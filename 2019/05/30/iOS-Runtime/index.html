<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS-Runtime | 涛涛</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS-Runtime</h1><a id="logo" href="/.">涛涛</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS-Runtime</h1><div class="post-meta">May 30, 2019</div><div class="post-content"><p>Runtime 相关示例代码：<a href="https://github.com/terryfine/BlogDemo/tree/master/RuntimDemo" target="_blank" rel="noopener">https://github.com/terryfine/BlogDemo/tree/master/RuntimDemo</a></p>
<h2 id="Objc-Runtime"><a href="#Objc-Runtime" class="headerlink" title="Objc Runtime"></a>Objc Runtime</h2><p>  源代码下载地址：<a href="http://www.opensource.apple.com/source/objc4/" target="_blank" rel="noopener">http://www.opensource.apple.com/source/objc4/</a></p>
<p>  Runtime 函数文档: <a href="https://developer.apple.com/documentation/objectivec/objective-c_runtime" target="_blank" rel="noopener">https://developer.apple.com/documentation/objectivec/objective-c_runtime</a></p>
<p>  苹果官方 Runtime 编程指南：<br>  <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048</a></p>
<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p> Objective-C 是一门动态语言，它将很多静态语言在编译和链接时做的事情推迟到运行时来处理。</p>
<p> 这种动态特性意味着 Objective-C 不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。<br> 对于 Objective-C 来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。</p>
<p> Runtime 就是使用 C 和汇编写的一个运行时库，一般我们说 Runtime，不但包含运行时库的意思，还包含了运行时、运行时系统等概念。</p>
<p><strong>Objc Runtime 使得 C 具有了面向对象能力，可以在程序运行时创建、检查、修改类、对象和它们的方法</strong>。</p>
<h3 id="2-Runtime-的作用："><a href="#2-Runtime-的作用：" class="headerlink" title="2. Runtime 的作用："></a>2. Runtime 的作用：</h3><h4 id="1-封装"><a href="#1-封装" class="headerlink" title="(1) 封装"></a>(1) 封装</h4><p> Runtime 库中，对象可以用 C 语言中的结构体表示，而方法可以用 C 函数来实现，再加上了一些其他的特性。这些结构体和函数被 runtime 函数封装后，就可以在程序运行时创建、检查、修改类、对象和它们的方法了。</p>
<h3 id="2-找到方法的最终执行代码"><a href="#2-找到方法的最终执行代码" class="headerlink" title="(2) 找到方法的最终执行代码"></a>(2) 找到方法的最终执行代码</h3><p> 当程序中执行 [receiver message] 时，会向消息接收者（receiver）发送一条消息 message，runtime 会根据消息接收者是否能响应该消息而做出不同的反应，即消息转发的流程。</p>
<h3 id="3-类和对象（Class-和-Object）相关的基本数据结构"><a href="#3-类和对象（Class-和-Object）相关的基本数据结构" class="headerlink" title="3. 类和对象（Class 和 Object）相关的基本数据结构"></a>3. 类和对象（Class 和 Object）相关的基本数据结构</h3><h4 id="1-关键词："><a href="#1-关键词：" class="headerlink" title="(1) 关键词："></a>(1) 关键词：</h4><p> Class：指向了 objc_class 结构体的指针<br>    id：参数类型，指向某个类实例的指针<br>    Method：代表了类中的某个方法的类型<br>    SEL：方法选择器，全名是 selector<br>    IMP：函数指针，由编译器生成，方法实现的代码就是由 IMP 指定<br>    Ivar：成员变量的类型<br>    Property：属性存储器<br>    Cache：方法调用的缓存器，为方法调用的性能进行优化</p>
<h4 id="2-objc-class-和-objc-object-数据结构："><a href="#2-objc-class-和-objc-object-数据结构：" class="headerlink" title="(2) objc_class 和 objc_object 数据结构："></a>(2) objc_class 和 objc_object 数据结构：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-objc-object-和-isa"><a href="#3-objc-object-和-isa" class="headerlink" title="(3) objc_object 和 isa"></a>(3) objc_object 和 isa</h4><p>objc_object 源代码在 objc-private.h line 75, 关键代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">ISA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">getIsa</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>objc_object 中的 isa，对应类型为联合体 isa_t，源代码在 objc-private.h line 61, 关键代码定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;                                         \         <span class="comment">//0:普通指针，1:优化过，使用位域存储更多信息</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;                                         \         <span class="comment">//对象是否含有或曾经含有关联引用</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;                                         \         <span class="comment">//表示是否有 C++ 析构函数或OC的 dealloc</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">44</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/</span> \         <span class="comment">//存放着 Class、Meta-Class 对象的内存地址信息</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;                                         \         <span class="comment">//用于在调试时分辨对象是否未完成初始化</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;                                         \         <span class="comment">//是否被弱引用指向</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;                                         \         <span class="comment">//对象是否正在释放</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;                                         \         <span class="comment">//是否需要使用 sidetable 来存储引用计数</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">8</span>                                                    <span class="comment">//引用计数能够用 8 个二进制位存储时，直接存储在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-objc-class"><a href="#4-objc-class" class="headerlink" title="(4) objc_class"></a>(4) objc_class</h4><p>objc_class 源代码可在 objc-runtime-new.h line 1111 看到，由于 objc_class 继承自 objc_object， 所以其关键结构可简化如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="keyword">isa_t</span> isa;                 <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class_rw_t</span> *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>objc_object 用来描述 OC 中的实例，当用口语描述实例时，总会说 「XX类的实例x」或「x是XX的实例」。objc_object 的 isa 在程序结构上表达类似的含义，它指向了该实例所对应的类，类在 runtime 中被描述成 objc_class 结构。<br>Objective-C 中的类本质上也是对象，称之为类对象，在 Objective-C 中有一个非常特殊的类 NSObject ，绝大部分的类都继承自它。它是 Objective-C 中的两个根类（rootclass）之一，另外一个是 NSProxy。<br>NSObject 只有一个成员变量 isa。所有继承自 NSObject 的类也都会有这个成员变量。</p>
<h4 id="5-元类（metaclass）、根类（root-class）、根元类（root-metaclass）"><a href="#5-元类（metaclass）、根类（root-class）、根元类（root-metaclass）" class="headerlink" title="(5) 元类（metaclass）、根类（root class）、根元类（root metaclass）"></a>(5) 元类（metaclass）、根类（root class）、根元类（root metaclass）</h4><p>本质上 Objective-C 中的类也是对象，它也是某个类的实例，这个类我们称之为元类（metaclass）。元类也是对象（元类对象），元类也是某个类的实例，这个类我们称之为根元类（root metaclass）。<br>不过，有一点比较特殊，那就是所有的元类所属的类都是同一个根元类（当然根元类也是元类，所以它所属的类也是根元类，即它本身）。根元类指的就是根类的元类，具体来说就是根类 NSObject 对应的元类。</p>
<p>通过调用类方法，比如 [NSObject new]，给类对象发送消息。同样的，类对象能否响应这个消息也要通过 isa 找到类对象所属的类（元类）才能知道。也就是说，实例方法是保存在类中的，而类方法是保存在元类中的。理论上我们也可以给元类发送消息，但是 Objective-C 倾向于隐藏元类，不想让大家知道元类的存在。元类是为了保持 Objective-C 对象模型在设计上的完整性而引入的，比如用来保存类方法等，它主要是用来给编译器使用的。</p>
<p>下图是为类（class），元类（metaclass），根类（root class），根元类（root metaclass）关系<br><img src="/2019/05/30/iOS-Runtime/object_model.png" alt=""></p>
<h4 id="6-superclass"><a href="#6-superclass" class="headerlink" title="(6) superclass"></a>(6) superclass</h4><p>指向该类的父类，如果该类已经是最顶层的根类（如 NSObject 或 NSProxy），则 superclass 为 NULL。</p>
<h4 id="7-cache-t"><a href="#7-cache-t" class="headerlink" title="(7) cache_t"></a>(7) cache_t</h4><p>cache_t 是一个散列表，用来缓存曾经调用过的方法，提高方法的查找速度。<br>源代码可在 objc-runtime-new.h line 59 找到，其关键结构如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span>     <span class="comment">// 散列表</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;                  <span class="comment">// 散列表的长度 -1</span></span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;              <span class="comment">// 已经缓存的方法数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">cache_key_t</span> _key;              <span class="comment">// SEL 作为 key</span></span><br><span class="line">    MethodCacheIMP _imp;           <span class="comment">// 函数的内存地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>buckets：</strong>指向 Method 数据结构指针的数组。这个数组可能包含不超过 mask+1 个元素。需要注意的是，指针可能是 NULL，表示这个缓存 bucket 没有被占用，另外被占用的 bucket 可能是不连续的。这个数组可能会随着时间而增长。</p>
<p><strong>mask：</strong>一个整数，指定分配的缓存 bucket 的总数。在方法查找过程中，Objective-C runtime 使用这个字段来确定开始线性查找数组的索引未知。指向方法 selector 的指针与该字段做一个 AND 位操作（index = (mask &amp; selector)）。这可以作为一个简单的 hash 散列算法。</p>
<p><strong>occupied：</strong>一个整数，指定实际占用的缓存 bucket 的总数。</p>
<h4 id="8-class-data-bits-t"><a href="#8-class-data-bits-t" class="headerlink" title="(8) class_data_bits_t"></a>(8) class_data_bits_t</h4><p>class_data_bits_t 是一个结构体，里面包含了一个 class_rw_t 类型的指针 data。class_rw_t 内部有个 class_ro_t 的指针 ro。class_rw_t 是可读可写的，class_ro_t 是只读的。 class_data_bits_t 源代码可以在 objc-runtime-new.h line 870 看到。</p>
<p><strong>class_rw_t</strong> 结构如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;             <span class="comment">// 保存类的原始数据(不包含分类内容和动态添加的方法)</span></span><br><span class="line">    <span class="keyword">method_array_t</span> methods;           <span class="comment">// 方法列表(如果是类对象存储的是对象方法,元类对象存储的是类方法)</span></span><br><span class="line">    <span class="keyword">property_array_t</span> properties;      <span class="comment">// 属性列表</span></span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;       <span class="comment">// 协议列表</span></span><br><span class="line">    Class firstSubclass;              <span class="comment">// 第一个子类</span></span><br><span class="line">    Class nextSiblingClass;           <span class="comment">// 兄弟类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>class_ro_t</strong> 储存了类的初始信息，不包括分类和后来动态添加的内容。class_ro_t 关键代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;                    <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;       <span class="comment">// 原始方法列表</span></span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;      <span class="comment">// 原始协议列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;            <span class="comment">// 成员变量列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;      <span class="comment">// 属性列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_list_t</span> *baseMethods() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>method_list_t</strong> 数组包含了多个 method_t，其中 method_t 也是结构体 ，其关键结构如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name;               <span class="comment">// 函数名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;      <span class="comment">// 方法参数 (包含了返回值类型,参数类型)</span></span><br><span class="line">    MethodListIMP imp;      <span class="comment">// 方法的实现 (指向函数的指针)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>ivar_list_t</strong> 数组包含了多个 ivar_t 类型的结构体 ivar，ivar_t 结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> *offset;               <span class="comment">// 变量在内存中相对所属对象内存空间起始地址的偏移量,偏移量大小根据类型来定</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;              <span class="comment">// 变量名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;              <span class="comment">// 变量类型</span></span><br><span class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment_raw;</span><br><span class="line">    <span class="keyword">uint32_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (alignment_raw == ~(<span class="keyword">uint32_t</span>)<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1U</span> &lt;&lt; WORD_SHIFT;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; alignment_raw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>property_list_t</strong> 数组包含多个 property_t，property_t 结构如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;             </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>class_ro_t 包含的类信息（方法、属性、协议等）都是在编译期就可以确定的，暂且称为元信息吧，在之后的逻辑中，它们显然是不希望被改变的；后续在用户层，无论是方法还是别的扩展，都是在 class_rw_t 上进行操作，这些操作都不会影响类的元信息。更多关于 class_rw_t 和 class_ro_t 的资料可查看 <a href="https://zhangbuhuai.com/post/runtime.html" target="_blank" rel="noopener">这篇文章</a>。</p>
<h3 id="4-类和对象相关操作方法"><a href="#4-类和对象相关操作方法" class="headerlink" title="4. 类和对象相关操作方法"></a>4. 类和对象相关操作方法</h3><p>操作类相关的函数一般以 class 为前缀，操作对象相关函数以 objc 或 object_ 为前缀。可在开篇 Runtime 函数文档查看相关方法。</p>
<h4 id="1-类相关操作函数"><a href="#1-类相关操作函数" class="headerlink" title="(1) 类相关操作函数"></a>(1) 类相关操作函数</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const <span class="keyword">char</span> * class_getName ( <span class="keyword">Class</span> cls )           <span class="comment">// 获取类名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Class</span> class_getSuperclass ( <span class="keyword">Class</span> cls )            <span class="comment">// 获取父类</span></span><br><span class="line"></span><br><span class="line">BOOL class_isMetaClass ( <span class="keyword">Class</span> cls )               <span class="comment">// 判断给定的类是不是元类</span></span><br><span class="line"></span><br><span class="line">size_t class_getInstanceSize ( <span class="keyword">Class</span> cls )         <span class="comment">// 获取类的实例大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> class_getVersion ( <span class="keyword">Class</span> cls )                 <span class="comment">// 获取版本号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> class_setVersion ( <span class="keyword">Class</span> cls, <span class="keyword">int</span> version )   <span class="comment">// 设置版本号</span></span><br></pre></td></tr></table></figure>
<h4 id="2-成员变量-ivars-和属性相关操作函数"><a href="#2-成员变量-ivars-和属性相关操作函数" class="headerlink" title="(2) 成员变量 (ivars) 和属性相关操作函数"></a>(2) 成员变量 (ivars) 和属性相关操作函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Ivar <span class="title">class_getInstanceVariable</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name )</span>                                           <span class="comment">// 获取类中指定名称实例成员变量的信息</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Ivar <span class="title">class_getClassVariable</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name )</span>                                              <span class="comment">// 获取类成员变量的信息</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addIvar</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> size, <span class="keyword">uint8_t</span> alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types )</span>    <span class="comment">// 在 runtime 时创建的类添加成员变量</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Ivar * <span class="title">class_copyIvarList</span> <span class="params">( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount )</span>                                          <span class="comment">// 获取整个成员变量列表，必须使用 free() 来释放</span></span></span><br></pre></td></tr></table></figure>
<h4 id="3-method-相关操作函数"><a href="#3-method-相关操作函数" class="headerlink" title="(3) method 相关操作函数"></a>(3) method 相关操作函数</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BOOL class_addMethod ( <span class="keyword">Class</span> cls, SEL name, IMP imp, <span class="keyword">const</span> char *types )       <span class="comment">// 添加方法，和成员变量不同的是可以为类动态添加方法。如果有同名会返回 NO，修改的话需要使用 method_setImplementation</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">class_getInstanceMethod</span> <span class="params">( <span class="keyword">Class</span> cls, SEL name )</span>                         // 获取实例方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Method</span> <span class="title">class_getClassMethod</span> <span class="params">( <span class="keyword">Class</span> cls, SEL name )</span>                            // 获取类方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Method</span> * <span class="title">class_copyMethodList</span> <span class="params">( <span class="keyword">Class</span> cls, unsigned int *outCount )</span>            // 获取所有方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">IMP</span> <span class="title">class_replaceMethod</span> <span class="params">( <span class="keyword">Class</span> cls, SEL name, IMP imp, <span class="keyword">const</span> char *types )</span>    // 实现替换方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">IMP</span> <span class="title">class_getMethodImplementation</span> <span class="params">( <span class="keyword">Class</span> cls, SEL name )</span>                      // 返回方法的具体实现</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">IMP</span> <span class="title">class_getMethodImplementation_stret</span> <span class="params">( <span class="keyword">Class</span> cls, SEL name )</span>                // 返回方法的具体实现</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">BOOL</span> <span class="title">class_respondsToSelector</span> <span class="params">( <span class="keyword">Class</span> cls, SEL sel )</span>                           // 类实例是否响应指定的 <span class="title">selector</span></span></span><br></pre></td></tr></table></figure>
<h4 id="4-protocol-相关操作函数"><a href="#4-protocol-相关操作函数" class="headerlink" title="(4) protocol 相关操作函数"></a>(4) protocol 相关操作函数</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BOOL</span> class_addProtocol ( Class <span class="keyword">cls</span>, Protocol *protocol )                       <span class="comment">// 添加协议</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BOOL</span> class_conformsToProtocol ( Class <span class="keyword">cls</span>, Protocol *protocol )                <span class="comment">// 返回类是否实现指定的协议</span></span><br><span class="line"></span><br><span class="line">Protocol * class_copyProtocolList ( Class <span class="keyword">cls</span>, unsigned int *outCount )        <span class="comment">// 获取类实现的协议列表</span></span><br></pre></td></tr></table></figure>
<h4 id="5-相关示例代码及输出："><a href="#5-相关示例代码及输出：" class="headerlink" title="(5) 相关示例代码及输出："></a>(5) 相关示例代码及输出：</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"> RuntimClass *runtimeClass = [[RuntimClass alloc] init]<span class="comment">;</span></span><br><span class="line"> Class cls = runtimeClass.class<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> // 类名</span><br><span class="line"> const char *clsName = class_getName(cls)<span class="comment">;</span></span><br><span class="line"> NSLog(@"类名：%s", clsName)<span class="comment">;</span></span><br><span class="line"> NSLog(@"**********************************")<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line"> // 父类</span><br><span class="line"> Class superCls = class_getSuperclass(cls)<span class="comment">;</span></span><br><span class="line"> NSLog(@"父类名：%s", class_getName(superCls))<span class="comment">;</span></span><br><span class="line"> NSLog(@"**********************************")<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line"> // 元类</span><br><span class="line"> BOOL isMetaCls = class_isMetaClass(cls)<span class="comment">;</span></span><br><span class="line"> NSLog(@"%s %@元类", clsName, (isMetaCls ? @"是" : @"不是"))<span class="comment">;</span></span><br><span class="line"> NSLog(@"**********************************")<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line"> Class metaCls = objc_getMetaClass(class_getName(cls))<span class="comment">;</span></span><br><span class="line"> NSLog(@"%s的元类是：%s", clsName, class_getName(metaCls))<span class="comment">;</span></span><br><span class="line"> NSLog(@"**********************************")<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line"> // 变量实例大小</span><br><span class="line"> size_t instanceSize = class_getInstanceSize(cls)<span class="comment">;</span></span><br><span class="line"> NSLog(@"%s的所有实例变量大小：%zu",clsName ,instanceSize)<span class="comment">;</span></span><br><span class="line"> NSLog(@"**********************************")<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line"> // 成员变量</span><br><span class="line"> unsigned int outCount = <span class="number">0</span><span class="comment">;</span></span><br><span class="line"> Ivar *ivars = class_copyIvarList(cls, &amp;outCount)<span class="comment">;</span></span><br><span class="line"> for (int i = <span class="number">0</span><span class="comment">; i &lt; outCount; i++) &#123;</span></span><br><span class="line">     Ivar ivar = ivars[i]<span class="comment">;</span></span><br><span class="line">     NSLog(@"成员变量%s在第%d的位置", ivar_getName(ivar), i)<span class="comment">;</span></span><br><span class="line">     NSLog(@"**********************************")<span class="comment">;</span></span><br><span class="line"> &#125;</span><br><span class="line"> free(ivars)<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line"> Ivar ivar = class_getInstanceVariable(cls, "_array")<span class="comment">;</span></span><br><span class="line"> if (ivar != NULL) &#123;</span><br><span class="line">     const char *ivarName = ivar_getName(ivar)<span class="comment">;</span></span><br><span class="line">     NSLog(@"成员变量：%s", ivarName)<span class="comment">;</span></span><br><span class="line">     NSLog(@"**********************************")<span class="comment">;</span></span><br><span class="line"> &#125; else &#123;</span><br><span class="line">     NSLog(@"没有此成员变量")<span class="comment">;</span></span><br><span class="line">     NSLog(@"**********************************")<span class="comment">;</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> // 属性</span><br><span class="line"> objc_property_t *properties = class_copyPropertyList(cls, &amp;outCount)<span class="comment">;</span></span><br><span class="line"> for (int i = <span class="number">0</span><span class="comment">; i &lt; outCount; i++) &#123;</span></span><br><span class="line">     objc_property_t property = properties[i]<span class="comment">;</span></span><br><span class="line">     NSLog(@"属性名称: %s", property_getName(property))<span class="comment">;</span></span><br><span class="line">     NSLog(@"**********************************")<span class="comment">;</span></span><br><span class="line"> &#125;</span><br><span class="line"> free(properties)<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line"> objc_property_t arrayProperty = class_getProperty(cls, "array")<span class="comment">;</span></span><br><span class="line"> if (arrayProperty != NULL) &#123;</span><br><span class="line">     const char *arryPropertyName = property_getName(arrayProperty)<span class="comment">;</span></span><br><span class="line">     NSLog(@"属性%s", arryPropertyName)<span class="comment">;</span></span><br><span class="line">     NSLog(@"**********************************")<span class="comment">;</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> //方法</span><br><span class="line"> Method *methods = class_copyMethodList(cls, &amp;outCount)<span class="comment">;   //包含category添加的方法</span></span><br><span class="line"> for (int i = <span class="number">0</span><span class="comment">; i &lt; outCount; i++) &#123;</span></span><br><span class="line">     Method method = methods[i]<span class="comment">;</span></span><br><span class="line">     SEL methodSignature = method_getName(method)<span class="comment">;</span></span><br><span class="line">     NSLog(@"方法签名: %s", methodSignature)<span class="comment">;</span></span><br><span class="line">     NSLog(@"**********************************")<span class="comment">;</span></span><br><span class="line"> &#125;</span><br><span class="line"> free(methods)<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line"> Method method1 = class_getInstanceMethod(cls, @selector(method2))<span class="comment">;</span></span><br><span class="line"> if (method1 != NULL) &#123;</span><br><span class="line">     SEL method1Signature = method_getName(method1)<span class="comment">;</span></span><br><span class="line">     NSLog(@"方法%s",method1Signature)<span class="comment">;</span></span><br><span class="line">     NSLog(@"**********************************")<span class="comment">;</span></span><br><span class="line"> &#125; else &#123;</span><br><span class="line">     NSLog(@"未找到此方法")<span class="comment">;</span></span><br><span class="line">     NSLog(@"**********************************")<span class="comment">;</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> Method classMethod = class_getClassMethod(cls, @selector(classMethod))<span class="comment">;</span></span><br><span class="line"> if (classMethod != NULL) &#123;</span><br><span class="line">     SEL classMethodName = method_getName(classMethod)<span class="comment">;</span></span><br><span class="line">     NSLog(@"类方法 %s", classMethodName)<span class="comment">;</span></span><br><span class="line">     NSLog(@"**********************************")<span class="comment">;</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> BOOL responds = class_respondsToSelector(cls, @selector(method4WithArg1:arg2:))<span class="comment">;</span></span><br><span class="line"> if (responds) &#123;</span><br><span class="line">     Method respondsMethod = class_getInstanceMethod(cls, @selector(method4WithArg1:arg2:))<span class="comment">;</span></span><br><span class="line">     SEL respondsMethodName = method_getName(respondsMethod)<span class="comment">;</span></span><br><span class="line">     NSLog(@"%s响应方法%s", clsName, respondsMethodName)<span class="comment">;</span></span><br><span class="line">     NSLog(@"**********************************")<span class="comment">;</span></span><br><span class="line"> &#125; else &#123;</span><br><span class="line">     NSLog(@"%s不响应此方法", clsName)<span class="comment">;</span></span><br><span class="line">     NSLog(@"**********************************")<span class="comment">;</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> IMP imp = class_getMethodImplementation(cls, @selector(method1))<span class="comment">;</span></span><br><span class="line"> imp()<span class="comment">;</span></span><br><span class="line"> NSLog(@"**********************************")<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line"> // 协议</span><br><span class="line"> Protocol __unsafe_unretained **protocols = class_copyProtocolList(cls, &amp;outCount)<span class="comment">;</span></span><br><span class="line"> for (int i = <span class="number">0</span><span class="comment">; i &lt; outCount; i++) &#123;</span></span><br><span class="line">     Protocol * protocol = protocols[i]<span class="comment">;</span></span><br><span class="line">     const char *protocalName = protocol_getName(protocol)<span class="comment">;</span></span><br><span class="line">     NSLog(@"协议名称：%s", protocalName)<span class="comment">;</span></span><br><span class="line">     NSLog(@"**********************************")<span class="comment">;</span></span><br><span class="line"> &#125;</span><br><span class="line"> Protocol * protocol = protocols[<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line"> BOOL conformProtocol = class_conformsToProtocol(cls, protocol)<span class="comment">;</span></span><br><span class="line"> NSLog(@"%s%@遵循协议%s", clsName, (conformProtocol ? @"" : @"不"), protocol_getName(protocol))<span class="comment">;</span></span><br><span class="line"> NSLog(@"**********************************")<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">输出日志如下：</span><br><span class="line"></span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.595856</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 类名：RuntimClass</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.596386</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.596500</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 父类名：NSObject</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.596584</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.596721</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] RuntimClass 不是元类</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.596798</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.596890</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] RuntimClass的元类是：RuntimClass</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.596966</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.597060</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] RuntimClass的所有实例变量大小：<span class="number">56</span></span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26:12.597136</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26:12.597251</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 成员变量firstInstance在第<span class="number">0</span>的位置</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.597429</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.597622</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 成员变量secondInstance在第<span class="number">1</span>的位置</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.597803</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.601663</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 成员变量thirdInstance在第<span class="number">2</span>的位置</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.601739</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.601823</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 成员变量_array在第<span class="number">3</span>的位置</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.601888</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.601965</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 成员变量_string在第<span class="number">4</span>的位置</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.602033</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26:12.602106</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 成员变量_index在第<span class="number">5</span>的位置</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26:12.602168</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.602479</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 成员变量：_array</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.602681</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.602908</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 属性名称: array</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.603056</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.603266</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 属性名称: string</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.603464</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.603662</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 属性名称: index</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.603887</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26:12.604116</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 属性名称: hash</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.604339</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.604568</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 属性名称: superclass</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.604777</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.604990</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 属性名称: description</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26:12.605190</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.605425</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 属性名称: debugDescription</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.605645</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.605936</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 属性array</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26:12.606183</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.606395</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 方法签名: method2</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.606628</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.606834</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 方法签名: method4WithArg1:arg2:</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.607034</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26:12.607246</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 方法签名: method1</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.607447</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.607663</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 方法签名: runtimeClassProtocol</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.607879</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26:12.608107</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 方法签名: method3</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.608328</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.608544</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 方法签名: categoryMethod</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.608751</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.609075</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 方法签名: setArray:</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.609301</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.609538</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 方法签名: .cxx_destruct</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.609716</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.609900</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 方法签名: array</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.610099</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.610279</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 方法签名: setString:</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.610425</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.610653</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 方法签名: string</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.610860</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.611082</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 方法签名: index</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.611292</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.611517</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 方法签名: setIndex:</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.611719</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.611945</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 方法method2</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26:12.612125</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.612359</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 类方法 classMethod</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.612575</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.612797</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] RuntimClass响应方法method4WithArg1:arg2:</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.612966</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26:12.613153</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] method1 被调用</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.613371</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.613612</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 协议名称：RuntimeClassProtocol</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.613829</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.614063</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 协议名称：NSCopying</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26:12.614253</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.614446</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] 协议名称：NSCoding</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.614655</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.614887</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] RuntimClass遵循协议NSCopying</span><br><span class="line"><span class="number">2019-06-15</span> <span class="number">18</span>:<span class="number">26</span>:<span class="number">12.615037</span>+<span class="number">0800</span> RuntimDemo[<span class="number">18732</span>:<span class="number">16102829</span>] **********************************</span><br></pre></td></tr></table></figure>
<h3 id="5-消息与消息转发"><a href="#5-消息与消息转发" class="headerlink" title="5. 消息与消息转发"></a>5. 消息与消息转发</h3><h4 id="1-Method-基础数据结构："><a href="#1-Method-基础数据结构：" class="headerlink" title="(1) Method 基础数据结构："></a>(1) Method 基础数据结构：</h4><p>  Method 是 method_t 结构体的指针，method_t 在分析 method_list_t 已写出其结构，其结构中包括 SEL 和 IMP 两种数据结构。</p>
<p><strong>SEL：</strong>Objective-C 在编译的时候，objc_selector 会依据方法的名字、参数序列、生成一个整型标识的地址<br>( int 类型的地址)：这个标识就是 SEL，其结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *<span class="title">SEL</span></span></span><br></pre></td></tr></table></figure>
<p><strong>IMP：</strong>是一个函数指针，指向方法实现的地址。其结构如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A pointer to the function of a method implementation. </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*IMP)</span><span class="params">(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> )</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>SEL 和 IMP 为映射关系：</strong>SEL 通过 Dispatch table 表寻找到对应的 IMP， Dispatch table 表存放 SEL 和 IMP 的映射。我们可以对一个编号 (SEL) 和什么方法 (IMP) 映射做些操作，也就是说我们可以一个 SEL 指向不同的函数指针，这样就可以完成一个方法名在不同时候执行不同的函数体。</p>
<h4 id="2-相关操作方法："><a href="#2-相关操作方法：" class="headerlink" title="(2) 相关操作方法："></a>(2) 相关操作方法：</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用指定方法的实现，返回的是方法实现时的返回，参数 receiver 不能为空，这个比 method_getImplementation 和 method_getName 速度快</span></span><br><span class="line">void method_invoke_stret ( id receiver, <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, ... )</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 调用返回一个数据结构的方法的实现              </span></span><br><span class="line"><span class="function"><span class="title">id</span> <span class="title">method_invoke</span> <span class="params">( id receiver, <span class="keyword">Method</span> m, ... )</span>           </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 获取方法名，希望获得方法名的 <span class="title">C</span> 字符串，使用 <span class="title">sel_getName</span><span class="params">(method_getName(<span class="keyword">method</span>)</span>)          </span></span><br><span class="line"><span class="function"><span class="title">SEL</span> <span class="title">method_getName</span> <span class="params">( <span class="keyword">Method</span> m )</span>                   </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回方法的实现                  </span></span><br><span class="line"><span class="function"><span class="title">IMP</span> <span class="title">method_getImplementation</span> <span class="params">( <span class="keyword">Method</span> m )</span>    </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 获取描述方法参数和返回值类型的字符串                        </span></span><br><span class="line"><span class="function"><span class="title">const</span> <span class="title">char</span> * <span class="title">method_getTypeEncoding</span> <span class="params">( <span class="keyword">Method</span> m )</span>    </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 获取方法的返回值类型的字符串                 </span></span><br><span class="line"><span class="function"><span class="title">char</span> * <span class="title">method_copyReturnType</span> <span class="params">( <span class="keyword">Method</span> m )</span>         </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 获取方法的指定位置参数的类型字符串                    </span></span><br><span class="line"><span class="function"><span class="title">char</span> * <span class="title">method_copyArgumentType</span> <span class="params">( <span class="keyword">Method</span> m, unsigned int <span class="keyword">index</span> )</span>      </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 通过引用返回方法的返回值类型字符串</span></span><br><span class="line"><span class="function"><span class="title">void</span> <span class="title">method_getReturnType</span> <span class="params">( <span class="keyword">Method</span> m, char *dst, size_t dst_len )</span>    </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回方法的参数的个数</span></span><br><span class="line"><span class="function"><span class="title">unsigned</span> <span class="title">int</span> <span class="title">method_getNumberOfArguments</span> <span class="params">( <span class="keyword">Method</span> m )</span>               </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 通过引用返回方法指定位置参数的类型字符串</span></span><br><span class="line"><span class="function"><span class="title">void</span> <span class="title">method_getArgumentType</span> <span class="params">( <span class="keyword">Method</span> m, unsigned int <span class="keyword">index</span>, char *dst, size_t dst_len )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回指定方法的方法描述结构体</span></span><br><span class="line"><span class="function"><span class="title">struct</span> <span class="title">objc_method_description</span> * <span class="title">method_getDescription</span> <span class="params">( <span class="keyword">Method</span> m )</span>  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 设置方法的实现</span></span><br><span class="line"><span class="function"><span class="title">IMP</span> <span class="title">method_setImplementation</span> <span class="params">( <span class="keyword">Method</span> m, IMP imp )</span>           </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 交换两个方法的实现</span></span><br><span class="line"><span class="function"><span class="title">void</span> <span class="title">method_exchangeImplementations</span> <span class="params">( <span class="keyword">Method</span> m1, <span class="keyword">Method</span> m2 )</span>     </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回给定选择器指定的方法的名称    </span></span><br><span class="line"><span class="function"><span class="title">const</span> <span class="title">char</span> * <span class="title">sel_getName</span> <span class="params">( SEL sel )</span>          </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回 <span class="title">Runtime</span> 系统中注册的方法，方法名映射的选择器                       </span></span><br><span class="line"><span class="function"><span class="title">SEL</span> <span class="title">sel_registerName</span> <span class="params">( <span class="keyword">const</span> char *str )</span>                             </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Runtime</span> 系统中注册一个方法</span></span><br><span class="line"><span class="function"><span class="title">SEL</span> <span class="title">sel_getUid</span> <span class="params">( <span class="keyword">const</span> char *str )</span>           </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 比较两个选择器                        </span></span><br><span class="line"><span class="function"><span class="title">BOOL</span> <span class="title">sel_isEqual</span> <span class="params">( SEL lhs, SEL rhs )</span></span></span><br></pre></td></tr></table></figure>
<h4 id="4-Method-调用流程："><a href="#4-Method-调用流程：" class="headerlink" title="(4) Method 调用流程："></a>(4) Method 调用流程：</h4><p><strong>objc_msgSend 函数：</strong> 这个函数将消息接收者和方法名作为基础参数。消息发送给一个对象时，objc_msgSend 通过对象的 isa 指针获得类的结构体，先在 Cache 里找，找到就执行，没找到就在分发列表里查找方法的 selector，没找到就通过 objc_msgSend 结构体中指向父类的指针找到父类，然后在父类分发列表找，直到 root class（NSObject）。Objc 中发送消息是用中括号把接收者和消息括起来，只到运行时才会把消息和方法实现绑定。为了加快速度，苹果对这个方法做了很多优化，这个方法是用汇编实现的。<br>objc_msgSend 定义如下：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">objc_msgSend</span>(<span class="params">receiver, selector, arg1, arg2, ...</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>objc_msgSend 内部实现大致流程：首先在 Class 中的缓存查找 imp（没缓存则初始化缓存），如果没找到就去父类的 Class 查找，如果一直查到到根类仍旧没有实现，则用 <em>_objc_msgForward</em> 函数指针代替 imp， 最后执行 imp。 <em>_objc_msgForward</em>  是用于消息转发的，当方法没有被寻找到的时候，就会触发消息转发流程。</p>
<p><strong>消息转发流程：</strong>当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息，如果是以 [receiver message] 的方式调用方法，那么如果 receiver 无法响应 message 消息时，编译器就会报错。但如果是 perform… 的形式来调用，则需要等到运行时才能确定 receiver 是否能接受 message 消息。如果不能，则程序崩溃。消息转发的流程，可以分为三个阶段: 方法解析、重定向、消息转发。</p>
<p><em>tips:</em> 通常，当不能确定一个对象是否能接收某个消息时，会先调用 respondsToSelector: 来判断一下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">if</span> ([self <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(method)]) &#123;</span><br><span class="line">    <span class="selector-attr">[self performSelector:@selector(method)]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>方法解析：</strong>当 runtime 在方法缓存列表和方法分发列表（包括超类）中找不到要执行的方法时，首先会进入方法解析阶段，此时可以在方法解析中动态添加方法实现。具体操作的函数如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例方法找不到实现的情况，可以在方法解析中动态添加方法实现</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel     </span><br><span class="line"></span><br><span class="line"><span class="comment">//类方法找不到实现的情况，可以在方法解析中动态添加方法实现</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态添加一个方法，Class cls 是要指定的类，runtime 会到这个类中去找方法， SEL name 是要解析的方法，IMP 是动态添加的方法实现的 imp ，const char *types : 类型编码，是个字符串</span></span><br><span class="line">class_addMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span><br></pre></td></tr></table></figure></p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">类型编码文档</a></p>
<p><strong>重定向：</strong>在消息转发机制执行前，系统会再给我们一次偷梁换柱的机会通过重载 <em>forwardingTargetForSelector</em> 方法替换消息的接受者为其他对象，毕竟消息转发需要耗费更多的时间，如果此方法返回 nil 或是 self，则会进入消息转发阶段。但是替换的对象千万不要是 self，那样会进入死循环。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (id)<span class="selector-tag">forwardingTargetForSelector</span><span class="selector-pseudo">:(SEL)aSelector</span> &#123;</span><br><span class="line">    <span class="selector-tag">if</span> (aSelector == <span class="variable">@selector</span>(<span class="attribute">mysteriousMethod</span>:)) &#123;</span><br><span class="line">       <span class="selector-tag">return</span> <span class="selector-tag">alternateObject</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-attr">[super forwardingTargetForSelector:aSelector]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>消息转发：</strong><br>如果以上两种都没法处理未知消息就需要完整消息转发了，调用如下方法：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这一步是最后机会将消息转发给其它对象，对象会将未处理的消息相关的 selector，target 和参数都封装在 anInvocation 中。forwardInvocation :像未知消息分发中心，将未知消息转发给其它对象。注意的是 forwardInvocation: 方法只有在消息接收对象无法正常响应消息时才被调用。</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">forwardInvocation</span><span class="selector-pseudo">:(NSInvocation</span> *)<span class="selector-tag">anInvocation</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//必须重写这个方法，消息转发使用这个方法获得的信息创建 NSInvocation 对象。</span></span><br><span class="line"><span class="selector-tag">-</span> (NSMethodSignature *)<span class="selector-tag">methodSignatureForSelector</span><span class="selector-pseudo">:(SEL)aSelector</span></span><br></pre></td></tr></table></figure></p>
<p><a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/" target="_blank" rel="noopener">消息转发更详细资料</a></p>
<h4 id="5-Method-Swizzling："><a href="#5-Method-Swizzling：" class="headerlink" title="(5) Method Swizzling："></a>(5) Method Swizzling：</h4><p>Objective-C 中的 Method Swizzling 允许我们动态地替换方法的实现，实现 Hook 功能，是一种比子类化更加灵活的“重写”方法的方式。讲 Method 结构的时候提到过：原则上方法的名称 name 和方法的实现 imp 是一一对应的，而 Method Swizzling 的原理就是动态地改变它们的对应关系，达到替换方法实现的目的，如下代码实现了 NSArray 异常操作的崩溃拦截功能：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"NSArray+SafeArray.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> 在 iOS 中 NSNumber、NSArray、NSDictionary 等这些类都是类簇，一个 NSArray 的实现可能由多个类组成。所以如果想对 NSArray 进行 Swizzling，必须获取到其“真身”进行 Swizzling，直接对 NSArray 进行操作是无效的。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 下面列举了 NSArray 和 NSDictionary 本类的类名，可以通过Runtime函数取出本类。</span></span><br><span class="line"><span class="comment"> NSArray                __NSArrayI</span></span><br><span class="line"><span class="comment"> NSMutableArray         __NSArrayM</span></span><br><span class="line"><span class="comment"> NSDictionary           __NSDictionaryI</span></span><br><span class="line"><span class="comment"> NSMutableDictionary	__NSDictionaryM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSArray</span> (<span class="title">SafeArray</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意下面的load方法中，不应该调用父类的load方法</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    Method fromMethod = class_getInstanceMethod(objc_getClass(<span class="string">"__NSArrayI"</span>), <span class="keyword">@selector</span>(objectAtIndex:));</span><br><span class="line">    Method toMethod = class_getInstanceMethod(objc_getClass(<span class="string">"__NSArrayI"</span>), <span class="keyword">@selector</span>(safe_objectAtIndex:));</span><br><span class="line">    method_exchangeImplementations(fromMethod, toMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了避免和系统的方法冲突在 swizzling 方法前面加前缀</span></span><br><span class="line">- (<span class="keyword">id</span>)safe_objectAtIndex:(<span class="built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.count<span class="number">-1</span> &lt; index) &#123;</span><br><span class="line">        <span class="comment">// 如果越界就进入异常拦截</span></span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> safe_objectAtIndex:index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">            <span class="comment">// 崩溃后收集日志</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"---------- %s Crash Because Method %s  ----------\n"</span>, class_getName(<span class="keyword">self</span>.class), __func__);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [exception callStackSymbols]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@finally</span> &#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有问题，则正常进行方法调用</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> safe_objectAtIndex:index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p><strong>使用 Method Swizzling 注意的点：</strong></p>
<p><strong>1 ）在 +load 方法中实现 Method Swizzling 的逻辑而不是在 +initialize ：</strong></p>
<p>+load 和 +initialize 是 Objective-C runtime 会自动调用的两个类方法，但是它们的调用时机是不一样的。+load 方法是在类被加载的时候调用的，而 +initialize 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法调用。也就是说 +initialize 方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 +initialize 方法是永远不会被调用的。此外 +load 方法还有一个非常重要的特性，那就是子类、父类和分类中的 +load 方法的实现是被区别对待的。也就是说在 Objective-C runtime 自动调用 +load 方法时，分类中的 +load 方法并不会对主类中的 +load 方法造成覆盖。所以在 +load 方法是实现 Method Swizzling 逻辑是最佳选择。</p>
<p><strong>2 ）用 dispatch_once 来进行调度：</strong></p>
<p>+load 方法在类加载的时候会被 runtime 自动调用一次，但是它并没有限制程序员对 +load 方法的手动调用，所以使用 dispatch_once 确保代码不管有多少线程都只被执行一次。</p>
<p><strong>3 ）需要调用 class_addMethod 方法，并且以它的结果为依据分别处理两种不同的情况：</strong></p>
<p>使用 Method Swizzling 的目的通常都是为了给程序增加功能，而不是完全替换某个功能，所以我们一般都需要在自定义的实现中调用原始的实现，所以这里就会有两种情况需要我们分别进行处理：</p>
<p><em>第一种情况：</em>主类本身有实现需要替换的方法，也就是 class_addMethod 方法返回 NO 时，直接交换两个方法的实现就可以了。</p>
<p><em>第二种情况：</em>主类本身没有实现需要替换的方法，而是继承了父类的实现，即 class_addMethod 方法返回 YES。这时调用 class_getInstanceMethod 函数获取到的 originalSelector 指向的就是父类的方法，我们再通过执行 lass_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); 将父类的实现替换到我们自定义的方法中，这样就达到了在自定义方法的实现中调用父类实现的目的。</p>
<p><strong>4）Selector，Method 和 Implementation 的关系：</strong></p>
<p>一个类维护一个运行时可接收的消息分发表，分发表中每个入口是一个 Method，其中 key 是一个特定的名称即 SEL，与其对应的实现是 IMP 即指向底层 C 函数的指针。</p>
<p><a href="https://juejin.im/entry/584912648e450a006c4be90a" target="_blank" rel="noopener">Runtime Method Swizzling 开发实例汇总</a></p>
<h3 id="6-Category-和-Protocol"><a href="#6-Category-和-Protocol" class="headerlink" title="6. Category 和 Protocol"></a>6. Category 和 Protocol</h3><h4 id="1-Category-数据结构："><a href="#1-Category-数据结构：" class="headerlink" title="(1) Category 数据结构："></a>(1) Category 数据结构：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; </span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span>         <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span>            <span class="comment">// 类方法列表，Meta Class方法列表的子集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>             <span class="comment">// 分类所实现的协议列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span>    </span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span>      </span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_list_t</span> *methodsForMeta(<span class="keyword">bool</span> isMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">property_list_t</span> *propertiesForMeta(<span class="keyword">bool</span> isMeta, struct header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-Category-的用途："><a href="#2-Category-的用途：" class="headerlink" title="(2) Category 的用途："></a>(2) Category 的用途：</h4><p> 1 ) 给现有的类添加方法</p>
<p> 2 ) 将一个类的实现拆分成多个独立的源文件</p>
<p> 3 ) 声明私有的方法</p>
<p><em>注意:</em> Category 有一个非常容易误用的场景，那就是用 Category 来覆写父类或主类的方法。虽然目前 Objective-C 是允许这么做的，但是这种使用场景是非常不推荐的。使用 Category 来覆写方法有很多缺点，比如不能覆写 Category 中的方法、无法调用主类中的原始实现等，且很容易造成无法预估的行为。 </p>
<h4 id="3-Category-的实现原理："><a href="#3-Category-的实现原理：" class="headerlink" title="(3) Category 的实现原理："></a>(3) Category 的实现原理：</h4><p>1 ）在编译时期，会将 Category 中实现的方法生成一个结构体 method_list_t ，将声明的属性生成一个结构体 property_list_t ，然后通过这些结构体生成一个结构体 category_t 并保存。</p>
<p>2 ）在运行时期，Runtime 会拿到编译时期我们保存下来的结构体 category_t 然后将结构体 category_t 中的实例方法列表、协议列表、属性列表添加到主类中。</p>
<p>3 ）将结构体 category_t 中的类方法列表、协议列表添加到主类的 metaClass 中。</p>
<p><em>注意点 (1)：</em>category_t 中的方法列表是插入到主类的方法列表前面，所以这里 Category 中实现的方法并不会真正的覆盖掉主类中的方法，只是将 Category 的方法插到方法列表的前面去了，运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会停止查找，即会出现覆盖方法的这种假象了。</p>
<p><em>注意点 (2)：</em>Category 添加实例变量，因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局。</p>
<p>关键代码在 objc-runtime-new.mm 中的 _read_images 方法中实现，如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span><span class="emphasis">_read_</span>images</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Perform initial processing of </span>the<span class="markdown"> headers in </span>the<span class="markdown"> linked </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>list beginning with headerList. </span></span></span><br><span class="line"><span class="comment"><span class="markdown">*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Called by: map<span class="emphasis">_images_</span>nolock</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Locking: runtimeLock acquired by map_images</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>/</span></span></span><br><span class="line"><span class="keyword">void</span> _read_images(header_info **hList, uint32_t hCount, <span class="built_in">int</span> totalClasses, <span class="built_in">int</span> unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">    header_info *hi;</span><br><span class="line">    uint32_t hIndex;</span><br><span class="line">    size_t count;</span><br><span class="line">    size_t i;</span><br><span class="line">    Class *resolvedFutureClasses = nil;</span><br><span class="line">    size_t resolvedFutureClassCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">bool</span> doneOnce;</span><br><span class="line">    TimeLogger ts(PrintImageTimes);</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">#define EACH_HEADER \</span><br><span class="line">    hIndex = <span class="number">0</span>;         \</span><br><span class="line">    hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \</span><br><span class="line">    hIndex++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!doneOnce) &#123;</span><br><span class="line">        doneOnce = YES;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DisableTaggedPointers) &#123;</span><br><span class="line">            disableTaggedPointers();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        initializeTaggedPointerObfuscator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: found %d classes during launch"</span>, totalClasses);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// namedClasses</span></span><br><span class="line">        <span class="comment">// Preoptimized classes don't go in this table.</span></span><br><span class="line">        <span class="comment">// 4/3 is NXMapTable's load factor</span></span><br><span class="line">        <span class="built_in">int</span> namedClassesSize = </span><br><span class="line">            (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * <span class="number">4</span> / <span class="number">3</span>;</span><br><span class="line">        gdb_objc_realized_classes =</span><br><span class="line">            NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);</span><br><span class="line">        </span><br><span class="line">        allocatedClasses = NXCreateHashTable(NXPtrPrototype, <span class="number">0</span>, nil);</span><br><span class="line">        </span><br><span class="line">        ts.log(<span class="string">"IMAGE TIMES: first time tasks"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover categories. </span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        category_t **catlist = </span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        <span class="built_in">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            category_t *cat = catlist[i];</span><br><span class="line">            Class cls = remapClass(cat-&gt;cls);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                <span class="comment">// Category's target class is missing (probably weak-linked).</span></span><br><span class="line">                <span class="comment">// Disavow any knowledge of this category.</span></span><br><span class="line">                catlist[i] = nil;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: IGNORING category \?\?\?(%s) %p with "</span></span><br><span class="line">                                 <span class="string">"missing weak-linked target class"</span>, </span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process this category. </span></span><br><span class="line">            <span class="comment">// First, register the category with its target class. </span></span><br><span class="line">            <span class="comment">// Then, rebuild the class's method lists (etc) if </span></span><br><span class="line">            <span class="comment">// the class is realized. </span></span><br><span class="line">            <span class="built_in">bool</span> classExists = NO;</span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">                ||  cat-&gt;instanceProperties) </span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: found category -%s(%s) %s"</span>, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name, </span><br><span class="line">                                 classExists ? <span class="string">"on existing class"</span> : <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls-&gt;ISA());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: found category +%s(%s)"</span>, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.log(<span class="string">"IMAGE TIMES: discover categories"</span>);</span><br><span class="line">#undef EACH_HEADER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码主要完成了一下以下几件事：</p>
<p>1 ）将 Category 和它的主类（或元类）注册到哈希表中</p>
<p>2 ）如果主类（或元类）已实现，那么重建它的方法列表</p>
<p>3 ）Category 中的实例方法和属性被整合到主类中；而类方法则被整合到元类中</p>
<p>4 ）对协议的处理比较特殊，Category 中的协议被同时整合到了主类和元类中</p>
<p>上述代码中通过 static void remethodizeClass(Class cls) 函数来重新整理类的数据结构，代码如下：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void remethodizeClass(<span class="class"><span class="keyword">Class</span> <span class="title">cls</span>)</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    <span class="keyword">bool</span> isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-methodizing: check for more categories</span></span><br><span class="line">    <span class="keyword">if</span> ((cats = unattachedCategoriesForClass(cls, <span class="keyword">false</span><span class="comment">/*not realizing*/</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: attaching categories to class '%s' %s"</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? <span class="string">"(meta)"</span> : <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        attachCategories(cls, cats, <span class="keyword">true</span> <span class="comment">/*flush caches*/</span>);        </span><br><span class="line">        free(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数的主要作用是将 Category 中的方法、属性和协议整合到类（主类或元类）中，更新类的数据字段 data() 中 method_lists（或 method_list）、properties 和 protocols 的值。上述代码中真正处理 Category 的方法是 attachCategories 方法，源码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Attach method lists and properties and protocols from categories to a class.</span></span><br><span class="line"><span class="comment">// Assumes the categories in cats are all loaded and sorted by load order, </span></span><br><span class="line"><span class="comment">// oldest categories first.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">attachCategories(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme rearrange to remove these intermediate allocations</span></span><br><span class="line">    <span class="keyword">method_list_t</span> **mlists = (<span class="keyword">method_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">    <span class="keyword">property_list_t</span> **proplists = (<span class="keyword">property_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*proplists));</span><br><span class="line">    <span class="keyword">protocol_list_t</span> **protolists = (<span class="keyword">protocol_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*protolists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count;</span><br><span class="line">    <span class="keyword">bool</span> fromBundle = NO;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats-&gt;<span class="built_in">list</span>[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">property_list_t</span> *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    <span class="built_in">free</span>(mlists);</span><br><span class="line">    <span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    <span class="built_in">free</span>(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    <span class="built_in">free</span>(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-Protocol"><a href="#4-Protocol" class="headerlink" title="(4) Protocol"></a>(4) Protocol</h4><p>Protocol 结构如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uintptr_t</span> <span class="keyword">protocol_ref_t</span>;  <span class="comment">// protocol_t *, but unremapped</span></span><br></pre></td></tr></table></figure></p>
<p>protocol_ref_t 指向 protocol_t，而 protocol_t 继承自 objc_object，所以 Protocol 是对象结构体，protocol_t 关键结构如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">protocol_t</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *instanceMethods;</span><br><span class="line">    <span class="keyword">method_list_t</span> *classMethods;</span><br><span class="line">    <span class="keyword">method_list_t</span> *optionalInstanceMethods;</span><br><span class="line">    <span class="keyword">method_list_t</span> *optionalClassMethods;</span><br><span class="line">    <span class="keyword">property_list_t</span> *instanceProperties;</span><br><span class="line">    <span class="keyword">uint32_t</span> size;   <span class="comment">// sizeof(protocol_t)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **_extendedMethodTypes;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *_demangledName;</span><br><span class="line">    <span class="keyword">property_list_t</span> *_classProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-Category-和-Protocol-的操作方法"><a href="#5-Category-和-Protocol-的操作方法" class="headerlink" title="(5) Category 和 Protocol 的操作方法"></a>(5) Category 和 Protocol 的操作方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定的协议</span></span><br><span class="line"><span class="function">Protocol * <span class="title">objc_getProtocol</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运行时所知道的所有协议的数组</span></span><br><span class="line"><span class="function">Protocol ** <span class="title">objc_copyProtocolList</span> <span class="params">( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的协议实例</span></span><br><span class="line"><span class="function">Protocol * <span class="title">objc_allocateProtocol</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在运行时中注册新创建的协议，创建一个新协议后必须使用这个进行注册这个新协议，但是注册后不能够再修改和添加新方法。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_registerProtocol</span> <span class="params">( Protocol *proto )</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 为协议添加方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">protocol_addMethodDescription</span> <span class="params">( Protocol *proto, SEL name, <span class="keyword">const</span> <span class="keyword">char</span> *types, BOOL isRequiredMethod, BOOL isInstanceMethod )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个已注册的协议到协议中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">protocol_addProtocol</span> <span class="params">( Protocol *proto, Protocol *addition )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为协议添加属性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">protocol_addProperty</span> <span class="params">( Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回协议名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">protocol_getName</span> <span class="params">( Protocol *p )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试两个协议是否相等</span></span><br><span class="line"><span class="function">BOOL <span class="title">protocol_isEqual</span> <span class="params">( Protocol *proto, Protocol *other )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中指定条件的方法的方法描述数组</span></span><br><span class="line"><span class="function">struct objc_method_description * <span class="title">protocol_copyMethodDescriptionList</span> <span class="params">( Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中指定方法的方法描述</span></span><br><span class="line"><span class="function">struct objc_method_description <span class="title">protocol_getMethodDescription</span> <span class="params">( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中的属性列表</span></span><br><span class="line"><span class="keyword">objc_property_t</span> * protocol_copyPropertyList ( Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议的指定属性</span></span><br><span class="line"><span class="keyword">objc_property_t</span> protocol_getProperty ( Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, BOOL isRequiredProperty, BOOL isInstanceProperty );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议采用的协议</span></span><br><span class="line"><span class="function">Protocol ** <span class="title">protocol_copyProtocolList</span> <span class="params">( Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看协议是否采用了另一个协议</span></span><br><span class="line"><span class="function">BOOL <span class="title">protocol_conformsToProtocol</span> <span class="params">( Protocol *proto, Protocol *other )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="7-Extention"><a href="#7-Extention" class="headerlink" title="(7) Extention"></a>(7) Extention</h4><p><strong>Extention 格式如下：</strong><br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> ClassName()</span><br><span class="line"><span class="comment">//私有属性</span></span><br><span class="line"><span class="comment">//私有方法，如果不实现，编译时会报警</span></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p><strong>(2) Extension 的作用</strong></p>
<p>1 )  为一个类添加原来没有的变量、方法、属性<br>2 )  一般的类扩展写到 .m 文件中<br>3 )  一般的私有属性写到 .m 文件中的类扩展中</p>
<p><strong>(3) Category 和 Extension 的区别</strong></p>
<p>1 )  Category 中原则上只能增加方法（能添加属性的的原因只是通过 runtime 解决无 setter / getter 的问题而已）。Extension 不仅可以增加方法，还可以增加实例变量（或者属性），只是该实例变量默认是 Private 类型的。</p>
<p>2 )  Extension 中声明的方法没被实现，编译器会报警，但是 Category 中的方法没被实现编译器是不会有任何警告的。Extention 添加的方法是在编译阶段被添加到类中，而 Category 添加的方法是在运行时添加到类中。所以相对于两者各有不同特性。</p>
<p>3 )  Extention 不能像 Category 那样拥有独立的实现部分。也就是说，Extention 所声明的方法必须依托对应类的实现部分来实现。</p>
<p>4 )  定义在 .m 文件中的 Extention 方法为私有的，Extention 是在 .m 文件中声明私有方法的非常好的方式。</p>
<h3 id="7-Runtime-的应用"><a href="#7-Runtime-的应用" class="headerlink" title="7. Runtime 的应用"></a>7. Runtime 的应用</h3><p><strong>(1) 利用 Method Swizzling 特性实现用户行为收集，预防数组字典越界奔溃， 代码解耦等</strong></p>
<p><strong>(2) 获取系统提供的库相关信息</strong></p>
<p><strong>(3) 为类动态添加方法</strong></p>
<h2 id="Swift-Runtime"><a href="#Swift-Runtime" class="headerlink" title="Swift Runtime"></a>Swift Runtime</h2><p>已查阅到的资料，待消化总结：</p>
<p><a href="https://github.com/apple/swift/blob/master/docs/Runtime.md" target="_blank" rel="noopener">https://github.com/apple/swift/blob/master/docs/Runtime.md</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&amp;mid=403068491&amp;idx=1&amp;sn=c95f07e3d38c92ba56933502cc3e1800#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&amp;mid=403068491&amp;idx=1&amp;sn=c95f07e3d38c92ba56933502cc3e1800#rd</a></p>
<p><a href="https://nshipster.com/swift-objc-runtime/" target="_blank" rel="noopener">https://nshipster.com/swift-objc-runtime/</a></p>
<p><a href="https://academy.realm.io/posts/mobilization-roy-marmelstein-objective-c-runtime-swift-dynamic/" target="_blank" rel="noopener">https://academy.realm.io/posts/mobilization-roy-marmelstein-objective-c-runtime-swift-dynamic/</a></p>
</div><div class="tags"><a href="/tags/iOS/">iOS</a></div><div class="post-nav"><a class="pre" href="/2019/06/05/iOS-RunLoop/">iOS-RunLoop</a><a class="next" href="/2018/02/02/Git-常用命令/">Git-常用命令</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/SVN/" style="font-size: 15px;">SVN</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Xcode/" style="font-size: 15px;">Xcode</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/10/iOS 中使用 Python/">iOS 中使用 Python</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/05/iOS-RunLoop/">iOS-RunLoop</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/30/iOS-Runtime/">iOS-Runtime</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/02/Git-常用命令/">Git-常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/01/SVN常用命令/">SVN-常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/01/iOS-调试技巧/">Xcode-常用调试技巧</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">涛涛.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>