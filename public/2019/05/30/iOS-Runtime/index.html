<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS-Runtime | 涛涛</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS-Runtime</h1><a id="logo" href="/.">涛涛</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS-Runtime</h1><div class="post-meta">May 30, 2019</div><div class="post-content"><h2 id="Objc-Runtime"><a href="#Objc-Runtime" class="headerlink" title="Objc Runtime"></a>Objc Runtime</h2><p>  源代码下载地址：<a href="http://www.opensource.apple.com/source/objc4/" target="_blank" rel="noopener">http://www.opensource.apple.com/source/objc4/</a></p>
<p>  Runtime 函数文档: <a href="https://developer.apple.com/documentation/objectivec/objective-c_runtime" target="_blank" rel="noopener">https://developer.apple.com/documentation/objectivec/objective-c_runtime</a></p>
<p>  苹果官方 Runtime 编程指南：<br>  <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048</a></p>
<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p> Objective-C 是一门动态语言，它将很多静态语言在编译和链接时做的事情推迟到运行时来处理。</p>
<p> 这种动态特性意味着 Objective-C 不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。<br> 对于 Objective-C 来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。</p>
<p> Runtime 就是使用 C 和汇编写的一个运行时库，一般我们说 Runtime，不但包含运行时库的意思，还包含了运行时、运行时系统等概念。</p>
<p><strong>Objc Runtime 使得 C 具有了面向对象能力，可以在程序运行时创建、检查、修改类、对象和它们的方法</strong>。</p>
<h3 id="2-Runtime-的作用："><a href="#2-Runtime-的作用：" class="headerlink" title="2. Runtime 的作用："></a>2. Runtime 的作用：</h3><h4 id="1-封装"><a href="#1-封装" class="headerlink" title="(1) 封装"></a>(1) 封装</h4><p> Runtime 库中，对象可以用 C 语言中的结构体表示，而方法可以用 C 函数来实现，再加上了一些其他的特性。这些结构体和函数被 runtime 函数封装后，就可以在程序运行时创建、检查、修改类、对象和它们的方法了。</p>
<h4 id="2-找到方法的最终执行代码"><a href="#2-找到方法的最终执行代码" class="headerlink" title="(2) 找到方法的最终执行代码"></a>(2) 找到方法的最终执行代码</h4><p> 当程序中执行 [receiver message] 时，会向消息接收者（receiver）发送一条消息 message，runtime 会根据消息接收者是否能响应该消息而做出不同的反应，即消息转发的流程。</p>
<h3 id="3-类和对象（Class-和-Object）相关的基本数据结构"><a href="#3-类和对象（Class-和-Object）相关的基本数据结构" class="headerlink" title="3. 类和对象（Class 和 Object）相关的基本数据结构"></a>3. 类和对象（Class 和 Object）相关的基本数据结构</h3><h4 id="1-关键词："><a href="#1-关键词：" class="headerlink" title="(1) 关键词："></a>(1) 关键词：</h4><p> Class：指向了 objc_class 结构体的指针<br>    id：参数类型，指向某个类实例的指针<br>    Method：代表了类中的某个方法的类型<br>    SEL：方法选择器，全名是 selector<br>    IMP：函数指针，由编译器生成，方法实现的代码就是由 IMP 指定<br>    Ivar：成员变量的类型<br>    Property：属性存储器<br>    Cache：方法调用的缓存器，为方法调用的性能进行优化</p>
<h4 id="2-objc-class-和-objc-object-数据结构："><a href="#2-objc-class-和-objc-object-数据结构：" class="headerlink" title="(2) objc_class 和 objc_object 数据结构："></a>(2) objc_class 和 objc_object 数据结构：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-objc-object-和-isa"><a href="#3-objc-object-和-isa" class="headerlink" title="(3) objc_object 和 isa"></a>(3) objc_object 和 isa</h4><p>objc_object 源代码在 objc-private.h line 75, 关键代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">ISA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">getIsa</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>objc_object 中的 isa，对应类型为联合体 isa_t，源代码在 objc-private.h line 61, 关键代码定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;                                         \         <span class="comment">//0:普通指针，1:优化过，使用位域存储更多信息</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;                                         \         <span class="comment">//对象是否含有或曾经含有关联引用</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;                                         \         <span class="comment">//表示是否有 C++ 析构函数或OC的 dealloc</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">44</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/</span> \         <span class="comment">//存放着 Class、Meta-Class 对象的内存地址信息</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;                                         \         <span class="comment">//用于在调试时分辨对象是否未完成初始化</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;                                         \         <span class="comment">//是否被弱引用指向</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;                                         \         <span class="comment">//对象是否正在释放</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;                                         \         <span class="comment">//是否需要使用 sidetable 来存储引用计数</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">8</span>                                                    <span class="comment">//引用计数能够用 8 个二进制位存储时，直接存储在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-objc-class"><a href="#4-objc-class" class="headerlink" title="(4) objc_class"></a>(4) objc_class</h4><p>objc_class 源代码可在 objc-runtime-new.h line 1111 看到，由于 objc_class 继承自 objc_object， 所以其关键结构可简化如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="keyword">isa_t</span> isa;                 <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class_rw_t</span> *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>objc_object 用来描述 OC 中的实例，当用口语描述实例时，总会说 「XX类的实例x」或「x是XX的实例」。objc_object 的 isa 在程序结构上表达类似的含义，它指向了该实例所对应的类，类在 runtime 中被描述成 objc_class 结构。<br>Objective-C 中的类本质上也是对象，称之为类对象，在 Objective-C 中有一个非常特殊的类 NSObject ，绝大部分的类都继承自它。它是 Objective-C 中的两个根类（rootclass）之一，另外一个是 NSProxy。<br>NSObject 只有一个成员变量 isa。所有继承自 NSObject 的类也都会有这个成员变量。</p>
<h4 id="5-元类（metaclass），根类（root-class），根元类（root-metaclass）"><a href="#5-元类（metaclass），根类（root-class），根元类（root-metaclass）" class="headerlink" title="(5) 元类（metaclass），根类（root class），根元类（root metaclass）"></a>(5) 元类（metaclass），根类（root class），根元类（root metaclass）</h4><p>本质上 Objective-C 中的类也是对象，它也是某个类的实例，这个类我们称之为元类（metaclass）。元类也是对象（元类对象），元类也是某个类的实例，这个类我们称之为根元类（root metaclass）。<br>不过，有一点比较特殊，那就是所有的元类所属的类都是同一个根元类（当然根元类也是元类，所以它所属的类也是根元类，即它本身）。根元类指的就是根类的元类，具体来说就是根类 NSObject 对应的元类。</p>
<p>通过调用类方法，比如 [NSObject new]，给类对象发送消息。同样的，类对象能否响应这个消息也要通过 isa 找到类对象所属的类（元类）才能知道。也就是说，实例方法是保存在类中的，而类方法是保存在元类中的。理论上我们也可以给元类发送消息，但是 Objective-C 倾向于隐藏元类，不想让大家知道元类的存在。元类是为了保持 Objective-C 对象模型在设计上的完整性而引入的，比如用来保存类方法等，它主要是用来给编译器使用的。</p>
<p>下图是为类（class），元类（metaclass），根类（root class），根元类（root metaclass）关系<br><img src="/2019/05/30/iOS-Runtime/object_model.png" alt=""></p>
<h4 id="6-superclass"><a href="#6-superclass" class="headerlink" title="(6) superclass"></a>(6) superclass</h4><p>指向该类的父类，如果该类已经是最顶层的根类（如 NSObject 或 NSProxy），则 superclass 为 NULL。</p>
<h4 id="7-cache-t"><a href="#7-cache-t" class="headerlink" title="(7) cache_t"></a>(7) cache_t</h4><p>cache_t 是一个散列表，用来缓存曾经调用过的方法，提高方法的查找速度。<br>源代码可在 objc-runtime-new.h line 59 找到，其关键结构如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span>     <span class="comment">// 散列表</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;                  <span class="comment">// 散列表的长度 -1</span></span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;              <span class="comment">// 已经缓存的方法数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">cache_key_t</span> _key;              <span class="comment">// SEL 作为 key</span></span><br><span class="line">    MethodCacheIMP _imp;           <span class="comment">// 函数的内存地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>buckets：</strong>指向 Method 数据结构指针的数组。这个数组可能包含不超过 mask+1 个元素。需要注意的是，指针可能是 NULL，表示这个缓存 bucket 没有被占用，另外被占用的 bucket 可能是不连续的。这个数组可能会随着时间而增长。</p>
<p><strong>mask：</strong>一个整数，指定分配的缓存 bucket 的总数。在方法查找过程中，Objective-C runtime 使用这个字段来确定开始线性查找数组的索引未知。指向方法 selector 的指针与该字段做一个 AND 位操作（index = (mask &amp; selector)）。这可以作为一个简单的 hash 散列算法。</p>
<p><strong>occupied：</strong>一个整数，指定实际占用的缓存 bucket 的总数。</p>
<h4 id="8-class-data-bits-t"><a href="#8-class-data-bits-t" class="headerlink" title="(8) class_data_bits_t"></a>(8) class_data_bits_t</h4><p>class_data_bits_t 是一个结构体，里面包含了一个 class_rw_t 类型的指针 data。class_rw_t 内部有个 class_ro_t 的指针 ro。class_rw_t 是可读可写的，class_ro_t 是只读的。 class_data_bits_t 源代码可以在 objc-runtime-new.h line 870 看到。</p>
<p><strong>class_rw_t 结构如下：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;             <span class="comment">// 保存类的原始数据(不包含分类内容和动态添加的方法)</span></span><br><span class="line">    <span class="keyword">method_array_t</span> methods;           <span class="comment">// 方法列表(如果是类对象存储的是对象方法,元类对象存储的是类方法)</span></span><br><span class="line">    <span class="keyword">property_array_t</span> properties;      <span class="comment">// 属性列表</span></span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;       <span class="comment">// 协议列表</span></span><br><span class="line">    Class firstSubclass;              <span class="comment">// 第一个子类</span></span><br><span class="line">    Class nextSiblingClass;           <span class="comment">// 兄弟类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>class_ro_t 储存了类的初始信息，不包括分类和后来动态添加的内容。class_ro_t 关键代码如下：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;                    <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;       <span class="comment">// 原始方法列表</span></span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;      <span class="comment">// 原始协议列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;            <span class="comment">// 成员变量列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;      <span class="comment">// 属性列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_list_t</span> *baseMethods() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>method_list_t 数组包含了多个 method_t，其中 method_t 也是结构体 ，其关键结构如下：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name;               <span class="comment">// 函数名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;      <span class="comment">// 方法参数 (包含了返回值类型,参数类型)</span></span><br><span class="line">    MethodListIMP imp;      <span class="comment">// 方法的实现 (指向函数的指针)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>ivar_list_t 数组包含了多个 ivar_t 类型的结构体 ivar，ivar_t 结构如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> *offset;               <span class="comment">// 变量在内存中相对所属对象内存空间起始地址的偏移量,偏移量大小根据类型来定</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;              <span class="comment">// 变量名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;              <span class="comment">// 变量类型</span></span><br><span class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment_raw;</span><br><span class="line">    <span class="keyword">uint32_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (alignment_raw == ~(<span class="keyword">uint32_t</span>)<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1U</span> &lt;&lt; WORD_SHIFT;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; alignment_raw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>property_list_t 数组包含多个 property_t，property_t 结构如下：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;             </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>class_ro_t 包含的类信息（方法、属性、协议等）都是在编译期就可以确定的，暂且称为元信息吧，在之后的逻辑中，它们显然是不希望被改变的；后续在用户层，无论是方法还是别的扩展，都是在 class_rw_t 上进行操作，这些操作都不会影响类的元信息。更多关于 class_rw_t 和 class_ro_t 的资料可查看 <a href="https://zhangbuhuai.com/post/runtime.html" target="_blank" rel="noopener">这篇文章</a>。</p>
<h3 id="4-类和对象相关操作方法"><a href="#4-类和对象相关操作方法" class="headerlink" title="4. 类和对象相关操作方法"></a>4. 类和对象相关操作方法</h3><p>操作类相关的函数一般以 class 为前缀，操作对象相关函数以 objc 或 object_ 为前缀。可在开篇 Runtime 函数文档查看相关方法。</p>
<h4 id="1-类相关操作函数"><a href="#1-类相关操作函数" class="headerlink" title="(1) 类相关操作函数"></a>(1) 类相关操作函数</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const <span class="keyword">char</span> * class_getName ( <span class="keyword">Class</span> cls )           <span class="comment">// 获取类名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Class</span> class_getSuperclass ( <span class="keyword">Class</span> cls )            <span class="comment">// 获取父类</span></span><br><span class="line"></span><br><span class="line">BOOL class_isMetaClass ( <span class="keyword">Class</span> cls )               <span class="comment">// 判断给定的类是不是元类</span></span><br><span class="line"></span><br><span class="line">size_t class_getInstanceSize ( <span class="keyword">Class</span> cls )         <span class="comment">// 获取类的实例大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> class_getVersion ( <span class="keyword">Class</span> cls )                 <span class="comment">// 获取版本号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> class_setVersion ( <span class="keyword">Class</span> cls, <span class="keyword">int</span> version )   <span class="comment">// 设置版本号</span></span><br></pre></td></tr></table></figure>
<h4 id="2-成员变量-ivars-和属性相关操作函数"><a href="#2-成员变量-ivars-和属性相关操作函数" class="headerlink" title="(2) 成员变量 (ivars) 和属性相关操作函数"></a>(2) 成员变量 (ivars) 和属性相关操作函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Ivar <span class="title">class_getInstanceVariable</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name )</span>                                           <span class="comment">// 获取类中指定名称实例成员变量的信息</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Ivar <span class="title">class_getClassVariable</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name )</span>                                              <span class="comment">// 获取类成员变量的信息</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addIvar</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> size, <span class="keyword">uint8_t</span> alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types )</span>    <span class="comment">// 在 runtime 时创建的类添加成员变量</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Ivar * <span class="title">class_copyIvarList</span> <span class="params">( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount )</span>                                          <span class="comment">// 获取整个成员变量列表，必须使用 free() 来释放</span></span></span><br></pre></td></tr></table></figure>
<h4 id="3-method-相关操作函数"><a href="#3-method-相关操作函数" class="headerlink" title="(3) method 相关操作函数"></a>(3) method 相关操作函数</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BOOL class_addMethod ( <span class="keyword">Class</span> cls, SEL name, IMP imp, <span class="keyword">const</span> char *types )       <span class="comment">// 添加方法，和成员变量不同的是可以为类动态添加方法。如果有同名会返回 NO，修改的话需要使用 method_setImplementation</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">class_getInstanceMethod</span> <span class="params">( <span class="keyword">Class</span> cls, SEL name )</span>                         // 获取实例方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Method</span> <span class="title">class_getClassMethod</span> <span class="params">( <span class="keyword">Class</span> cls, SEL name )</span>                            // 获取类方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Method</span> * <span class="title">class_copyMethodList</span> <span class="params">( <span class="keyword">Class</span> cls, unsigned int *outCount )</span>            // 获取所有方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">IMP</span> <span class="title">class_replaceMethod</span> <span class="params">( <span class="keyword">Class</span> cls, SEL name, IMP imp, <span class="keyword">const</span> char *types )</span>    // 实现替换方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">IMP</span> <span class="title">class_getMethodImplementation</span> <span class="params">( <span class="keyword">Class</span> cls, SEL name )</span>                      // 返回方法的具体实现</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">IMP</span> <span class="title">class_getMethodImplementation_stret</span> <span class="params">( <span class="keyword">Class</span> cls, SEL name )</span>                // 返回方法的具体实现</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">BOOL</span> <span class="title">class_respondsToSelector</span> <span class="params">( <span class="keyword">Class</span> cls, SEL sel )</span>                           // 类实例是否响应指定的 <span class="title">selector</span></span></span><br></pre></td></tr></table></figure>
<h4 id="4-protocol-相关操作函数"><a href="#4-protocol-相关操作函数" class="headerlink" title="(4) protocol 相关操作函数"></a>(4) protocol 相关操作函数</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BOOL</span> class_addProtocol ( Class <span class="keyword">cls</span>, Protocol *protocol )                       <span class="comment">// 添加协议</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BOOL</span> class_conformsToProtocol ( Class <span class="keyword">cls</span>, Protocol *protocol )                <span class="comment">// 返回类是否实现指定的协议</span></span><br><span class="line"></span><br><span class="line">Protocol * class_copyProtocolList ( Class <span class="keyword">cls</span>, unsigned int *outCount )        <span class="comment">// 获取类实现的协议列表</span></span><br></pre></td></tr></table></figure>
<h4 id="5-相关示例代码："><a href="#5-相关示例代码：" class="headerlink" title="(5) 相关示例代码："></a>(5) 相关示例代码：</h4><h3 id="5-消息与消息转发"><a href="#5-消息与消息转发" class="headerlink" title="5. 消息与消息转发"></a>5. 消息与消息转发</h3><h4 id="1-Method-基础数据结构："><a href="#1-Method-基础数据结构：" class="headerlink" title="(1) Method 基础数据结构："></a>(1) Method 基础数据结构：</h4><p>  Method 是 method_t 结构体的指针，method_t 在分析 method_list_t 已写出其结构，其结构中包括 SEL 和 IMP 两种数据结构。</p>
<p><strong>SEL:</strong><br>Objective-C 在编译的时候，objc_selector 会依据方法的名字、参数序列、生成一个整型标识的地址<br>( int 类型的地址)：这个标识就是 SEL，其结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *<span class="title">SEL</span></span></span><br></pre></td></tr></table></figure>
<p><strong>IMP：</strong><br>是一个函数指针，指向方法实现的地址。其结构如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A pointer to the function of a method implementation. </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*IMP)</span><span class="params">(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> )</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>SEL 和 IMP 为映射关系：</strong>SEL 通过 Dispatch table 表寻找到对应的 IMP， Dispatch table 表 (哈希表) 存放 SEL 和 IMP 的映射。我们可以对一个编号 (SEL) 和什么方法 (IMP) 映射做些操作，也就是说我们可以一个 SEL 指向不同的函数指针，这样就可以完成一个方法名在不同时候执行不同的函数体。</p>
<h4 id="2-相关操作方法："><a href="#2-相关操作方法：" class="headerlink" title="(2) 相关操作方法："></a>(2) 相关操作方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Swift-Runtime"><a href="#Swift-Runtime" class="headerlink" title="Swift Runtime"></a>Swift Runtime</h2></div><div class="tags"><a href="/tags/iOS/">iOS</a></div><div class="post-nav"><a class="pre" href="/2019/06/05/iOS-RunLoop/">iOS-RunLoop</a><a class="next" href="/2018/02/02/Git-常用命令/">Git-常用命令</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/SVN/" style="font-size: 15px;">SVN</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Xcode/" style="font-size: 15px;">Xcode</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/10/iOS 中使用 Python/">iOS 中使用 Python</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/05/iOS-RunLoop/">iOS-RunLoop</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/30/iOS-Runtime/">iOS-Runtime</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/02/Git-常用命令/">Git-常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/01/SVN常用命令/">SVN-常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/01/iOS-调试技巧/">Xcode-常用调试技巧</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">涛涛.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>