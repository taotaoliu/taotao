{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/default.css","path":"css/default.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/maupassant/source/donate/index.html","path":"donate/index.html","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/AliPayQR.png","path":"img/AliPayQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/BTCQR.png","path":"img/BTCQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/WeChatQR.png","path":"img/WeChatQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"8c74542526d93b6822e523184cdde5396639e333","modified":1560057872134},{"_id":"themes/maupassant/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1560662407492},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1559114337678},{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1559114337678},{"_id":"themes/maupassant/_config.yml","hash":"fee8f5bafc7a796561c90b55c007ee02d43abcf1","modified":1559115367093},{"_id":"themes/maupassant/README.md","hash":"90032cb3a46f741a3d6198de9f83ce384505519e","modified":1559114337679},{"_id":"themes/maupassant/package.json","hash":"f092433469eb87362e831326425a6a5c3c9fea0d","modified":1559114337687},{"_id":"source/_posts/.DS_Store","hash":"9508d2ef0acf36a537be5e812078bffe638c2f0f","modified":1560865821601},{"_id":"source/_posts/iOS 中使用 Python.md","hash":"b03f38f35cad410223018eb5e056e4ae9a4eedf3","modified":1559299093648},{"_id":"source/_posts/iOS-RunLoop.md","hash":"d6062dfb4ed99b5149842a237e46818930e4176c","modified":1560913702241},{"_id":"source/_posts/Git-常用命令.md","hash":"e427ea12fe0d2438be9f19966d09f1385c608250","modified":1559371935085},{"_id":"source/_posts/SVN常用命令.md","hash":"37255e28aab7361d39d389d24be6a3510a5b5ff3","modified":1559295459336},{"_id":"source/_posts/iOS-Runtime.md","hash":"801a5a63f7e4af10878fa065502c93a05d818110","modified":1560914021157},{"_id":"source/about/index.md","hash":"24acacd5dfa4ceb8534f88c3ac6b79959b7391a8","modified":1559111577656},{"_id":"source/category/index.md","hash":"73650e3874483fefe8b2e4a63dfedbcc24c7bdc1","modified":1559111577657},{"_id":"source/category/.DS_Store","hash":"f2aee57486db29d3a9028ecfe1f84362e50b5aa4","modified":1560840710712},{"_id":"source/_posts/iOS-调试技巧.md","hash":"b783347189f2155f0dcf356c01b22f5056132caa","modified":1559295087180},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1559114337679},{"_id":"themes/maupassant/languages/en.yml","hash":"c3fb5c155560a00889a75882c680afe1197ebf1a","modified":1559114337679},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1559114337680},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1559114337680},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1559114337680},{"_id":"themes/maupassant/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1559114337680},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"710b204e637c18b86ac7c681f7d1cf8dfeddf4bb","modified":1559114337682},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"bf3ab970f2ab3f29ddeb9f59bf98163be635e284","modified":1559114337682},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"16c4d1079450f801b5ac079d3cc101856d8f387c","modified":1559114337686},{"_id":"themes/maupassant/layout/archive.pug","hash":"2fe2cff144c9b7b509b7b6cb1b3acba27aa1d132","modified":1559114337686},{"_id":"themes/maupassant/layout/base.pug","hash":"a4e32bcb580b76af9ad0582d9d3f0107e34509ed","modified":1559114337686},{"_id":"themes/maupassant/layout/index.pug","hash":"0435a4e5f5c6976e05b3079d335453c246f5ba6e","modified":1559114337686},{"_id":"themes/maupassant/layout/page.pug","hash":"8cfd307b13cad8be34a1e75c4566f96c1722e08e","modified":1559114337686},{"_id":"themes/maupassant/layout/post.pug","hash":"f4d17b1b2a590cc076e80d912591648f9e99aeaf","modified":1559114337686},{"_id":"themes/maupassant/layout/single-column.pug","hash":"0593f261dc208bb0b5c4232eb41eff597a291bd9","modified":1559114337687},{"_id":"themes/maupassant/layout/timeline.pug","hash":"84fbfc92ccdf291b491140d89557553141a5d3f9","modified":1559114337687},{"_id":"source/_posts/Git-常用命令/.DS_Store","hash":"1c412b535acced9b86e95d0cbcd9dde94eb4b95f","modified":1559367845431},{"_id":"source/_posts/Git-常用命令/git_sections.png","hash":"7144c5e9e911d79586f90926a500a5ecb976b4d0","modified":1559366473978},{"_id":"source/_posts/iOS-Runtime/object_model.png","hash":"d2ef6d4a90d58a581f72fc63d4c462adfee71872","modified":1559460168075},{"_id":"source/_posts/iOS-调试技巧/breakpoint12.png","hash":"f85c679e23402f6e0b574a6efbfd6b6e235899de","modified":1559111577651},{"_id":"source/_posts/iOS-调试技巧/breakpoint13.png","hash":"e8a6a00b8789d9fe1f64f8493dc8b02bfdf0c364","modified":1559111577652},{"_id":"source/_posts/iOS-调试技巧/breakpoint15.png","hash":"38648981010ff460e3d161ea49ec391889da29e1","modified":1559111577653},{"_id":"source/_posts/iOS-调试技巧/breakpoint4.png","hash":"cc514934e78224ac5e290fc38504c886a62b99d7","modified":1559111577654},{"_id":"source/_posts/iOS-调试技巧/breakpoint16.png","hash":"62914b63188fb033af2e27a8bd7f3e287cef5bd1","modified":1559111577653},{"_id":"source/_posts/iOS-调试技巧/breakpoint5.png","hash":"2e6e00af53d5ea766a0b161e3ee826e20ffcc56a","modified":1559111577654},{"_id":"source/_posts/iOS-调试技巧/breakpoint7.png","hash":"ad9cc81432c0a6c706989cfe1d722c7ea92d5e09","modified":1559111577655},{"_id":"source/_posts/iOS-调试技巧/breakpoint8.png","hash":"3c226c35db2ffa9e22361fea4507cf68a4501d5b","modified":1559111577655},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"ff14baa25f6db34dedfb5e029c25687a335ad430","modified":1559114337683},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"31bf35a57634ff8a796c71dd5246eba3a3db10ee","modified":1559114337683},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"650781b5bc8c632658ad6880ba663b1e3bfb5798","modified":1559114337683},{"_id":"source/_posts/iOS-调试技巧/breakpoint9.png","hash":"a92019c371a73409511be25879f2fc4966f67223","modified":1559111577656},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"8af6e452ea2a56b110b5079f79bf743b643f7d6c","modified":1559114337683},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1559114337683},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1559114337683},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1559114337684},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1559114337684},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1559114337684},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1559114337684},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1559114337684},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"004c8a3edc19d428179b83a0f97eae3c1a6d3cfa","modified":1559114337684},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1559114337685},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"c45aa7ec00158579e58f1f8dfd890447bb5e5e54","modified":1559114337685},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"4102d446f13b02ff617f055c2a8f726bca12744a","modified":1559114337685},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6e8e4123cca38840c4607c1a056205972b82bb7b","modified":1559114337685},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"19431336d724d2118e46da43683bce9063176541","modified":1559114337685},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1559114337685},{"_id":"themes/maupassant/source/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1559114337688},{"_id":"themes/maupassant/source/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1559114337687},{"_id":"themes/maupassant/source/css/style.scss","hash":"fa5dfd0867f95fe1708e6fda90e41db6364c01d9","modified":1559114337689},{"_id":"themes/maupassant/source/donate/index.html","hash":"c42428765d48c8674ce28100ad95fdf4c7806a85","modified":1559114337689},{"_id":"themes/maupassant/source/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1559114337689},{"_id":"themes/maupassant/source/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1559114337690},{"_id":"themes/maupassant/source/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1559114337690},{"_id":"themes/maupassant/source/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1559114337691},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1559114337691},{"_id":"themes/maupassant/source/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1559114337691},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1559114337690},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1559114337691},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1559114337690},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1559114337692},{"_id":"themes/maupassant/source/js/donate.js","hash":"780beaaf44b1e6c057752bdbc085b1048937e5e7","modified":1559114337692},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1559114337692},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1559114337693},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1559114337694},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1559114337694},{"_id":"themes/maupassant/source/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1559114337693},{"_id":"source/_posts/iOS-调试技巧/breakpoint11.png","hash":"4b067ab8a8015ebd92b29b384a0349f8468d7cf3","modified":1559111577651},{"_id":"source/_posts/iOS-调试技巧/breakpoint1.png","hash":"a0506650a7562e9ff514b2549c416fee62486bb4","modified":1559111577650},{"_id":"source/_posts/iOS-调试技巧/breakpoint14.png","hash":"548cdcc7649683caf3800099903ce4525aa5169f","modified":1559111577652},{"_id":"source/_posts/iOS-调试技巧/breakpoint6.png","hash":"4263f434e8feb051932cf4e4afc1fef873309960","modified":1559111577655},{"_id":"themes/maupassant/source/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1559114337693},{"_id":"public/about/index.html","hash":"c50e731cc4f5d77a27833491f66a013ad3dfec23","modified":1560914032227},{"_id":"public/category/index.html","hash":"9e06393efe23b1b201e1cb58973739f22ba8b120","modified":1560914032227},{"_id":"public/2019/06/10/iOS 中使用 Python/index.html","hash":"f968287f38d9ed855c9ef7f047fb609efe3ab46d","modified":1560914032227},{"_id":"public/2019/06/05/iOS-RunLoop/index.html","hash":"61f5b628ebde4089b83c0c264b17f4fbb36fe6c0","modified":1560914032227},{"_id":"public/2018/02/01/iOS-调试技巧/index.html","hash":"253876fd030a870e55fdb50580dedf3f1aa6de15","modified":1560914032227},{"_id":"public/archives/index.html","hash":"5d79441091ba8d7d3edb03702ad4f16566891156","modified":1560914032227},{"_id":"public/archives/2018/index.html","hash":"730c2916fa67f9f9aba2106eb640e113f84157fc","modified":1560914032227},{"_id":"public/archives/2018/02/index.html","hash":"730c2916fa67f9f9aba2106eb640e113f84157fc","modified":1560914032227},{"_id":"public/archives/2019/index.html","hash":"6f848bc9a0e4bca1d57ab778643d7e93476ae057","modified":1560914032228},{"_id":"public/archives/2019/05/index.html","hash":"6e43fd1d93f6a37a220b33a75ea90d92cb695bc9","modified":1560914032228},{"_id":"public/archives/2019/06/index.html","hash":"f6eb6aa7a5fec6847b6466861874f9c5248c8336","modified":1560914032228},{"_id":"public/index.html","hash":"f480979c9edaafc1942812eeb5183da3f310e055","modified":1560914032228},{"_id":"public/tags/Python/index.html","hash":"6cb98931020f0c33e732d8aaceb3ec5ca06b5c40","modified":1560914032228},{"_id":"public/tags/SVN/index.html","hash":"f4029397f062b6a793a6f6cc1614e61d9485c41d","modified":1560914032228},{"_id":"public/tags/iOS/index.html","hash":"8b50cacd300a36c4e30737df37ac12db3eb6d799","modified":1560914032228},{"_id":"public/tags/Git/index.html","hash":"83ec64560ece6950f83594a7e4bd811be4f58e20","modified":1560914032228},{"_id":"public/tags/Xcode/index.html","hash":"367746719c5097d26b49a3f615dd7f4c42146297","modified":1560914032228},{"_id":"public/2019/05/30/iOS-Runtime/index.html","hash":"802d1607e5513bd0ed7d4279ea77df78bd94a3de","modified":1560914032228},{"_id":"public/2018/02/02/Git-常用命令/index.html","hash":"c2250daac39d0c026401624a5293d0a71db8a482","modified":1560914032228},{"_id":"public/2018/02/01/SVN常用命令/index.html","hash":"6b56edc2554c82d2899fa3fc7c3e504284a2dbbd","modified":1560914032228},{"_id":"public/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1560914032233},{"_id":"public/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1560914032233},{"_id":"public/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1560914032233},{"_id":"public/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1560914032233},{"_id":"public/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1560914032233},{"_id":"public/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1560914032233},{"_id":"public/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1560914032233},{"_id":"public/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1560914032233},{"_id":"public/2018/02/02/Git-常用命令/git_sections.png","hash":"7144c5e9e911d79586f90926a500a5ecb976b4d0","modified":1560914032233},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint1.png","hash":"a0506650a7562e9ff514b2549c416fee62486bb4","modified":1560914032234},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint12.png","hash":"f85c679e23402f6e0b574a6efbfd6b6e235899de","modified":1560914032234},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint13.png","hash":"e8a6a00b8789d9fe1f64f8493dc8b02bfdf0c364","modified":1560914032234},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint15.png","hash":"38648981010ff460e3d161ea49ec391889da29e1","modified":1560914032234},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint16.png","hash":"62914b63188fb033af2e27a8bd7f3e287cef5bd1","modified":1560914032234},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint5.png","hash":"2e6e00af53d5ea766a0b161e3ee826e20ffcc56a","modified":1560914032234},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint7.png","hash":"ad9cc81432c0a6c706989cfe1d722c7ea92d5e09","modified":1560914032234},{"_id":"public/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1560914032237},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint11.png","hash":"4b067ab8a8015ebd92b29b384a0349f8468d7cf3","modified":1560914032238},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint4.png","hash":"cc514934e78224ac5e290fc38504c886a62b99d7","modified":1560914032239},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint6.png","hash":"4263f434e8feb051932cf4e4afc1fef873309960","modified":1560914032239},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint8.png","hash":"3c226c35db2ffa9e22361fea4507cf68a4501d5b","modified":1560914032239},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint9.png","hash":"a92019c371a73409511be25879f2fc4966f67223","modified":1560914032239},{"_id":"public/2019/05/30/iOS-Runtime/object_model.png","hash":"d2ef6d4a90d58a581f72fc63d4c462adfee71872","modified":1560914032240},{"_id":"public/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1560914032242},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1560914032242},{"_id":"public/js/donate.js","hash":"89f0b9d9d0c4fce183161d29c2a44aef750efb27","modified":1560914032243},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1560914032243},{"_id":"public/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1560914032243},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1560914032243},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1560914032243},{"_id":"public/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1560914032243},{"_id":"public/donate/index.html","hash":"e94c928417ceaf6e2dae7eac2ccb5b106fd9c2a4","modified":1560914032243},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint14.png","hash":"548cdcc7649683caf3800099903ce4525aa5169f","modified":1560914032243},{"_id":"public/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1560914032248},{"_id":"public/css/style.css","hash":"50dac51e44b24279f14cd3756bf1b388e5977f74","modified":1560914032306},{"_id":"public/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1560914032315}],"Category":[],"Data":[],"Page":[{"title":"","date":"2018-01-30T09:10:00.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: \ndate: 2018-01-30 17:10:00\n---\n","updated":"2019-05-29T06:32:57.656Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjx2nwtyh0001u78eo3kc9lvc","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"category","date":"2018-02-06T06:48:11.000Z","_content":"iOS\nPython","source":"category/index.md","raw":"---\ntitle: category\ndate: 2018-02-06 14:48:11\n---\niOS\nPython","updated":"2019-05-29T06:32:57.657Z","path":"category/index.html","comments":1,"layout":"page","_id":"cjx2nwtyj0003u78e5pq2i3h1","content":"<p>iOS<br>Python</p>\n","site":{"data":{}},"excerpt":"","more":"<p>iOS<br>Python</p>\n"}],"Post":[{"title":"iOS 中使用 Python","date":"2019-06-10T03:10:12.000Z","_content":"","source":"_posts/iOS 中使用 Python.md","raw":"---\ntitle: iOS 中使用 Python\ndate: 2019-06-10 11:10:12\ntags: Python\n---\n","slug":"iOS 中使用 Python","published":1,"updated":"2019-05-31T10:38:13.648Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx2nwtyc0000u78ek4as0dnr","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"SVN-常用命令","date":"2018-02-01T10:13:48.000Z","_content":"\n### 1. 检出: checkout 缩写 co\n如果不带 --password  参数传输密码的话，会提示输入密码，建议不要用明文的 --password 选项。其中 username 与 password前是两个短线，不是一个。默认check到当前目录。\n```\n    svn  checkout  http://路径(目录或文件的全路径)　[本地目录全路径] --username　用户名\n    svn  checkout  svn://路径(目录或文件的全路径)　 [本地目录全路径] --username　用户名\n\n    //例子：\n    svn co svn://localhost/files          --username taotao\n    svn checkout http://localhost/files   --username taotao\n```\n### 2. 导出(导出一个干净的不带.svn文件夹的目录树)\n```\n    svn  export  [-r 版本号]  http: //路径(目录或文件的全路径) --username　用户名\n    svn  export  [-r 版本号]  svn:  //路径(目录或文件的全路径) --username　用户名\n    svn  export  本地检出的(即带有.svn文件夹的)目录全路径  要导出的本地目录全路径\n\n    //例子：\n    svn export svn://localhost/files --username wzhnsc\n    svn export svn://localhost/files --username wzhnsc\n    svn export /home/files /home/tofiles\n    ```\n### 3. 添加新文件: add\n```\n    svn　add　文件名\n\n    //例子：\n    svn add picture.png\n```\n### 4. 提交: commit 缩写 ci\n```\n    svn　commit　-m　“提交备注信息文本“　[-N]　[--no-unlock]　文件名\n    svn　ci　-m　“提交备注信息文本“　    [-N]　[--no-unlock]　文件名\n\n    //例子：\n    svn commit -m “提交我的测试用test.swift“ test.swift\n    svn ci -m “提交我的测试用test.swift“ test.swift\n```\n### 5. 更新文件: update\n```\n    svn　update\n    svn　update　-r　修正版本　文件名\n    svn　update　文件名\n\n    //例子：\n    svn update      \n\n    //后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本\n\n    svn update -r 200 test.swift    \n\n    //将版本库中的文件 test.swift还原到修正版本（revision）200\n\n    //svn update test.swift\n\n    //更新与版本库同步。提交的时候提示过期冲突，需要先update修改文件，然后清除\n    svn resolved，最后再提交commit。\n```\n### 6. 删除文件: delete\n```\n    svn　delete　svn://路径(目录或文件的全路径) -m “删除备注信息文本”\n    svn　delete　文件名 \n\n    //例子：\n    svn delete svn://localhost/testapp/test.swift -m “删除测试文件test.swift”\n\n    //如下：\n    svn delete test.swift \n```\n### 7. 加锁: lock\n```\n    svn　lock　-m　“加锁备注信息文本“　[--force]　文件名 \n    svn　unlock　文件名\n\n    //例子：\n    svn lock -m “锁信测试用test.swift文件“ test.swift \n    svn unlock test.swift\n```\n### 8. 比较差异: diff\n```\n    svn　diff　     文件名 \n    svn　diff　-r　 修正版本号m:修正版本号n　文件名\n\n    //例子：\n    svn diff test.swift               \n\n    //将修改的文件与基础版本比较\n\n    svn diff -r 200:201 test.swift   \n\n    //对修正版本号200和修正版本号201比较差异\n```\n### 9. 查看文件或者目录状态: status  缩写 st\n```\n    svn st 目录路径/名\n\n    //目录下的文件和子目录的状态，正常状态不显示 //?：不在svn的控制中M：内容被修改；C：发生冲突A：预定加入到版本库 K：被锁定 \n\n    svn  -v 目录路径/名\n\n    svn status -v 目录路径/名\n\n    //显示文件和子目录状态,第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次\n    //修改的版本号和修改人\n```\n### 10. 查看日志: log\n```\n    svn　log　文件名\n\n    //例子：\n    svn log test.swift    \n\n    //显示这个文件的所有修改记录，及其版本号的变化\n```\n### 11. 查看文件详细信息: info\n```\n    svn　info　文件名\n\n    //例子：\n    svn info test.swift\n```\n### 12. 查看版本库下的文件和目录列表: list 缩写 ls\n```\n    svn　list　svn://路径(目录或文件的全路径)\n    svn　ls　svn://路径(目录或文件的全路径)\n\n    //例子：\n    svn list svn://localhost/test\n    svn ls svn://localhost/test   \n\n    //显示svn://localhost/test目录下的所有属于版本库的文件和目录 \n```\n### 13. 恢复本地修改: revert\n```\n    svn　revert　[--recursive]　文件名\n\n    //注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录。\n\n    //例子：\n    svn revert taotao.swift      \n\n    //丢弃对一个文件的修改\n\n    svn revert --recursive .     \n\n    //恢复一整个目录的文件，. 为当前目录 \n```\n### 14. 把工作拷贝更新到别的URL: switch\n```\n    svn　switch　http://目录全路径　  \n\n    //本地目录全路径\n\n    //例子：\n    svn switch http://localhost/test/456 .  \n\n    //(原为123的分支)当前所在目录分支到\n```\n### 15. 新建分支: copy\n```\n    svn copy\n\n    //例子：\n    svn copy branchA branchB  -m \"make B branch\"\n    //从branchA拷贝出一个新分支branchB\n```\n### 16. 合并分支: merge\n```\n    //例子：\n    svn merge branchA branchB  \n\n    //把对branchA的修改合并到分支branchB\n```\n### 17. 解决冲突：resolved\n```\n    svn　resolved　[本地目录全路径]\n\n    //例子：\n    $ svn update\n    C foo.c\n    Updated to revision 31.\n    //如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：\n\n    $ ls\n    foo.c\n    foo.c.mine\n    foo.c.r30\n    foo.c.r31\n    //当你解决了foo.c的冲突，并且准备提交，\n    //运行svn resolved让你的工作拷贝知道你已经完成了所有事情。\n    //你可以仅仅删除冲突的文件并且提交，\n    //但是svn resolved除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据。\n```\n","source":"_posts/SVN常用命令.md","raw":"---\ntitle: SVN-常用命令\ndate: 2018-02-01 18:13:48\ntags: SVN\n---\n\n### 1. 检出: checkout 缩写 co\n如果不带 --password  参数传输密码的话，会提示输入密码，建议不要用明文的 --password 选项。其中 username 与 password前是两个短线，不是一个。默认check到当前目录。\n```\n    svn  checkout  http://路径(目录或文件的全路径)　[本地目录全路径] --username　用户名\n    svn  checkout  svn://路径(目录或文件的全路径)　 [本地目录全路径] --username　用户名\n\n    //例子：\n    svn co svn://localhost/files          --username taotao\n    svn checkout http://localhost/files   --username taotao\n```\n### 2. 导出(导出一个干净的不带.svn文件夹的目录树)\n```\n    svn  export  [-r 版本号]  http: //路径(目录或文件的全路径) --username　用户名\n    svn  export  [-r 版本号]  svn:  //路径(目录或文件的全路径) --username　用户名\n    svn  export  本地检出的(即带有.svn文件夹的)目录全路径  要导出的本地目录全路径\n\n    //例子：\n    svn export svn://localhost/files --username wzhnsc\n    svn export svn://localhost/files --username wzhnsc\n    svn export /home/files /home/tofiles\n    ```\n### 3. 添加新文件: add\n```\n    svn　add　文件名\n\n    //例子：\n    svn add picture.png\n```\n### 4. 提交: commit 缩写 ci\n```\n    svn　commit　-m　“提交备注信息文本“　[-N]　[--no-unlock]　文件名\n    svn　ci　-m　“提交备注信息文本“　    [-N]　[--no-unlock]　文件名\n\n    //例子：\n    svn commit -m “提交我的测试用test.swift“ test.swift\n    svn ci -m “提交我的测试用test.swift“ test.swift\n```\n### 5. 更新文件: update\n```\n    svn　update\n    svn　update　-r　修正版本　文件名\n    svn　update　文件名\n\n    //例子：\n    svn update      \n\n    //后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本\n\n    svn update -r 200 test.swift    \n\n    //将版本库中的文件 test.swift还原到修正版本（revision）200\n\n    //svn update test.swift\n\n    //更新与版本库同步。提交的时候提示过期冲突，需要先update修改文件，然后清除\n    svn resolved，最后再提交commit。\n```\n### 6. 删除文件: delete\n```\n    svn　delete　svn://路径(目录或文件的全路径) -m “删除备注信息文本”\n    svn　delete　文件名 \n\n    //例子：\n    svn delete svn://localhost/testapp/test.swift -m “删除测试文件test.swift”\n\n    //如下：\n    svn delete test.swift \n```\n### 7. 加锁: lock\n```\n    svn　lock　-m　“加锁备注信息文本“　[--force]　文件名 \n    svn　unlock　文件名\n\n    //例子：\n    svn lock -m “锁信测试用test.swift文件“ test.swift \n    svn unlock test.swift\n```\n### 8. 比较差异: diff\n```\n    svn　diff　     文件名 \n    svn　diff　-r　 修正版本号m:修正版本号n　文件名\n\n    //例子：\n    svn diff test.swift               \n\n    //将修改的文件与基础版本比较\n\n    svn diff -r 200:201 test.swift   \n\n    //对修正版本号200和修正版本号201比较差异\n```\n### 9. 查看文件或者目录状态: status  缩写 st\n```\n    svn st 目录路径/名\n\n    //目录下的文件和子目录的状态，正常状态不显示 //?：不在svn的控制中M：内容被修改；C：发生冲突A：预定加入到版本库 K：被锁定 \n\n    svn  -v 目录路径/名\n\n    svn status -v 目录路径/名\n\n    //显示文件和子目录状态,第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次\n    //修改的版本号和修改人\n```\n### 10. 查看日志: log\n```\n    svn　log　文件名\n\n    //例子：\n    svn log test.swift    \n\n    //显示这个文件的所有修改记录，及其版本号的变化\n```\n### 11. 查看文件详细信息: info\n```\n    svn　info　文件名\n\n    //例子：\n    svn info test.swift\n```\n### 12. 查看版本库下的文件和目录列表: list 缩写 ls\n```\n    svn　list　svn://路径(目录或文件的全路径)\n    svn　ls　svn://路径(目录或文件的全路径)\n\n    //例子：\n    svn list svn://localhost/test\n    svn ls svn://localhost/test   \n\n    //显示svn://localhost/test目录下的所有属于版本库的文件和目录 \n```\n### 13. 恢复本地修改: revert\n```\n    svn　revert　[--recursive]　文件名\n\n    //注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录。\n\n    //例子：\n    svn revert taotao.swift      \n\n    //丢弃对一个文件的修改\n\n    svn revert --recursive .     \n\n    //恢复一整个目录的文件，. 为当前目录 \n```\n### 14. 把工作拷贝更新到别的URL: switch\n```\n    svn　switch　http://目录全路径　  \n\n    //本地目录全路径\n\n    //例子：\n    svn switch http://localhost/test/456 .  \n\n    //(原为123的分支)当前所在目录分支到\n```\n### 15. 新建分支: copy\n```\n    svn copy\n\n    //例子：\n    svn copy branchA branchB  -m \"make B branch\"\n    //从branchA拷贝出一个新分支branchB\n```\n### 16. 合并分支: merge\n```\n    //例子：\n    svn merge branchA branchB  \n\n    //把对branchA的修改合并到分支branchB\n```\n### 17. 解决冲突：resolved\n```\n    svn　resolved　[本地目录全路径]\n\n    //例子：\n    $ svn update\n    C foo.c\n    Updated to revision 31.\n    //如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：\n\n    $ ls\n    foo.c\n    foo.c.mine\n    foo.c.r30\n    foo.c.r31\n    //当你解决了foo.c的冲突，并且准备提交，\n    //运行svn resolved让你的工作拷贝知道你已经完成了所有事情。\n    //你可以仅仅删除冲突的文件并且提交，\n    //但是svn resolved除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据。\n```\n","slug":"SVN常用命令","published":1,"updated":"2019-05-31T09:37:39.336Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx2nwtyi0002u78et5ozjn2w","content":"<h3 id=\"1-检出-checkout-缩写-co\"><a href=\"#1-检出-checkout-缩写-co\" class=\"headerlink\" title=\"1. 检出: checkout 缩写 co\"></a>1. 检出: checkout 缩写 co</h3><p>如果不带 –password  参数传输密码的话，会提示输入密码，建议不要用明文的 –password 选项。其中 username 与 password前是两个短线，不是一个。默认check到当前目录。<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn  checkout  <span class=\"string\">http:</span><span class=\"comment\">//路径(目录或文件的全路径)　[本地目录全路径] --username　用户名</span></span><br><span class=\"line\">svn  checkout  <span class=\"string\">svn:</span><span class=\"comment\">//路径(目录或文件的全路径)　 [本地目录全路径] --username　用户名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn co <span class=\"string\">svn:</span><span class=\"comment\">//localhost/files          --username taotao</span></span><br><span class=\"line\">svn checkout <span class=\"string\">http:</span><span class=\"comment\">//localhost/files   --username taotao</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-导出-导出一个干净的不带-svn文件夹的目录树\"><a href=\"#2-导出-导出一个干净的不带-svn文件夹的目录树\" class=\"headerlink\" title=\"2. 导出(导出一个干净的不带.svn文件夹的目录树)\"></a>2. 导出(导出一个干净的不带.svn文件夹的目录树)</h3><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn  <span class=\"keyword\">export</span>  [-r 版本号]  http: <span class=\"comment\">//路径(目录或文件的全路径) --username　用户名</span></span><br><span class=\"line\">svn  <span class=\"keyword\">export</span>  [-r 版本号]  svn:  <span class=\"comment\">//路径(目录或文件的全路径) --username　用户名</span></span><br><span class=\"line\">svn  <span class=\"keyword\">export</span>  本地检出的(即带有.svn文件夹的)目录全路径  要导出的本地目录全路径</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn <span class=\"keyword\">export</span> svn:<span class=\"comment\">//localhost/files --username wzhnsc</span></span><br><span class=\"line\">svn <span class=\"keyword\">export</span> svn:<span class=\"comment\">//localhost/files --username wzhnsc</span></span><br><span class=\"line\">svn <span class=\"keyword\">export</span> /<span class=\"built_in\">home</span>/files /<span class=\"built_in\">home</span>/tofiles</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-添加新文件-add\"><a href=\"#3-添加新文件-add\" class=\"headerlink\" title=\"3. 添加新文件: add\"></a>3. 添加新文件: add</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">add</span><span class=\"bash\">　文件名</span></span><br><span class=\"line\"><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"bash\">//例子：</span></span><br><span class=\"line\"><span class=\"bash\">svn add picture.png</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-提交-commit-缩写-ci\"><a href=\"#4-提交-commit-缩写-ci\" class=\"headerlink\" title=\"4. 提交: commit 缩写 ci\"></a>4. 提交: commit 缩写 ci</h3><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　commit　-<span class=\"keyword\">m</span>　“提交备注信息文本“　[-<span class=\"keyword\">N</span>]　[--<span class=\"keyword\">no</span>-unlock]　文件名</span><br><span class=\"line\">svn　<span class=\"keyword\">ci</span>　-<span class=\"keyword\">m</span>　“提交备注信息文本“　    [-<span class=\"keyword\">N</span>]　[--<span class=\"keyword\">no</span>-unlock]　文件名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn commit -<span class=\"keyword\">m</span> “提交我的测试用<span class=\"keyword\">test</span>.swift“ <span class=\"keyword\">test</span>.swift</span><br><span class=\"line\">svn <span class=\"keyword\">ci</span> -<span class=\"keyword\">m</span> “提交我的测试用<span class=\"keyword\">test</span>.swift“ <span class=\"keyword\">test</span>.swift</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-更新文件-update\"><a href=\"#5-更新文件-update\" class=\"headerlink\" title=\"5. 更新文件: update\"></a>5. 更新文件: update</h3><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">update</span></span><br><span class=\"line\">svn　<span class=\"keyword\">update</span>　-r　修正版本　文件名</span><br><span class=\"line\">svn　<span class=\"keyword\">update</span>　文件名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn <span class=\"keyword\">update</span>      </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本</span></span><br><span class=\"line\"></span><br><span class=\"line\">svn <span class=\"keyword\">update</span> -r 200 <span class=\"keyword\">test</span>.swift    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将版本库中的文件 test.swift还原到修正版本（revision）200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//svn update test.swift</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//更新与版本库同步。提交的时候提示过期冲突，需要先update修改文件，然后清除</span></span><br><span class=\"line\">svn resolved，最后再提交commit。</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-删除文件-delete\"><a href=\"#6-删除文件-delete\" class=\"headerlink\" title=\"6. 删除文件: delete\"></a>6. 删除文件: delete</h3><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">delete</span>　svn:<span class=\"regexp\">//</span>路径(目录或文件的全路径) -m “删除备注信息文本”</span><br><span class=\"line\">svn　<span class=\"keyword\">delete</span>　文件名 </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>例子：</span><br><span class=\"line\">svn <span class=\"keyword\">delete</span> svn:<span class=\"regexp\">//</span>localhost<span class=\"regexp\">/testapp/</span>test.swift -m “删除测试文件test.swift”</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>如下：</span><br><span class=\"line\">svn <span class=\"keyword\">delete</span> test.swift</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-加锁-lock\"><a href=\"#7-加锁-lock\" class=\"headerlink\" title=\"7. 加锁: lock\"></a>7. 加锁: lock</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">lock</span>　-m　“加锁备注信息文本“　[<span class=\"comment\">--force]　文件名 </span></span><br><span class=\"line\">svn　<span class=\"keyword\">unlock</span>　文件名</span><br><span class=\"line\"></span><br><span class=\"line\">//例子：</span><br><span class=\"line\">svn <span class=\"keyword\">lock</span> -m “锁信测试用test.swift文件“ test.swift </span><br><span class=\"line\">svn <span class=\"keyword\">unlock</span> test.swift</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-比较差异-diff\"><a href=\"#8-比较差异-diff\" class=\"headerlink\" title=\"8. 比较差异: diff\"></a>8. 比较差异: diff</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　diff　     文件名 </span><br><span class=\"line\">svn　diff　-r　 修正版本号m:修正版本号n　文件名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn diff test<span class=\"selector-class\">.swift</span>               </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将修改的文件与基础版本比较</span></span><br><span class=\"line\"></span><br><span class=\"line\">svn diff -r <span class=\"number\">200</span>:<span class=\"number\">201</span> test<span class=\"selector-class\">.swift</span>   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对修正版本号200和修正版本号201比较差异</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"9-查看文件或者目录状态-status-缩写-st\"><a href=\"#9-查看文件或者目录状态-status-缩写-st\" class=\"headerlink\" title=\"9. 查看文件或者目录状态: status  缩写 st\"></a>9. 查看文件或者目录状态: status  缩写 st</h3><figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn st 目录路径/名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//目录下的文件和子目录的状态，正常状态不显示 //?：不在svn的控制中M：内容被修改；C：发生冲突A：预定加入到版本库 K：被锁定 </span></span><br><span class=\"line\"></span><br><span class=\"line\">svn  -v 目录路径/名</span><br><span class=\"line\"></span><br><span class=\"line\">svn status -v 目录路径/名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//显示文件和子目录状态,第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次</span></span><br><span class=\"line\"><span class=\"comment\">//修改的版本号和修改人</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"10-查看日志-log\"><a href=\"#10-查看日志-log\" class=\"headerlink\" title=\"10. 查看日志: log\"></a>10. 查看日志: log</h3><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">log</span>　文件名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn <span class=\"keyword\">log</span> <span class=\"keyword\">test</span>.swift    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//显示这个文件的所有修改记录，及其版本号的变化</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"11-查看文件详细信息-info\"><a href=\"#11-查看文件详细信息-info\" class=\"headerlink\" title=\"11. 查看文件详细信息: info\"></a>11. 查看文件详细信息: info</h3><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">svn</span>　<span class=\"literal\">info</span>　文件名</span><br><span class=\"line\"></span><br><span class=\"line\">//例子：</span><br><span class=\"line\">svn <span class=\"literal\">info</span> test.swift</span><br></pre></td></tr></table></figure>\n<h3 id=\"12-查看版本库下的文件和目录列表-list-缩写-ls\"><a href=\"#12-查看版本库下的文件和目录列表-list-缩写-ls\" class=\"headerlink\" title=\"12. 查看版本库下的文件和目录列表: list 缩写 ls\"></a>12. 查看版本库下的文件和目录列表: list 缩写 ls</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　list　<span class=\"string\">svn:</span><span class=\"comment\">//路径(目录或文件的全路径)</span></span><br><span class=\"line\">svn　ls　<span class=\"string\">svn:</span><span class=\"comment\">//路径(目录或文件的全路径)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn list <span class=\"string\">svn:</span><span class=\"comment\">//localhost/test</span></span><br><span class=\"line\">svn ls <span class=\"string\">svn:</span><span class=\"comment\">//localhost/test   </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//显示svn://localhost/test目录下的所有属于版本库的文件和目录</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"13-恢复本地修改-revert\"><a href=\"#13-恢复本地修改-revert\" class=\"headerlink\" title=\"13. 恢复本地修改: revert\"></a>13. 恢复本地修改: revert</h3><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　revert　[<span class=\"params\">--recursive</span>]　文件名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span>注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span>例子：</span><br><span class=\"line\">svn revert taotao.swift      </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span>丢弃对一个文件的修改</span><br><span class=\"line\"></span><br><span class=\"line\">svn revert <span class=\"params\">--recursive</span> .     </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span>恢复一整个目录的文件，. 为当前目录</span><br></pre></td></tr></table></figure>\n<h3 id=\"14-把工作拷贝更新到别的URL-switch\"><a href=\"#14-把工作拷贝更新到别的URL-switch\" class=\"headerlink\" title=\"14. 把工作拷贝更新到别的URL: switch\"></a>14. 把工作拷贝更新到别的URL: switch</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">switch</span>　<span class=\"string\">http:</span><span class=\"comment\">//目录全路径　  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//本地目录全路径</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn <span class=\"keyword\">switch</span> <span class=\"string\">http:</span><span class=\"comment\">//localhost/test/456 .  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//(原为123的分支)当前所在目录分支到</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"15-新建分支-copy\"><a href=\"#15-新建分支-copy\" class=\"headerlink\" title=\"15. 新建分支: copy\"></a>15. 新建分支: copy</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn <span class=\"keyword\">copy</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"bash\">//例子：</span></span><br><span class=\"line\"><span class=\"bash\">svn copy branchA branchB  -m <span class=\"string\">\"make B branch\"</span></span></span><br><span class=\"line\"><span class=\"bash\">//从branchA拷贝出一个新分支branchB</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"16-合并分支-merge\"><a href=\"#16-合并分支-merge\" class=\"headerlink\" title=\"16. 合并分支: merge\"></a>16. 合并分支: merge</h3><figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn <span class=\"keyword\">merge</span> branchA branchB  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//把对branchA的修改合并到分支branchB</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"17-解决冲突：resolved\"><a href=\"#17-解决冲突：resolved\" class=\"headerlink\" title=\"17. 解决冲突：resolved\"></a>17. 解决冲突：resolved</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　resolved　[本地目录全路径]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">$ svn update</span><br><span class=\"line\">C foo.c</span><br><span class=\"line\">Updated to revision <span class=\"number\">31</span>.</span><br><span class=\"line\"><span class=\"comment\">//如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ ls</span><br><span class=\"line\">foo.c</span><br><span class=\"line\">foo<span class=\"selector-class\">.c</span><span class=\"selector-class\">.mine</span></span><br><span class=\"line\">foo<span class=\"selector-class\">.c</span><span class=\"selector-class\">.r30</span></span><br><span class=\"line\">foo<span class=\"selector-class\">.c</span><span class=\"selector-class\">.r31</span></span><br><span class=\"line\"><span class=\"comment\">//当你解决了foo.c的冲突，并且准备提交，</span></span><br><span class=\"line\"><span class=\"comment\">//运行svn resolved让你的工作拷贝知道你已经完成了所有事情。</span></span><br><span class=\"line\"><span class=\"comment\">//你可以仅仅删除冲突的文件并且提交，</span></span><br><span class=\"line\"><span class=\"comment\">//但是svn resolved除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据。</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-检出-checkout-缩写-co\"><a href=\"#1-检出-checkout-缩写-co\" class=\"headerlink\" title=\"1. 检出: checkout 缩写 co\"></a>1. 检出: checkout 缩写 co</h3><p>如果不带 –password  参数传输密码的话，会提示输入密码，建议不要用明文的 –password 选项。其中 username 与 password前是两个短线，不是一个。默认check到当前目录。<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn  checkout  <span class=\"string\">http:</span><span class=\"comment\">//路径(目录或文件的全路径)　[本地目录全路径] --username　用户名</span></span><br><span class=\"line\">svn  checkout  <span class=\"string\">svn:</span><span class=\"comment\">//路径(目录或文件的全路径)　 [本地目录全路径] --username　用户名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn co <span class=\"string\">svn:</span><span class=\"comment\">//localhost/files          --username taotao</span></span><br><span class=\"line\">svn checkout <span class=\"string\">http:</span><span class=\"comment\">//localhost/files   --username taotao</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-导出-导出一个干净的不带-svn文件夹的目录树\"><a href=\"#2-导出-导出一个干净的不带-svn文件夹的目录树\" class=\"headerlink\" title=\"2. 导出(导出一个干净的不带.svn文件夹的目录树)\"></a>2. 导出(导出一个干净的不带.svn文件夹的目录树)</h3><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn  <span class=\"keyword\">export</span>  [-r 版本号]  http: <span class=\"comment\">//路径(目录或文件的全路径) --username　用户名</span></span><br><span class=\"line\">svn  <span class=\"keyword\">export</span>  [-r 版本号]  svn:  <span class=\"comment\">//路径(目录或文件的全路径) --username　用户名</span></span><br><span class=\"line\">svn  <span class=\"keyword\">export</span>  本地检出的(即带有.svn文件夹的)目录全路径  要导出的本地目录全路径</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn <span class=\"keyword\">export</span> svn:<span class=\"comment\">//localhost/files --username wzhnsc</span></span><br><span class=\"line\">svn <span class=\"keyword\">export</span> svn:<span class=\"comment\">//localhost/files --username wzhnsc</span></span><br><span class=\"line\">svn <span class=\"keyword\">export</span> /<span class=\"built_in\">home</span>/files /<span class=\"built_in\">home</span>/tofiles</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-添加新文件-add\"><a href=\"#3-添加新文件-add\" class=\"headerlink\" title=\"3. 添加新文件: add\"></a>3. 添加新文件: add</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">add</span><span class=\"bash\">　文件名</span></span><br><span class=\"line\"><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"bash\">//例子：</span></span><br><span class=\"line\"><span class=\"bash\">svn add picture.png</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-提交-commit-缩写-ci\"><a href=\"#4-提交-commit-缩写-ci\" class=\"headerlink\" title=\"4. 提交: commit 缩写 ci\"></a>4. 提交: commit 缩写 ci</h3><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　commit　-<span class=\"keyword\">m</span>　“提交备注信息文本“　[-<span class=\"keyword\">N</span>]　[--<span class=\"keyword\">no</span>-unlock]　文件名</span><br><span class=\"line\">svn　<span class=\"keyword\">ci</span>　-<span class=\"keyword\">m</span>　“提交备注信息文本“　    [-<span class=\"keyword\">N</span>]　[--<span class=\"keyword\">no</span>-unlock]　文件名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn commit -<span class=\"keyword\">m</span> “提交我的测试用<span class=\"keyword\">test</span>.swift“ <span class=\"keyword\">test</span>.swift</span><br><span class=\"line\">svn <span class=\"keyword\">ci</span> -<span class=\"keyword\">m</span> “提交我的测试用<span class=\"keyword\">test</span>.swift“ <span class=\"keyword\">test</span>.swift</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-更新文件-update\"><a href=\"#5-更新文件-update\" class=\"headerlink\" title=\"5. 更新文件: update\"></a>5. 更新文件: update</h3><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">update</span></span><br><span class=\"line\">svn　<span class=\"keyword\">update</span>　-r　修正版本　文件名</span><br><span class=\"line\">svn　<span class=\"keyword\">update</span>　文件名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn <span class=\"keyword\">update</span>      </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本</span></span><br><span class=\"line\"></span><br><span class=\"line\">svn <span class=\"keyword\">update</span> -r 200 <span class=\"keyword\">test</span>.swift    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将版本库中的文件 test.swift还原到修正版本（revision）200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//svn update test.swift</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//更新与版本库同步。提交的时候提示过期冲突，需要先update修改文件，然后清除</span></span><br><span class=\"line\">svn resolved，最后再提交commit。</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-删除文件-delete\"><a href=\"#6-删除文件-delete\" class=\"headerlink\" title=\"6. 删除文件: delete\"></a>6. 删除文件: delete</h3><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">delete</span>　svn:<span class=\"regexp\">//</span>路径(目录或文件的全路径) -m “删除备注信息文本”</span><br><span class=\"line\">svn　<span class=\"keyword\">delete</span>　文件名 </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>例子：</span><br><span class=\"line\">svn <span class=\"keyword\">delete</span> svn:<span class=\"regexp\">//</span>localhost<span class=\"regexp\">/testapp/</span>test.swift -m “删除测试文件test.swift”</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>如下：</span><br><span class=\"line\">svn <span class=\"keyword\">delete</span> test.swift</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-加锁-lock\"><a href=\"#7-加锁-lock\" class=\"headerlink\" title=\"7. 加锁: lock\"></a>7. 加锁: lock</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">lock</span>　-m　“加锁备注信息文本“　[<span class=\"comment\">--force]　文件名 </span></span><br><span class=\"line\">svn　<span class=\"keyword\">unlock</span>　文件名</span><br><span class=\"line\"></span><br><span class=\"line\">//例子：</span><br><span class=\"line\">svn <span class=\"keyword\">lock</span> -m “锁信测试用test.swift文件“ test.swift </span><br><span class=\"line\">svn <span class=\"keyword\">unlock</span> test.swift</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-比较差异-diff\"><a href=\"#8-比较差异-diff\" class=\"headerlink\" title=\"8. 比较差异: diff\"></a>8. 比较差异: diff</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　diff　     文件名 </span><br><span class=\"line\">svn　diff　-r　 修正版本号m:修正版本号n　文件名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn diff test<span class=\"selector-class\">.swift</span>               </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将修改的文件与基础版本比较</span></span><br><span class=\"line\"></span><br><span class=\"line\">svn diff -r <span class=\"number\">200</span>:<span class=\"number\">201</span> test<span class=\"selector-class\">.swift</span>   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对修正版本号200和修正版本号201比较差异</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"9-查看文件或者目录状态-status-缩写-st\"><a href=\"#9-查看文件或者目录状态-status-缩写-st\" class=\"headerlink\" title=\"9. 查看文件或者目录状态: status  缩写 st\"></a>9. 查看文件或者目录状态: status  缩写 st</h3><figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn st 目录路径/名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//目录下的文件和子目录的状态，正常状态不显示 //?：不在svn的控制中M：内容被修改；C：发生冲突A：预定加入到版本库 K：被锁定 </span></span><br><span class=\"line\"></span><br><span class=\"line\">svn  -v 目录路径/名</span><br><span class=\"line\"></span><br><span class=\"line\">svn status -v 目录路径/名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//显示文件和子目录状态,第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次</span></span><br><span class=\"line\"><span class=\"comment\">//修改的版本号和修改人</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"10-查看日志-log\"><a href=\"#10-查看日志-log\" class=\"headerlink\" title=\"10. 查看日志: log\"></a>10. 查看日志: log</h3><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">log</span>　文件名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn <span class=\"keyword\">log</span> <span class=\"keyword\">test</span>.swift    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//显示这个文件的所有修改记录，及其版本号的变化</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"11-查看文件详细信息-info\"><a href=\"#11-查看文件详细信息-info\" class=\"headerlink\" title=\"11. 查看文件详细信息: info\"></a>11. 查看文件详细信息: info</h3><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">svn</span>　<span class=\"literal\">info</span>　文件名</span><br><span class=\"line\"></span><br><span class=\"line\">//例子：</span><br><span class=\"line\">svn <span class=\"literal\">info</span> test.swift</span><br></pre></td></tr></table></figure>\n<h3 id=\"12-查看版本库下的文件和目录列表-list-缩写-ls\"><a href=\"#12-查看版本库下的文件和目录列表-list-缩写-ls\" class=\"headerlink\" title=\"12. 查看版本库下的文件和目录列表: list 缩写 ls\"></a>12. 查看版本库下的文件和目录列表: list 缩写 ls</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　list　<span class=\"string\">svn:</span><span class=\"comment\">//路径(目录或文件的全路径)</span></span><br><span class=\"line\">svn　ls　<span class=\"string\">svn:</span><span class=\"comment\">//路径(目录或文件的全路径)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn list <span class=\"string\">svn:</span><span class=\"comment\">//localhost/test</span></span><br><span class=\"line\">svn ls <span class=\"string\">svn:</span><span class=\"comment\">//localhost/test   </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//显示svn://localhost/test目录下的所有属于版本库的文件和目录</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"13-恢复本地修改-revert\"><a href=\"#13-恢复本地修改-revert\" class=\"headerlink\" title=\"13. 恢复本地修改: revert\"></a>13. 恢复本地修改: revert</h3><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　revert　[<span class=\"params\">--recursive</span>]　文件名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span>注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span>例子：</span><br><span class=\"line\">svn revert taotao.swift      </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span>丢弃对一个文件的修改</span><br><span class=\"line\"></span><br><span class=\"line\">svn revert <span class=\"params\">--recursive</span> .     </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span>恢复一整个目录的文件，. 为当前目录</span><br></pre></td></tr></table></figure>\n<h3 id=\"14-把工作拷贝更新到别的URL-switch\"><a href=\"#14-把工作拷贝更新到别的URL-switch\" class=\"headerlink\" title=\"14. 把工作拷贝更新到别的URL: switch\"></a>14. 把工作拷贝更新到别的URL: switch</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">switch</span>　<span class=\"string\">http:</span><span class=\"comment\">//目录全路径　  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//本地目录全路径</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn <span class=\"keyword\">switch</span> <span class=\"string\">http:</span><span class=\"comment\">//localhost/test/456 .  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//(原为123的分支)当前所在目录分支到</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"15-新建分支-copy\"><a href=\"#15-新建分支-copy\" class=\"headerlink\" title=\"15. 新建分支: copy\"></a>15. 新建分支: copy</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn <span class=\"keyword\">copy</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"bash\">//例子：</span></span><br><span class=\"line\"><span class=\"bash\">svn copy branchA branchB  -m <span class=\"string\">\"make B branch\"</span></span></span><br><span class=\"line\"><span class=\"bash\">//从branchA拷贝出一个新分支branchB</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"16-合并分支-merge\"><a href=\"#16-合并分支-merge\" class=\"headerlink\" title=\"16. 合并分支: merge\"></a>16. 合并分支: merge</h3><figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn <span class=\"keyword\">merge</span> branchA branchB  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//把对branchA的修改合并到分支branchB</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"17-解决冲突：resolved\"><a href=\"#17-解决冲突：resolved\" class=\"headerlink\" title=\"17. 解决冲突：resolved\"></a>17. 解决冲突：resolved</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　resolved　[本地目录全路径]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">$ svn update</span><br><span class=\"line\">C foo.c</span><br><span class=\"line\">Updated to revision <span class=\"number\">31</span>.</span><br><span class=\"line\"><span class=\"comment\">//如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ ls</span><br><span class=\"line\">foo.c</span><br><span class=\"line\">foo<span class=\"selector-class\">.c</span><span class=\"selector-class\">.mine</span></span><br><span class=\"line\">foo<span class=\"selector-class\">.c</span><span class=\"selector-class\">.r30</span></span><br><span class=\"line\">foo<span class=\"selector-class\">.c</span><span class=\"selector-class\">.r31</span></span><br><span class=\"line\"><span class=\"comment\">//当你解决了foo.c的冲突，并且准备提交，</span></span><br><span class=\"line\"><span class=\"comment\">//运行svn resolved让你的工作拷贝知道你已经完成了所有事情。</span></span><br><span class=\"line\"><span class=\"comment\">//你可以仅仅删除冲突的文件并且提交，</span></span><br><span class=\"line\"><span class=\"comment\">//但是svn resolved除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据。</span></span><br></pre></td></tr></table></figure>\n"},{"title":"iOS-RunLoop","date":"2019-06-05T06:01:15.000Z","_content":"\n## 1. RunLoop 概念\n\n\n## 2. RunLoop 组成结构\n\n\n## 3. RunLoop 实现\n\n\n## 4. RunLoop 实际应用","source":"_posts/iOS-RunLoop.md","raw":"---\ntitle: iOS-RunLoop\ndate: 2019-06-5 14:01:15\ntags: iOS\n---\n\n## 1. RunLoop 概念\n\n\n## 2. RunLoop 组成结构\n\n\n## 3. RunLoop 实现\n\n\n## 4. RunLoop 实际应用","slug":"iOS-RunLoop","published":1,"updated":"2019-06-19T03:08:22.241Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx2nwtym0005u78ekkf8cw5i","content":"<h2 id=\"1-RunLoop-概念\"><a href=\"#1-RunLoop-概念\" class=\"headerlink\" title=\"1. RunLoop 概念\"></a>1. RunLoop 概念</h2><h2 id=\"2-RunLoop-组成结构\"><a href=\"#2-RunLoop-组成结构\" class=\"headerlink\" title=\"2. RunLoop 组成结构\"></a>2. RunLoop 组成结构</h2><h2 id=\"3-RunLoop-实现\"><a href=\"#3-RunLoop-实现\" class=\"headerlink\" title=\"3. RunLoop 实现\"></a>3. RunLoop 实现</h2><h2 id=\"4-RunLoop-实际应用\"><a href=\"#4-RunLoop-实际应用\" class=\"headerlink\" title=\"4. RunLoop 实际应用\"></a>4. RunLoop 实际应用</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-RunLoop-概念\"><a href=\"#1-RunLoop-概念\" class=\"headerlink\" title=\"1. RunLoop 概念\"></a>1. RunLoop 概念</h2><h2 id=\"2-RunLoop-组成结构\"><a href=\"#2-RunLoop-组成结构\" class=\"headerlink\" title=\"2. RunLoop 组成结构\"></a>2. RunLoop 组成结构</h2><h2 id=\"3-RunLoop-实现\"><a href=\"#3-RunLoop-实现\" class=\"headerlink\" title=\"3. RunLoop 实现\"></a>3. RunLoop 实现</h2><h2 id=\"4-RunLoop-实际应用\"><a href=\"#4-RunLoop-实际应用\" class=\"headerlink\" title=\"4. RunLoop 实际应用\"></a>4. RunLoop 实际应用</h2>"},{"title":"Git-常用命令","date":"2018-02-02T02:25:47.000Z","_content":"\n### 1. Git分区：\n\n 工作区 (Working directory)：本地数据或者代码编辑区，数据或者代码操作区。\n\t暂存区 (Index cache)：数据或者代码暂时存放区。\n\t版本库 (Local repository)：存放已经提交的数据或者代码，此区数据或者代码直接push到远程仓库。\n\t分区之间数据传递流程图如下：\n###### ![](Git-常用命令/git_sections.png)\n### 2.  Git命令：\n\n#### (1) 基本操作\n```\n\tgit init                      //创建空仓库，当前目录下多出 .git 目录 \n\n\tgit add <file>                //将文件添加到缓存 \n\n\tgit status                    //查看在你上次提交之后是否有修改 \n\n\tgit diff                      //查看尚未缓存的修改\n\n\tgit diff --cached             //查看已经缓存的修改\n\n\tgit diff HEAD                 //查看已缓存和未缓存的所有修改\n\n\tgit diff --stat               //统计哪些文件发生了改变，有多少行产生了改动，并不会给出改动的具体内容\n\n\tgit commit -m\"message\"        //缓存区内容添加到仓库中\n\n\tgit commit -a                 //跳过 git add 提交缓存，直接commit\n\n\tgit reset HEAD  <file>        //取消之前 git add 添加，但不希望包含在下一提交快照中的缓存\n\n\tgit rm <file>                 //从工作目录中手工删除文件\n\n\tgit rm -f <file>              //强制删除之前修改过并且已经放到暂存区域的文件\n\n\tgit rm --cached <file>        //把文件从暂存区域移除，但仍然保留在当前工作目录中\n\n\tgit rm –r *                   //删除整个目录中的所有子目录和文件\n\n\tgit mv                        //移动或重命名一个文件、目录、软连接\n\n```\n\n#### (2) 分支管理\n```\n\tgit branch (branchname)        //创建分支\n\n\tgit checkout (branchname)      //切换分支\n\n\tgit checkout -b (branchname)   //加上-b参数表示创建并切换分支\n\n\tgit branch                     //列出所有分支，当前分支前面会标一个*号\n\n\tgit merge  (branchname)        //合并指定分支(branchname)到当前分支\n\n\tgit branch -d (branchname)     //删除分支\n\n```\n\n#### (3) 查看历史提交\n```\n\tgit log                         //查看提交历史\n\n\tgit log --oneline               //查看简洁的历史提交信息\n\n\tgit log --graph                 //查看分支合并图\n\n\tgit log --reverse --oneline     //逆向显示所有日志\n\n\tgit log --author                //查看指定用户的提交日志\n\n\tgit log --oneline --before={starttime}  --after={endtime}\n\n\tgit log --oneline --until={starttime}  --after={endtime}      //查看时间段的历史提交，后面加 --no-merges 选项以隐藏合并提交\n\n```\n\n#### (4) 添加标签\n```\n\tgit tag -a <tagname>                   //-a 选项意为创建一个带注解的标签，不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解\n\n\tgit tag                                //查看所有标签\n\n\tgit tag -a <tagname> -m\"标签信息\"       //指定标签信息\n\n```\n\n#### (5) Git 远程仓库\n```\n\tgit remote add [alias] [url]      //添加一个新的远程仓库， alias为远程仓库别名\n\n\tgit remote                        //查看当前配置的远程仓库\n\n\tgit fetch                         //从远程仓库下载新分支与数据，执行完后需要执行git merge 远程分支到你所在的分支\n\n\tgit push [alias] [branchname]     //推送新分支与数据到某个远端仓库\n\n\tgit remote rm [alias]             //删除远程仓库 \n\n```\n\n#### (6) Git rebase\n\n假设现在基于远程分支 *origin* ，创建一个叫 *mybranch* 的分支，然后在这个分支做一些修改。然后生成若干个提交 **(commit)**，但是与此同时，有些人也在 *origin* 分支上做了一些修改并且做了提交了。\n这就意味着 *origin* 和 *mybranch* 这两个分支各自<前进> 了，它们之间<分叉> 了。你可以用 *pull* 命令把 *origin* 分支上的修改拉下来并且和你的修改合并。\n结果看起来就像一个新的 *合并的提交* **(merge commit)**。如果你想让 *mybranch* 分支历史看起来像没有经过任何合并一样，可以用 git rebase ：\n```\n\tgit rebase origin\n\n```\n该命令会把你的 *mybranch* 分支里的每个提交 **(commit)** 取消掉，并且把它们临时保存为补丁 **(patch)** ( 这些补丁放到\" .git/rebase \"目录中 )。\n然后把 *mybranch* 分支更新到最新的 *origin* 分支，最后把保存的这些补丁应用到 *mybranch* 分支上。\n当 *mybranch* 分支更新之后，它会指向这些新创建的提交 **(commit)**, 而那些老的提交会被丢弃。 如果运行垃圾收集命令 **(pruning garbage collection)**, 这些被丢弃的提交就会删除。\n在 **rebase** 的过程中，也许会出现冲突 **(conflict)**. 在这种情况，Git 会停止 rebase 并会让你去解决冲突；在解决完冲突后，用 **git-add** 命令去更新这些内容的索引 (index), 然后，你无需执行**git-commit** ,只要执行 **continue** 命令，这样 git 会继续应用 **(apply)** 余下的补丁：\n\n```\n\tgit rebase --continue\n\n```\n任何时候，可以用** --abort **参数来终止 rebase 的行动，并且 *mybranch* 分支会回到 rebase 开始前的状态。\n```\n\tgit rebase --abort\n\n```","source":"_posts/Git-常用命令.md","raw":"---\ntitle: Git-常用命令\ndate: 2018-02-02 10:25:47\ntags: Git\n---\n\n### 1. Git分区：\n\n 工作区 (Working directory)：本地数据或者代码编辑区，数据或者代码操作区。\n\t暂存区 (Index cache)：数据或者代码暂时存放区。\n\t版本库 (Local repository)：存放已经提交的数据或者代码，此区数据或者代码直接push到远程仓库。\n\t分区之间数据传递流程图如下：\n###### ![](Git-常用命令/git_sections.png)\n### 2.  Git命令：\n\n#### (1) 基本操作\n```\n\tgit init                      //创建空仓库，当前目录下多出 .git 目录 \n\n\tgit add <file>                //将文件添加到缓存 \n\n\tgit status                    //查看在你上次提交之后是否有修改 \n\n\tgit diff                      //查看尚未缓存的修改\n\n\tgit diff --cached             //查看已经缓存的修改\n\n\tgit diff HEAD                 //查看已缓存和未缓存的所有修改\n\n\tgit diff --stat               //统计哪些文件发生了改变，有多少行产生了改动，并不会给出改动的具体内容\n\n\tgit commit -m\"message\"        //缓存区内容添加到仓库中\n\n\tgit commit -a                 //跳过 git add 提交缓存，直接commit\n\n\tgit reset HEAD  <file>        //取消之前 git add 添加，但不希望包含在下一提交快照中的缓存\n\n\tgit rm <file>                 //从工作目录中手工删除文件\n\n\tgit rm -f <file>              //强制删除之前修改过并且已经放到暂存区域的文件\n\n\tgit rm --cached <file>        //把文件从暂存区域移除，但仍然保留在当前工作目录中\n\n\tgit rm –r *                   //删除整个目录中的所有子目录和文件\n\n\tgit mv                        //移动或重命名一个文件、目录、软连接\n\n```\n\n#### (2) 分支管理\n```\n\tgit branch (branchname)        //创建分支\n\n\tgit checkout (branchname)      //切换分支\n\n\tgit checkout -b (branchname)   //加上-b参数表示创建并切换分支\n\n\tgit branch                     //列出所有分支，当前分支前面会标一个*号\n\n\tgit merge  (branchname)        //合并指定分支(branchname)到当前分支\n\n\tgit branch -d (branchname)     //删除分支\n\n```\n\n#### (3) 查看历史提交\n```\n\tgit log                         //查看提交历史\n\n\tgit log --oneline               //查看简洁的历史提交信息\n\n\tgit log --graph                 //查看分支合并图\n\n\tgit log --reverse --oneline     //逆向显示所有日志\n\n\tgit log --author                //查看指定用户的提交日志\n\n\tgit log --oneline --before={starttime}  --after={endtime}\n\n\tgit log --oneline --until={starttime}  --after={endtime}      //查看时间段的历史提交，后面加 --no-merges 选项以隐藏合并提交\n\n```\n\n#### (4) 添加标签\n```\n\tgit tag -a <tagname>                   //-a 选项意为创建一个带注解的标签，不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解\n\n\tgit tag                                //查看所有标签\n\n\tgit tag -a <tagname> -m\"标签信息\"       //指定标签信息\n\n```\n\n#### (5) Git 远程仓库\n```\n\tgit remote add [alias] [url]      //添加一个新的远程仓库， alias为远程仓库别名\n\n\tgit remote                        //查看当前配置的远程仓库\n\n\tgit fetch                         //从远程仓库下载新分支与数据，执行完后需要执行git merge 远程分支到你所在的分支\n\n\tgit push [alias] [branchname]     //推送新分支与数据到某个远端仓库\n\n\tgit remote rm [alias]             //删除远程仓库 \n\n```\n\n#### (6) Git rebase\n\n假设现在基于远程分支 *origin* ，创建一个叫 *mybranch* 的分支，然后在这个分支做一些修改。然后生成若干个提交 **(commit)**，但是与此同时，有些人也在 *origin* 分支上做了一些修改并且做了提交了。\n这就意味着 *origin* 和 *mybranch* 这两个分支各自<前进> 了，它们之间<分叉> 了。你可以用 *pull* 命令把 *origin* 分支上的修改拉下来并且和你的修改合并。\n结果看起来就像一个新的 *合并的提交* **(merge commit)**。如果你想让 *mybranch* 分支历史看起来像没有经过任何合并一样，可以用 git rebase ：\n```\n\tgit rebase origin\n\n```\n该命令会把你的 *mybranch* 分支里的每个提交 **(commit)** 取消掉，并且把它们临时保存为补丁 **(patch)** ( 这些补丁放到\" .git/rebase \"目录中 )。\n然后把 *mybranch* 分支更新到最新的 *origin* 分支，最后把保存的这些补丁应用到 *mybranch* 分支上。\n当 *mybranch* 分支更新之后，它会指向这些新创建的提交 **(commit)**, 而那些老的提交会被丢弃。 如果运行垃圾收集命令 **(pruning garbage collection)**, 这些被丢弃的提交就会删除。\n在 **rebase** 的过程中，也许会出现冲突 **(conflict)**. 在这种情况，Git 会停止 rebase 并会让你去解决冲突；在解决完冲突后，用 **git-add** 命令去更新这些内容的索引 (index), 然后，你无需执行**git-commit** ,只要执行 **continue** 命令，这样 git 会继续应用 **(apply)** 余下的补丁：\n\n```\n\tgit rebase --continue\n\n```\n任何时候，可以用** --abort **参数来终止 rebase 的行动，并且 *mybranch* 分支会回到 rebase 开始前的状态。\n```\n\tgit rebase --abort\n\n```","slug":"Git-常用命令","published":1,"updated":"2019-06-01T06:52:15.085Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx2nwtyn0006u78elxyzf1wq","content":"<h3 id=\"1-Git分区：\"><a href=\"#1-Git分区：\" class=\"headerlink\" title=\"1. Git分区：\"></a>1. Git分区：</h3><p> 工作区 (Working directory)：本地数据或者代码编辑区，数据或者代码操作区。<br>    暂存区 (Index cache)：数据或者代码暂时存放区。<br>    版本库 (Local repository)：存放已经提交的数据或者代码，此区数据或者代码直接push到远程仓库。<br>    分区之间数据传递流程图如下：</p>\n<h6 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"/2018/02/02/Git-常用命令/git_sections.png\" alt=\"\"></h6><h3 id=\"2-Git命令：\"><a href=\"#2-Git命令：\" class=\"headerlink\" title=\"2.  Git命令：\"></a>2.  Git命令：</h3><h4 id=\"1-基本操作\"><a href=\"#1-基本操作\" class=\"headerlink\" title=\"(1) 基本操作\"></a>(1) 基本操作</h4><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init                      <span class=\"comment\">//创建空仓库，当前目录下多出 .git 目录 </span></span><br><span class=\"line\"></span><br><span class=\"line\">git add &lt;<span class=\"keyword\">file</span>&gt;                <span class=\"comment\">//将文件添加到缓存 </span></span><br><span class=\"line\"></span><br><span class=\"line\">git status                    <span class=\"comment\">//查看在你上次提交之后是否有修改 </span></span><br><span class=\"line\"></span><br><span class=\"line\">git diff                      <span class=\"comment\">//查看尚未缓存的修改</span></span><br><span class=\"line\"></span><br><span class=\"line\">git diff --cached             <span class=\"comment\">//查看已经缓存的修改</span></span><br><span class=\"line\"></span><br><span class=\"line\">git diff HEAD                 <span class=\"comment\">//查看已缓存和未缓存的所有修改</span></span><br><span class=\"line\"></span><br><span class=\"line\">git diff --stat               <span class=\"comment\">//统计哪些文件发生了改变，有多少行产生了改动，并不会给出改动的具体内容</span></span><br><span class=\"line\"></span><br><span class=\"line\">git commit -<span class=\"keyword\">m</span><span class=\"string\">\"message\"</span>        <span class=\"comment\">//缓存区内容添加到仓库中</span></span><br><span class=\"line\"></span><br><span class=\"line\">git commit -a                 <span class=\"comment\">//跳过 git add 提交缓存，直接commit</span></span><br><span class=\"line\"></span><br><span class=\"line\">git reset HEAD  &lt;<span class=\"keyword\">file</span>&gt;        <span class=\"comment\">//取消之前 git add 添加，但不希望包含在下一提交快照中的缓存</span></span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">rm</span> &lt;<span class=\"keyword\">file</span>&gt;                 <span class=\"comment\">//从工作目录中手工删除文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">rm</span> -f &lt;<span class=\"keyword\">file</span>&gt;              <span class=\"comment\">//强制删除之前修改过并且已经放到暂存区域的文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">rm</span> --cached &lt;<span class=\"keyword\">file</span>&gt;        <span class=\"comment\">//把文件从暂存区域移除，但仍然保留在当前工作目录中</span></span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">rm</span> –r *                   <span class=\"comment\">//删除整个目录中的所有子目录和文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">git mv                        <span class=\"comment\">//移动或重命名一个文件、目录、软连接</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-分支管理\"><a href=\"#2-分支管理\" class=\"headerlink\" title=\"(2) 分支管理\"></a>(2) 分支管理</h4><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">git</span> <span class=\"keyword\">branch </span>(<span class=\"keyword\">branchname) </span>       //创建分支</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">git</span> checkout (<span class=\"keyword\">branchname) </span>     //切换分支</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">git</span> checkout -<span class=\"keyword\">b </span>(<span class=\"keyword\">branchname) </span>  //加上-<span class=\"keyword\">b参数表示创建并切换分支</span></span><br><span class=\"line\"><span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">git </span><span class=\"keyword\">branch </span>                    //列出所有分支，当前分支前面会标一个*号</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">git</span> merge  (<span class=\"keyword\">branchname) </span>       //合并指定分支(<span class=\"keyword\">branchname)到当前分支</span></span><br><span class=\"line\"><span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">git </span><span class=\"keyword\">branch </span>-d (<span class=\"keyword\">branchname) </span>    //删除分支</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-查看历史提交\"><a href=\"#3-查看历史提交\" class=\"headerlink\" title=\"(3) 查看历史提交\"></a>(3) 查看历史提交</h4><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log                         <span class=\"string\">//</span>查看提交历史</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--oneline</span>               <span class=\"string\">//</span>查看简洁的历史提交信息</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--graph</span>                 <span class=\"string\">//</span>查看分支合并图</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--reverse</span> <span class=\"params\">--oneline</span>     <span class=\"string\">//</span>逆向显示所有日志</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--author</span>                <span class=\"string\">//</span>查看指定用户的提交日志</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--oneline</span> <span class=\"params\">--before=</span>&#123;starttime&#125;  <span class=\"params\">--after=</span>&#123;endtime&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--oneline</span> <span class=\"params\">--until=</span>&#123;starttime&#125;  <span class=\"params\">--after=</span>&#123;endtime&#125;      <span class=\"string\">//</span>查看时间段的历史提交，后面加 <span class=\"params\">--no-merges</span> 选项以隐藏合并提交</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-添加标签\"><a href=\"#4-添加标签\" class=\"headerlink\" title=\"(4) 添加标签\"></a>(4) 添加标签</h4><figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"keyword\">tag</span> <span class=\"title\">-a</span> <span class=\"tag\">&lt;tagname&gt;</span>                   //-a 选项意为创建一个带注解的标签，不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解</span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">tag</span>                                <span class=\"title\">//查看所有标签</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br><span class=\"line\"><span class=\"title\">git</span> <span class=\"keyword\">tag</span> <span class=\"title\">-a</span> <span class=\"tag\">&lt;tagname&gt;</span> -m<span class=\"string\">\"标签信息\"</span>       //指定标签信息</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-Git-远程仓库\"><a href=\"#5-Git-远程仓库\" class=\"headerlink\" title=\"(5) Git 远程仓库\"></a>(5) Git 远程仓库</h4><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">git</span> <span class=\"selector-tag\">remote</span> <span class=\"selector-tag\">add</span> <span class=\"selector-attr\">[alias]</span> <span class=\"selector-attr\">[url]</span>      <span class=\"comment\">//添加一个新的远程仓库， alias为远程仓库别名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">git</span> <span class=\"selector-tag\">remote</span>                        <span class=\"comment\">//查看当前配置的远程仓库</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">git</span> <span class=\"selector-tag\">fetch</span>                         <span class=\"comment\">//从远程仓库下载新分支与数据，执行完后需要执行git merge 远程分支到你所在的分支</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">git</span> <span class=\"selector-tag\">push</span> <span class=\"selector-attr\">[alias]</span> <span class=\"selector-attr\">[branchname]</span>     <span class=\"comment\">//推送新分支与数据到某个远端仓库</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">git</span> <span class=\"selector-tag\">remote</span> <span class=\"selector-tag\">rm</span> <span class=\"selector-attr\">[alias]</span>             <span class=\"comment\">//删除远程仓库</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"6-Git-rebase\"><a href=\"#6-Git-rebase\" class=\"headerlink\" title=\"(6) Git rebase\"></a>(6) Git rebase</h4><p>假设现在基于远程分支 <em>origin</em> ，创建一个叫 <em>mybranch</em> 的分支，然后在这个分支做一些修改。然后生成若干个提交 <strong>(commit)</strong>，但是与此同时，有些人也在 <em>origin</em> 分支上做了一些修改并且做了提交了。<br>这就意味着 <em>origin</em> 和 <em>mybranch</em> 这两个分支各自&lt;前进&gt; 了，它们之间&lt;分叉&gt; 了。你可以用 <em>pull</em> 命令把 <em>origin</em> 分支上的修改拉下来并且和你的修改合并。<br>结果看起来就像一个新的 <em>合并的提交</em> <strong>(merge commit)</strong>。如果你想让 <em>mybranch</em> 分支历史看起来像没有经过任何合并一样，可以用 git rebase ：<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">git rebase origin</span></span><br></pre></td></tr></table></figure></p>\n<p>该命令会把你的 <em>mybranch</em> 分支里的每个提交 <strong>(commit)</strong> 取消掉，并且把它们临时保存为补丁 <strong>(patch)</strong> ( 这些补丁放到” .git/rebase “目录中 )。<br>然后把 <em>mybranch</em> 分支更新到最新的 <em>origin</em> 分支，最后把保存的这些补丁应用到 <em>mybranch</em> 分支上。<br>当 <em>mybranch</em> 分支更新之后，它会指向这些新创建的提交 <strong>(commit)</strong>, 而那些老的提交会被丢弃。 如果运行垃圾收集命令 <strong>(pruning garbage collection)</strong>, 这些被丢弃的提交就会删除。<br>在 <strong>rebase</strong> 的过程中，也许会出现冲突 <strong>(conflict)</strong>. 在这种情况，Git 会停止 rebase 并会让你去解决冲突；在解决完冲突后，用 <strong>git-add</strong> 命令去更新这些内容的索引 (index), 然后，你无需执行<strong>git-commit</strong> ,只要执行 <strong>continue</strong> 命令，这样 git 会继续应用 <strong>(apply)</strong> 余下的补丁：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase --<span class=\"keyword\">continue</span></span><br></pre></td></tr></table></figure>\n<p>任何时候，可以用<strong> –abort </strong>参数来终止 rebase 的行动，并且 <em>mybranch</em> 分支会回到 rebase 开始前的状态。<br><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase <span class=\"comment\">--abort</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-Git分区：\"><a href=\"#1-Git分区：\" class=\"headerlink\" title=\"1. Git分区：\"></a>1. Git分区：</h3><p> 工作区 (Working directory)：本地数据或者代码编辑区，数据或者代码操作区。<br>    暂存区 (Index cache)：数据或者代码暂时存放区。<br>    版本库 (Local repository)：存放已经提交的数据或者代码，此区数据或者代码直接push到远程仓库。<br>    分区之间数据传递流程图如下：</p>\n<h6 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"/2018/02/02/Git-常用命令/git_sections.png\" alt=\"\"></h6><h3 id=\"2-Git命令：\"><a href=\"#2-Git命令：\" class=\"headerlink\" title=\"2.  Git命令：\"></a>2.  Git命令：</h3><h4 id=\"1-基本操作\"><a href=\"#1-基本操作\" class=\"headerlink\" title=\"(1) 基本操作\"></a>(1) 基本操作</h4><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init                      <span class=\"comment\">//创建空仓库，当前目录下多出 .git 目录 </span></span><br><span class=\"line\"></span><br><span class=\"line\">git add &lt;<span class=\"keyword\">file</span>&gt;                <span class=\"comment\">//将文件添加到缓存 </span></span><br><span class=\"line\"></span><br><span class=\"line\">git status                    <span class=\"comment\">//查看在你上次提交之后是否有修改 </span></span><br><span class=\"line\"></span><br><span class=\"line\">git diff                      <span class=\"comment\">//查看尚未缓存的修改</span></span><br><span class=\"line\"></span><br><span class=\"line\">git diff --cached             <span class=\"comment\">//查看已经缓存的修改</span></span><br><span class=\"line\"></span><br><span class=\"line\">git diff HEAD                 <span class=\"comment\">//查看已缓存和未缓存的所有修改</span></span><br><span class=\"line\"></span><br><span class=\"line\">git diff --stat               <span class=\"comment\">//统计哪些文件发生了改变，有多少行产生了改动，并不会给出改动的具体内容</span></span><br><span class=\"line\"></span><br><span class=\"line\">git commit -<span class=\"keyword\">m</span><span class=\"string\">\"message\"</span>        <span class=\"comment\">//缓存区内容添加到仓库中</span></span><br><span class=\"line\"></span><br><span class=\"line\">git commit -a                 <span class=\"comment\">//跳过 git add 提交缓存，直接commit</span></span><br><span class=\"line\"></span><br><span class=\"line\">git reset HEAD  &lt;<span class=\"keyword\">file</span>&gt;        <span class=\"comment\">//取消之前 git add 添加，但不希望包含在下一提交快照中的缓存</span></span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">rm</span> &lt;<span class=\"keyword\">file</span>&gt;                 <span class=\"comment\">//从工作目录中手工删除文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">rm</span> -f &lt;<span class=\"keyword\">file</span>&gt;              <span class=\"comment\">//强制删除之前修改过并且已经放到暂存区域的文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">rm</span> --cached &lt;<span class=\"keyword\">file</span>&gt;        <span class=\"comment\">//把文件从暂存区域移除，但仍然保留在当前工作目录中</span></span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">rm</span> –r *                   <span class=\"comment\">//删除整个目录中的所有子目录和文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">git mv                        <span class=\"comment\">//移动或重命名一个文件、目录、软连接</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-分支管理\"><a href=\"#2-分支管理\" class=\"headerlink\" title=\"(2) 分支管理\"></a>(2) 分支管理</h4><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">git</span> <span class=\"keyword\">branch </span>(<span class=\"keyword\">branchname) </span>       //创建分支</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">git</span> checkout (<span class=\"keyword\">branchname) </span>     //切换分支</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">git</span> checkout -<span class=\"keyword\">b </span>(<span class=\"keyword\">branchname) </span>  //加上-<span class=\"keyword\">b参数表示创建并切换分支</span></span><br><span class=\"line\"><span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">git </span><span class=\"keyword\">branch </span>                    //列出所有分支，当前分支前面会标一个*号</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">git</span> merge  (<span class=\"keyword\">branchname) </span>       //合并指定分支(<span class=\"keyword\">branchname)到当前分支</span></span><br><span class=\"line\"><span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">git </span><span class=\"keyword\">branch </span>-d (<span class=\"keyword\">branchname) </span>    //删除分支</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-查看历史提交\"><a href=\"#3-查看历史提交\" class=\"headerlink\" title=\"(3) 查看历史提交\"></a>(3) 查看历史提交</h4><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log                         <span class=\"string\">//</span>查看提交历史</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--oneline</span>               <span class=\"string\">//</span>查看简洁的历史提交信息</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--graph</span>                 <span class=\"string\">//</span>查看分支合并图</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--reverse</span> <span class=\"params\">--oneline</span>     <span class=\"string\">//</span>逆向显示所有日志</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--author</span>                <span class=\"string\">//</span>查看指定用户的提交日志</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--oneline</span> <span class=\"params\">--before=</span>&#123;starttime&#125;  <span class=\"params\">--after=</span>&#123;endtime&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--oneline</span> <span class=\"params\">--until=</span>&#123;starttime&#125;  <span class=\"params\">--after=</span>&#123;endtime&#125;      <span class=\"string\">//</span>查看时间段的历史提交，后面加 <span class=\"params\">--no-merges</span> 选项以隐藏合并提交</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-添加标签\"><a href=\"#4-添加标签\" class=\"headerlink\" title=\"(4) 添加标签\"></a>(4) 添加标签</h4><figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"keyword\">tag</span> <span class=\"title\">-a</span> <span class=\"tag\">&lt;tagname&gt;</span>                   //-a 选项意为创建一个带注解的标签，不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解</span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">tag</span>                                <span class=\"title\">//查看所有标签</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br><span class=\"line\"><span class=\"title\">git</span> <span class=\"keyword\">tag</span> <span class=\"title\">-a</span> <span class=\"tag\">&lt;tagname&gt;</span> -m<span class=\"string\">\"标签信息\"</span>       //指定标签信息</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-Git-远程仓库\"><a href=\"#5-Git-远程仓库\" class=\"headerlink\" title=\"(5) Git 远程仓库\"></a>(5) Git 远程仓库</h4><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">git</span> <span class=\"selector-tag\">remote</span> <span class=\"selector-tag\">add</span> <span class=\"selector-attr\">[alias]</span> <span class=\"selector-attr\">[url]</span>      <span class=\"comment\">//添加一个新的远程仓库， alias为远程仓库别名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">git</span> <span class=\"selector-tag\">remote</span>                        <span class=\"comment\">//查看当前配置的远程仓库</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">git</span> <span class=\"selector-tag\">fetch</span>                         <span class=\"comment\">//从远程仓库下载新分支与数据，执行完后需要执行git merge 远程分支到你所在的分支</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">git</span> <span class=\"selector-tag\">push</span> <span class=\"selector-attr\">[alias]</span> <span class=\"selector-attr\">[branchname]</span>     <span class=\"comment\">//推送新分支与数据到某个远端仓库</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">git</span> <span class=\"selector-tag\">remote</span> <span class=\"selector-tag\">rm</span> <span class=\"selector-attr\">[alias]</span>             <span class=\"comment\">//删除远程仓库</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"6-Git-rebase\"><a href=\"#6-Git-rebase\" class=\"headerlink\" title=\"(6) Git rebase\"></a>(6) Git rebase</h4><p>假设现在基于远程分支 <em>origin</em> ，创建一个叫 <em>mybranch</em> 的分支，然后在这个分支做一些修改。然后生成若干个提交 <strong>(commit)</strong>，但是与此同时，有些人也在 <em>origin</em> 分支上做了一些修改并且做了提交了。<br>这就意味着 <em>origin</em> 和 <em>mybranch</em> 这两个分支各自&lt;前进&gt; 了，它们之间&lt;分叉&gt; 了。你可以用 <em>pull</em> 命令把 <em>origin</em> 分支上的修改拉下来并且和你的修改合并。<br>结果看起来就像一个新的 <em>合并的提交</em> <strong>(merge commit)</strong>。如果你想让 <em>mybranch</em> 分支历史看起来像没有经过任何合并一样，可以用 git rebase ：<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">git rebase origin</span></span><br></pre></td></tr></table></figure></p>\n<p>该命令会把你的 <em>mybranch</em> 分支里的每个提交 <strong>(commit)</strong> 取消掉，并且把它们临时保存为补丁 <strong>(patch)</strong> ( 这些补丁放到” .git/rebase “目录中 )。<br>然后把 <em>mybranch</em> 分支更新到最新的 <em>origin</em> 分支，最后把保存的这些补丁应用到 <em>mybranch</em> 分支上。<br>当 <em>mybranch</em> 分支更新之后，它会指向这些新创建的提交 <strong>(commit)</strong>, 而那些老的提交会被丢弃。 如果运行垃圾收集命令 <strong>(pruning garbage collection)</strong>, 这些被丢弃的提交就会删除。<br>在 <strong>rebase</strong> 的过程中，也许会出现冲突 <strong>(conflict)</strong>. 在这种情况，Git 会停止 rebase 并会让你去解决冲突；在解决完冲突后，用 <strong>git-add</strong> 命令去更新这些内容的索引 (index), 然后，你无需执行<strong>git-commit</strong> ,只要执行 <strong>continue</strong> 命令，这样 git 会继续应用 <strong>(apply)</strong> 余下的补丁：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase --<span class=\"keyword\">continue</span></span><br></pre></td></tr></table></figure>\n<p>任何时候，可以用<strong> –abort </strong>参数来终止 rebase 的行动，并且 <em>mybranch</em> 分支会回到 rebase 开始前的状态。<br><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase <span class=\"comment\">--abort</span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"Xcode-常用调试技巧","date":"2018-02-01T07:06:17.000Z","_content":"\n### 1. 普通断点调试\n   断点(Breakpoint)调试顾名思义，是当程序运行到断点处时会暂停运行。然后可以查看具体参数的值或者属性状态等。具体操作是点击代码左侧开启断点，再点一次将关闭断点，但断点还在。\n   快捷键为：command+\\。如图：\n   ![](iOS-调试技巧/breakpoint1.png)\n### 2. 条件断点调试\n   可以对普通断点的属性进行配置，设置条件，使调试更加方便达到目的。如下循环中：\n    ```\n  for i in 0..<10 {\n      print(i)\n  }\n    ```\n   如果要调试循环中的代码，每次都要单步执行，可能这并不是我想要的。我想要在一定条件的时候中断程序进行调试，可以如图添加Condition：\n   ![](iOS-调试技巧/breakpoint4.png)\n   可以设置Ignore参数，会忽略前面n次的断点，会在第n+1次中断：\n   ![](iOS-调试技巧/breakpoint5.png)\n   可以查看某个函数被调用的次数，设置Action参数,要选中\n   Automatically continue after evaluating actions。\n   ![](iOS-调试技巧/breakpoint6.png)\n### 3. 异常断点调试\n   有时候由于异常导致后程序crash了，代码就直接断到main函数中去了，这时候调试就比较麻烦。这种情况就可以用异常断点调试方法进行调试。如图添加异常断点：\n   ![](iOS-调试技巧/breakpoint7.png)\n### 4. 符号断点Symbolic Breakpoint调试\n   符号断点的创建也和异常断点一样。一般符号断点可以在你指定的[类名 方法名]时中断执行。\n   ![](iOS-调试技巧/breakpoint8.png)\n   如果Symbol只写了一个函数名，那么就会在出现该函数名的地方中断执行。\n   ![](iOS-调试技巧/breakpoint9.png)\n### 5. Analyze分析器\n   Analyze分析器是一种静态的工具，可以对我们的程序进行分析，找出我们未使用的变量，或一些死存储。执行Analyze如下：Product-->Analyze。快捷键为: Command+Ctrl+B\n   可以设置在编译程序的时候同时Analyze，把下列选项设为Yes即可。\n   ![](iOS-调试技巧/breakpoint16.png)\n### 6. 僵尸对象\n   iOS中把那些已经release但还没完全消失的对象叫做僵尸对象，对已经release的对象再次释放，就会发生异常。虽然自从使用ARC后，由于对象释放产生的异常已经大大变少，但偶尔还会出现。开启僵尸对象模式后，就能快速定位到异常位置。\n   开启方式如下：Product-->Scheme-->Edit Scheme. 勾选Zombie Objects即可。\n   ![](iOS-调试技巧/breakpoint11.png)\n### 7. lldb命令调试\n#### (1) print、po输出打印：\n   打印变量的值可以使用print（简写p）命令，该命令如果打印的是基础数据类型，则会列出基础数据类型的类型和值。如果是对象，还会打印出对象指针地址。print的打印信息较多，如果只想查看对象的值，则可以使用po（printobject）命令。\n   ![](iOS-调试技巧/breakpoint12.png)\n#### (2) call:\n   call调用方法的意思，call可以使用在没有返回值，不需要显示输出的情况下。比如可以这样用：\n   ```  \n  call self.view.backgroundColor = UIColor.purple\n   ```\n   这样就不用为了看改一下颜色的效果再进行build一次了，尤其是build一次还要经过漫长的等待。\n  \n#### (3) expression表达式(expr):\n   expr常用于调试时修改变量的值。比如：\n   ![](iOS-调试技巧/breakpoint13.png)\n#### (4) image:\n   image lookup --address寻址。比如：\n   ```\n   (lldb) image lookup --address 0x00000001097c396f\n   ```\n   image lookup --type查看类型.比如：\n   ```\n  (lldb) image lookup --type UIButton\n   ```\n   可以列出UIButton所有的属性。\n#### (5) bt:\n   我们可以用bt来打印调用堆栈，加all可打印多个thread的堆栈，如下：\n   ![](iOS-调试技巧/breakpoint14.png)\n### 8. 视图调试\n   当在调看UI布局或者在布局产生冲突的时候可以使用视图调试解决问题。进入APP出现问题的那个界面然后点击Xcode Debug View Hierarchy, 如图：\n   ![](iOS-调试技巧/breakpoint15.png)\n### 9. Log调试\n   可以使用别人的Log工具或者自定义Log，按照需求自行选择。","source":"_posts/iOS-调试技巧.md","raw":"---\ntitle: Xcode-常用调试技巧\ndate: 2018-02-01 15:06:17\ntags: Xcode\n---\n\n### 1. 普通断点调试\n   断点(Breakpoint)调试顾名思义，是当程序运行到断点处时会暂停运行。然后可以查看具体参数的值或者属性状态等。具体操作是点击代码左侧开启断点，再点一次将关闭断点，但断点还在。\n   快捷键为：command+\\。如图：\n   ![](iOS-调试技巧/breakpoint1.png)\n### 2. 条件断点调试\n   可以对普通断点的属性进行配置，设置条件，使调试更加方便达到目的。如下循环中：\n    ```\n  for i in 0..<10 {\n      print(i)\n  }\n    ```\n   如果要调试循环中的代码，每次都要单步执行，可能这并不是我想要的。我想要在一定条件的时候中断程序进行调试，可以如图添加Condition：\n   ![](iOS-调试技巧/breakpoint4.png)\n   可以设置Ignore参数，会忽略前面n次的断点，会在第n+1次中断：\n   ![](iOS-调试技巧/breakpoint5.png)\n   可以查看某个函数被调用的次数，设置Action参数,要选中\n   Automatically continue after evaluating actions。\n   ![](iOS-调试技巧/breakpoint6.png)\n### 3. 异常断点调试\n   有时候由于异常导致后程序crash了，代码就直接断到main函数中去了，这时候调试就比较麻烦。这种情况就可以用异常断点调试方法进行调试。如图添加异常断点：\n   ![](iOS-调试技巧/breakpoint7.png)\n### 4. 符号断点Symbolic Breakpoint调试\n   符号断点的创建也和异常断点一样。一般符号断点可以在你指定的[类名 方法名]时中断执行。\n   ![](iOS-调试技巧/breakpoint8.png)\n   如果Symbol只写了一个函数名，那么就会在出现该函数名的地方中断执行。\n   ![](iOS-调试技巧/breakpoint9.png)\n### 5. Analyze分析器\n   Analyze分析器是一种静态的工具，可以对我们的程序进行分析，找出我们未使用的变量，或一些死存储。执行Analyze如下：Product-->Analyze。快捷键为: Command+Ctrl+B\n   可以设置在编译程序的时候同时Analyze，把下列选项设为Yes即可。\n   ![](iOS-调试技巧/breakpoint16.png)\n### 6. 僵尸对象\n   iOS中把那些已经release但还没完全消失的对象叫做僵尸对象，对已经release的对象再次释放，就会发生异常。虽然自从使用ARC后，由于对象释放产生的异常已经大大变少，但偶尔还会出现。开启僵尸对象模式后，就能快速定位到异常位置。\n   开启方式如下：Product-->Scheme-->Edit Scheme. 勾选Zombie Objects即可。\n   ![](iOS-调试技巧/breakpoint11.png)\n### 7. lldb命令调试\n#### (1) print、po输出打印：\n   打印变量的值可以使用print（简写p）命令，该命令如果打印的是基础数据类型，则会列出基础数据类型的类型和值。如果是对象，还会打印出对象指针地址。print的打印信息较多，如果只想查看对象的值，则可以使用po（printobject）命令。\n   ![](iOS-调试技巧/breakpoint12.png)\n#### (2) call:\n   call调用方法的意思，call可以使用在没有返回值，不需要显示输出的情况下。比如可以这样用：\n   ```  \n  call self.view.backgroundColor = UIColor.purple\n   ```\n   这样就不用为了看改一下颜色的效果再进行build一次了，尤其是build一次还要经过漫长的等待。\n  \n#### (3) expression表达式(expr):\n   expr常用于调试时修改变量的值。比如：\n   ![](iOS-调试技巧/breakpoint13.png)\n#### (4) image:\n   image lookup --address寻址。比如：\n   ```\n   (lldb) image lookup --address 0x00000001097c396f\n   ```\n   image lookup --type查看类型.比如：\n   ```\n  (lldb) image lookup --type UIButton\n   ```\n   可以列出UIButton所有的属性。\n#### (5) bt:\n   我们可以用bt来打印调用堆栈，加all可打印多个thread的堆栈，如下：\n   ![](iOS-调试技巧/breakpoint14.png)\n### 8. 视图调试\n   当在调看UI布局或者在布局产生冲突的时候可以使用视图调试解决问题。进入APP出现问题的那个界面然后点击Xcode Debug View Hierarchy, 如图：\n   ![](iOS-调试技巧/breakpoint15.png)\n### 9. Log调试\n   可以使用别人的Log工具或者自定义Log，按照需求自行选择。","slug":"iOS-调试技巧","published":1,"updated":"2019-05-31T09:31:27.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx2nwtyp0007u78ez2spta9o","content":"<h3 id=\"1-普通断点调试\"><a href=\"#1-普通断点调试\" class=\"headerlink\" title=\"1. 普通断点调试\"></a>1. 普通断点调试</h3><p>   断点(Breakpoint)调试顾名思义，是当程序运行到断点处时会暂停运行。然后可以查看具体参数的值或者属性状态等。具体操作是点击代码左侧开启断点，再点一次将关闭断点，但断点还在。<br>   快捷键为：command+\\。如图：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint1.png\" alt=\"\"></p>\n<h3 id=\"2-条件断点调试\"><a href=\"#2-条件断点调试\" class=\"headerlink\" title=\"2. 条件断点调试\"></a>2. 条件断点调试</h3><p>   可以对普通断点的属性进行配置，设置条件，使调试更加方便达到目的。如下循环中：<br>    <figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> 0<span class=\"built_in\">..</span>&lt;10 &#123;</span><br><span class=\"line\">    <span class=\"builtin-name\">print</span>(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>   如果要调试循环中的代码，每次都要单步执行，可能这并不是我想要的。我想要在一定条件的时候中断程序进行调试，可以如图添加Condition：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint4.png\" alt=\"\"><br>   可以设置Ignore参数，会忽略前面n次的断点，会在第n+1次中断：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint5.png\" alt=\"\"><br>   可以查看某个函数被调用的次数，设置Action参数,要选中<br>   Automatically continue after evaluating actions。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint6.png\" alt=\"\"></p>\n<h3 id=\"3-异常断点调试\"><a href=\"#3-异常断点调试\" class=\"headerlink\" title=\"3. 异常断点调试\"></a>3. 异常断点调试</h3><p>   有时候由于异常导致后程序crash了，代码就直接断到main函数中去了，这时候调试就比较麻烦。这种情况就可以用异常断点调试方法进行调试。如图添加异常断点：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint7.png\" alt=\"\"></p>\n<h3 id=\"4-符号断点Symbolic-Breakpoint调试\"><a href=\"#4-符号断点Symbolic-Breakpoint调试\" class=\"headerlink\" title=\"4. 符号断点Symbolic Breakpoint调试\"></a>4. 符号断点Symbolic Breakpoint调试</h3><p>   符号断点的创建也和异常断点一样。一般符号断点可以在你指定的[类名 方法名]时中断执行。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint8.png\" alt=\"\"><br>   如果Symbol只写了一个函数名，那么就会在出现该函数名的地方中断执行。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint9.png\" alt=\"\"></p>\n<h3 id=\"5-Analyze分析器\"><a href=\"#5-Analyze分析器\" class=\"headerlink\" title=\"5. Analyze分析器\"></a>5. Analyze分析器</h3><p>   Analyze分析器是一种静态的工具，可以对我们的程序进行分析，找出我们未使用的变量，或一些死存储。执行Analyze如下：Product–&gt;Analyze。快捷键为: Command+Ctrl+B<br>   可以设置在编译程序的时候同时Analyze，把下列选项设为Yes即可。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint16.png\" alt=\"\"></p>\n<h3 id=\"6-僵尸对象\"><a href=\"#6-僵尸对象\" class=\"headerlink\" title=\"6. 僵尸对象\"></a>6. 僵尸对象</h3><p>   iOS中把那些已经release但还没完全消失的对象叫做僵尸对象，对已经release的对象再次释放，就会发生异常。虽然自从使用ARC后，由于对象释放产生的异常已经大大变少，但偶尔还会出现。开启僵尸对象模式后，就能快速定位到异常位置。<br>   开启方式如下：Product–&gt;Scheme–&gt;Edit Scheme. 勾选Zombie Objects即可。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint11.png\" alt=\"\"></p>\n<h3 id=\"7-lldb命令调试\"><a href=\"#7-lldb命令调试\" class=\"headerlink\" title=\"7. lldb命令调试\"></a>7. lldb命令调试</h3><h4 id=\"1-print、po输出打印：\"><a href=\"#1-print、po输出打印：\" class=\"headerlink\" title=\"(1) print、po输出打印：\"></a>(1) print、po输出打印：</h4><p>   打印变量的值可以使用print（简写p）命令，该命令如果打印的是基础数据类型，则会列出基础数据类型的类型和值。如果是对象，还会打印出对象指针地址。print的打印信息较多，如果只想查看对象的值，则可以使用po（printobject）命令。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint12.png\" alt=\"\"></p>\n<h4 id=\"2-call\"><a href=\"#2-call\" class=\"headerlink\" title=\"(2) call:\"></a>(2) call:</h4><p>   call调用方法的意思，call可以使用在没有返回值，不需要显示输出的情况下。比如可以这样用：<br>   <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call self<span class=\"selector-class\">.view</span><span class=\"selector-class\">.backgroundColor</span> = UIColor.purple</span><br></pre></td></tr></table></figure></p>\n<p>   这样就不用为了看改一下颜色的效果再进行build一次了，尤其是build一次还要经过漫长的等待。</p>\n<h4 id=\"3-expression表达式-expr\"><a href=\"#3-expression表达式-expr\" class=\"headerlink\" title=\"(3) expression表达式(expr):\"></a>(3) expression表达式(expr):</h4><p>   expr常用于调试时修改变量的值。比如：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint13.png\" alt=\"\"></p>\n<h4 id=\"4-image\"><a href=\"#4-image\" class=\"headerlink\" title=\"(4) image:\"></a>(4) image:</h4><p>   image lookup –address寻址。比如：<br>   <figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) image <span class=\"built_in\">lookup</span> --<span class=\"built_in\">address</span> <span class=\"number\">0</span>x00000001097c396f</span><br></pre></td></tr></table></figure></p>\n<p>   image lookup –type查看类型.比如：<br>   <figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) image <span class=\"built_in\">lookup</span> --<span class=\"built_in\">type</span> UIButton</span><br></pre></td></tr></table></figure></p>\n<p>   可以列出UIButton所有的属性。</p>\n<h4 id=\"5-bt\"><a href=\"#5-bt\" class=\"headerlink\" title=\"(5) bt:\"></a>(5) bt:</h4><p>   我们可以用bt来打印调用堆栈，加all可打印多个thread的堆栈，如下：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint14.png\" alt=\"\"></p>\n<h3 id=\"8-视图调试\"><a href=\"#8-视图调试\" class=\"headerlink\" title=\"8. 视图调试\"></a>8. 视图调试</h3><p>   当在调看UI布局或者在布局产生冲突的时候可以使用视图调试解决问题。进入APP出现问题的那个界面然后点击Xcode Debug View Hierarchy, 如图：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint15.png\" alt=\"\"></p>\n<h3 id=\"9-Log调试\"><a href=\"#9-Log调试\" class=\"headerlink\" title=\"9. Log调试\"></a>9. Log调试</h3><p>   可以使用别人的Log工具或者自定义Log，按照需求自行选择。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-普通断点调试\"><a href=\"#1-普通断点调试\" class=\"headerlink\" title=\"1. 普通断点调试\"></a>1. 普通断点调试</h3><p>   断点(Breakpoint)调试顾名思义，是当程序运行到断点处时会暂停运行。然后可以查看具体参数的值或者属性状态等。具体操作是点击代码左侧开启断点，再点一次将关闭断点，但断点还在。<br>   快捷键为：command+\\。如图：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint1.png\" alt=\"\"></p>\n<h3 id=\"2-条件断点调试\"><a href=\"#2-条件断点调试\" class=\"headerlink\" title=\"2. 条件断点调试\"></a>2. 条件断点调试</h3><p>   可以对普通断点的属性进行配置，设置条件，使调试更加方便达到目的。如下循环中：<br>    <figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> 0<span class=\"built_in\">..</span>&lt;10 &#123;</span><br><span class=\"line\">    <span class=\"builtin-name\">print</span>(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>   如果要调试循环中的代码，每次都要单步执行，可能这并不是我想要的。我想要在一定条件的时候中断程序进行调试，可以如图添加Condition：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint4.png\" alt=\"\"><br>   可以设置Ignore参数，会忽略前面n次的断点，会在第n+1次中断：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint5.png\" alt=\"\"><br>   可以查看某个函数被调用的次数，设置Action参数,要选中<br>   Automatically continue after evaluating actions。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint6.png\" alt=\"\"></p>\n<h3 id=\"3-异常断点调试\"><a href=\"#3-异常断点调试\" class=\"headerlink\" title=\"3. 异常断点调试\"></a>3. 异常断点调试</h3><p>   有时候由于异常导致后程序crash了，代码就直接断到main函数中去了，这时候调试就比较麻烦。这种情况就可以用异常断点调试方法进行调试。如图添加异常断点：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint7.png\" alt=\"\"></p>\n<h3 id=\"4-符号断点Symbolic-Breakpoint调试\"><a href=\"#4-符号断点Symbolic-Breakpoint调试\" class=\"headerlink\" title=\"4. 符号断点Symbolic Breakpoint调试\"></a>4. 符号断点Symbolic Breakpoint调试</h3><p>   符号断点的创建也和异常断点一样。一般符号断点可以在你指定的[类名 方法名]时中断执行。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint8.png\" alt=\"\"><br>   如果Symbol只写了一个函数名，那么就会在出现该函数名的地方中断执行。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint9.png\" alt=\"\"></p>\n<h3 id=\"5-Analyze分析器\"><a href=\"#5-Analyze分析器\" class=\"headerlink\" title=\"5. Analyze分析器\"></a>5. Analyze分析器</h3><p>   Analyze分析器是一种静态的工具，可以对我们的程序进行分析，找出我们未使用的变量，或一些死存储。执行Analyze如下：Product–&gt;Analyze。快捷键为: Command+Ctrl+B<br>   可以设置在编译程序的时候同时Analyze，把下列选项设为Yes即可。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint16.png\" alt=\"\"></p>\n<h3 id=\"6-僵尸对象\"><a href=\"#6-僵尸对象\" class=\"headerlink\" title=\"6. 僵尸对象\"></a>6. 僵尸对象</h3><p>   iOS中把那些已经release但还没完全消失的对象叫做僵尸对象，对已经release的对象再次释放，就会发生异常。虽然自从使用ARC后，由于对象释放产生的异常已经大大变少，但偶尔还会出现。开启僵尸对象模式后，就能快速定位到异常位置。<br>   开启方式如下：Product–&gt;Scheme–&gt;Edit Scheme. 勾选Zombie Objects即可。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint11.png\" alt=\"\"></p>\n<h3 id=\"7-lldb命令调试\"><a href=\"#7-lldb命令调试\" class=\"headerlink\" title=\"7. lldb命令调试\"></a>7. lldb命令调试</h3><h4 id=\"1-print、po输出打印：\"><a href=\"#1-print、po输出打印：\" class=\"headerlink\" title=\"(1) print、po输出打印：\"></a>(1) print、po输出打印：</h4><p>   打印变量的值可以使用print（简写p）命令，该命令如果打印的是基础数据类型，则会列出基础数据类型的类型和值。如果是对象，还会打印出对象指针地址。print的打印信息较多，如果只想查看对象的值，则可以使用po（printobject）命令。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint12.png\" alt=\"\"></p>\n<h4 id=\"2-call\"><a href=\"#2-call\" class=\"headerlink\" title=\"(2) call:\"></a>(2) call:</h4><p>   call调用方法的意思，call可以使用在没有返回值，不需要显示输出的情况下。比如可以这样用：<br>   <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call self<span class=\"selector-class\">.view</span><span class=\"selector-class\">.backgroundColor</span> = UIColor.purple</span><br></pre></td></tr></table></figure></p>\n<p>   这样就不用为了看改一下颜色的效果再进行build一次了，尤其是build一次还要经过漫长的等待。</p>\n<h4 id=\"3-expression表达式-expr\"><a href=\"#3-expression表达式-expr\" class=\"headerlink\" title=\"(3) expression表达式(expr):\"></a>(3) expression表达式(expr):</h4><p>   expr常用于调试时修改变量的值。比如：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint13.png\" alt=\"\"></p>\n<h4 id=\"4-image\"><a href=\"#4-image\" class=\"headerlink\" title=\"(4) image:\"></a>(4) image:</h4><p>   image lookup –address寻址。比如：<br>   <figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) image <span class=\"built_in\">lookup</span> --<span class=\"built_in\">address</span> <span class=\"number\">0</span>x00000001097c396f</span><br></pre></td></tr></table></figure></p>\n<p>   image lookup –type查看类型.比如：<br>   <figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) image <span class=\"built_in\">lookup</span> --<span class=\"built_in\">type</span> UIButton</span><br></pre></td></tr></table></figure></p>\n<p>   可以列出UIButton所有的属性。</p>\n<h4 id=\"5-bt\"><a href=\"#5-bt\" class=\"headerlink\" title=\"(5) bt:\"></a>(5) bt:</h4><p>   我们可以用bt来打印调用堆栈，加all可打印多个thread的堆栈，如下：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint14.png\" alt=\"\"></p>\n<h3 id=\"8-视图调试\"><a href=\"#8-视图调试\" class=\"headerlink\" title=\"8. 视图调试\"></a>8. 视图调试</h3><p>   当在调看UI布局或者在布局产生冲突的时候可以使用视图调试解决问题。进入APP出现问题的那个界面然后点击Xcode Debug View Hierarchy, 如图：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint15.png\" alt=\"\"></p>\n<h3 id=\"9-Log调试\"><a href=\"#9-Log调试\" class=\"headerlink\" title=\"9. Log调试\"></a>9. Log调试</h3><p>   可以使用别人的Log工具或者自定义Log，按照需求自行选择。</p>\n"},{"title":"iOS-Runtime","date":"2019-05-30T02:25:47.000Z","_content":"\nRuntime 总结相关示例代码：[https://github.com/terryfine/BlogDemo/tree/master/RuntimDemo](https://github.com/terryfine/BlogDemo/tree/master/RuntimDemo)\n## Objc Runtime\n  源代码下载地址：[http://www.opensource.apple.com/source/objc4/](http://www.opensource.apple.com/source/objc4/)\n\n  Runtime 函数文档: [https://developer.apple.com/documentation/objectivec/objective-c_runtime](https://developer.apple.com/documentation/objectivec/objective-c_runtime)\n\n  苹果官方 Runtime 编程指南：\n  [https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048)\n\n### 1. 概念\n Objective-C 是一门动态语言，它将很多静态语言在编译和链接时做的事情推迟到运行时来处理。\n\n 这种动态特性意味着 Objective-C 不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。\n 对于 Objective-C 来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。\n\n Runtime 就是使用 C 和汇编写的一个运行时库，一般我们说 Runtime，不但包含运行时库的意思，还包含了运行时、运行时系统等概念。\n\n**Objc Runtime 使得 C 具有了面向对象能力，可以在程序运行时创建、检查、修改类、对象和它们的方法**。\n\n### 2. Runtime 的作用：\n#### (1) 封装\n Runtime 库中，对象可以用 C 语言中的结构体表示，而方法可以用 C 函数来实现，再加上了一些其他的特性。这些结构体和函数被 runtime 函数封装后，就可以在程序运行时创建、检查、修改类、对象和它们的方法了。\n### (2) 找到方法的最终执行代码\n 当程序中执行 [receiver message] 时，会向消息接收者（receiver）发送一条消息 message，runtime 会根据消息接收者是否能响应该消息而做出不同的反应，即消息转发的流程。\n### 3. 类和对象（Class 和 Object）相关的基本数据结构\n#### (1) 关键词：\n Class：指向了 objc_class 结构体的指针 \n\tid：参数类型，指向某个类实例的指针 \n\tMethod：代表了类中的某个方法的类型\n\tSEL：方法选择器，全名是 selector\n\tIMP：函数指针，由编译器生成，方法实现的代码就是由 IMP 指定\n\tIvar：成员变量的类型\n\tProperty：属性存储器\n\tCache：方法调用的缓存器，为方法调用的性能进行优化\n\n#### (2) objc_class 和 objc_object 数据结构：\n```\ntypedef struct objc_class *Class;\ntypedef struct objc_object *id;\n```\n#### (3) objc_object 和 isa\nobjc_object 源代码在 objc-private.h line 75, 关键代码如下：\n```\nstruct objc_object {\nprivate:\n    isa_t isa;\n\npublic:\n\n    // ISA() assumes this is NOT a tagged pointer object\n    Class ISA();\n\n    // getIsa() allows this to be a tagged pointer object\n    Class getIsa();\n}\n```\nobjc_object 中的 isa，对应类型为联合体 isa_t，源代码在 objc-private.h line 61, 关键代码定义如下：\n```\nstruct {\n    uintptr_t nonpointer        : 1;                                         \\         //0:普通指针，1:优化过，使用位域存储更多信息\n    uintptr_t has_assoc         : 1;                                         \\         //对象是否含有或曾经含有关联引用\n    uintptr_t has_cxx_dtor      : 1;                                         \\         //表示是否有 C++ 析构函数或OC的 dealloc\n    uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\         //存放着 Class、Meta-Class 对象的内存地址信息\n    uintptr_t magic             : 6;                                         \\         //用于在调试时分辨对象是否未完成初始化\n    uintptr_t weakly_referenced : 1;                                         \\         //是否被弱引用指向\n    uintptr_t deallocating      : 1;                                         \\         //对象是否正在释放\n    uintptr_t has_sidetable_rc  : 1;                                         \\         //是否需要使用 sidetable 来存储引用计数\n    uintptr_t extra_rc          : 8                                                    //引用计数能够用 8 个二进制位存储时，直接存储在这里\n}\n```\n#### (4) objc_class\nobjc_class 源代码可在 objc-runtime-new.h line 1111 看到，由于 objc_class 继承自 objc_object， 所以其关键结构可简化如下:\n```\nstruct objc_class : objc_object {\n    isa_t isa;                 // Class ISA;\n    Class superclass;\n    cache_t cache;             // formerly cache pointer and vtable\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n\n    class_rw_t *data() { \n        return bits.data();\n    }\n}\n```\nobjc_object 用来描述 OC 中的实例，当用口语描述实例时，总会说 「XX类的实例x」或「x是XX的实例」。objc_object 的 isa 在程序结构上表达类似的含义，它指向了该实例所对应的类，类在 runtime 中被描述成 objc_class 结构。\nObjective-C 中的类本质上也是对象，称之为类对象，在 Objective-C 中有一个非常特殊的类 NSObject ，绝大部分的类都继承自它。它是 Objective-C 中的两个根类（rootclass）之一，另外一个是 NSProxy。\nNSObject 只有一个成员变量 isa。所有继承自 NSObject 的类也都会有这个成员变量。\n\n#### (5) 元类（metaclass）、根类（root class）、根元类（root metaclass）\n本质上 Objective-C 中的类也是对象，它也是某个类的实例，这个类我们称之为元类（metaclass）。元类也是对象（元类对象），元类也是某个类的实例，这个类我们称之为根元类（root metaclass）。\n不过，有一点比较特殊，那就是所有的元类所属的类都是同一个根元类（当然根元类也是元类，所以它所属的类也是根元类，即它本身）。根元类指的就是根类的元类，具体来说就是根类 NSObject 对应的元类。\n\n通过调用类方法，比如 [NSObject new]，给类对象发送消息。同样的，类对象能否响应这个消息也要通过 isa 找到类对象所属的类（元类）才能知道。也就是说，实例方法是保存在类中的，而类方法是保存在元类中的。理论上我们也可以给元类发送消息，但是 Objective-C 倾向于隐藏元类，不想让大家知道元类的存在。元类是为了保持 Objective-C 对象模型在设计上的完整性而引入的，比如用来保存类方法等，它主要是用来给编译器使用的。\n\n下图是为类（class），元类（metaclass），根类（root class），根元类（root metaclass）关系\n![](iOS-Runtime/object_model.png)\n#### (6) superclass\n指向该类的父类，如果该类已经是最顶层的根类（如 NSObject 或 NSProxy），则 superclass 为 NULL。\n#### (7) cache_t\ncache_t 是一个散列表，用来缓存曾经调用过的方法，提高方法的查找速度。\n源代码可在 objc-runtime-new.h line 59 找到，其关键结构如下:\n```\nstruct cache_t {\n    struct bucket_t *_buckets;     // 散列表\n    mask_t _mask;                  // 散列表的长度 -1\n    mask_t _occupied;              // 已经缓存的方法数量\n}\n\nstruct bucket_t {\n    cache_key_t _key;              // SEL 作为 key\n    MethodCacheIMP _imp;           // 函数的内存地址\n};\n```\n**buckets：**指向 Method 数据结构指针的数组。这个数组可能包含不超过 mask+1 个元素。需要注意的是，指针可能是 NULL，表示这个缓存 bucket 没有被占用，另外被占用的 bucket 可能是不连续的。这个数组可能会随着时间而增长。\n\n**mask：**一个整数，指定分配的缓存 bucket 的总数。在方法查找过程中，Objective-C runtime 使用这个字段来确定开始线性查找数组的索引未知。指向方法 selector 的指针与该字段做一个 AND 位操作（index = (mask & selector)）。这可以作为一个简单的 hash 散列算法。\n\n**occupied：**一个整数，指定实际占用的缓存 bucket 的总数。\n\n#### (8) class_data_bits_t\nclass_data_bits_t 是一个结构体，里面包含了一个 class_rw_t 类型的指针 data。class_rw_t 内部有个 class_ro_t 的指针 ro。class_rw_t 是可读可写的，class_ro_t 是只读的。 class_data_bits_t 源代码可以在 objc-runtime-new.h line 870 看到。\n\n**class_rw_t** 结构如下：\n```\nstruct class_rw_t {\n    // Be warned that Symbolication knows the layout of this structure.\n    uint32_t flags;\n    uint32_t version;\n\n    const class_ro_t *ro;             // 保存类的原始数据(不包含分类内容和动态添加的方法)\n    method_array_t methods;           // 方法列表(如果是类对象存储的是对象方法,元类对象存储的是类方法)\n    property_array_t properties;      // 属性列表\n    protocol_array_t protocols;       // 协议列表\n    Class firstSubclass;              // 第一个子类\n    Class nextSiblingClass;           // 兄弟类\n}\n\n```\n\n**class_ro_t** 储存了类的初始信息，不包括分类和后来动态添加的内容。class_ro_t 关键代码如下：\n```\nstruct class_ro_t {\n    uint32_t flags;\n    uint32_t instanceStart;\n    uint32_t instanceSize;\n#ifdef __LP64__\n    uint32_t reserved;\n#endif\n\n    const uint8_t * ivarLayout;\n    \n    const char * name;                    // 类名\n    method_list_t * baseMethodList;       // 原始方法列表\n    protocol_list_t * baseProtocols;      // 原始协议列表\n    const ivar_list_t * ivars;            // 成员变量列表\n\n    const uint8_t * weakIvarLayout;\n    property_list_t *baseProperties;      // 属性列表\n\n    method_list_t *baseMethods() const {\n        return baseMethodList;\n    }\n}\n\n```\n**method_list_t** 数组包含了多个 method_t，其中 method_t 也是结构体 ，其关键结构如下：\n```\nstruct method_t {\n    SEL name;               // 函数名\n    const char *types;      // 方法参数 (包含了返回值类型,参数类型)\n    MethodListIMP imp;      // 方法的实现 (指向函数的指针)\n}\n```\n**ivar_list_t** 数组包含了多个 ivar_t 类型的结构体 ivar，ivar_t 结构如下：\n\n```\nstruct ivar_t {\n    int32_t *offset;               // 变量在内存中相对所属对象内存空间起始地址的偏移量,偏移量大小根据类型来定\n    const char *name;              // 变量名\n    const char *type;              // 变量类型\n    // alignment is sometimes -1; use alignment() instead\n    uint32_t alignment_raw;\n    uint32_t size;\n\n    uint32_t alignment() const {\n        if (alignment_raw == ~(uint32_t)0) return 1U << WORD_SHIFT;\n        return 1 << alignment_raw;\n    }\n}\n```\n**property_list_t** 数组包含多个 property_t，property_t 结构如下：\n```\nstruct property_t {\n    const char *name;             \n    const char *attributes;        \n}\n```\n\nclass_ro_t 包含的类信息（方法、属性、协议等）都是在编译期就可以确定的，暂且称为元信息吧，在之后的逻辑中，它们显然是不希望被改变的；后续在用户层，无论是方法还是别的扩展，都是在 class_rw_t 上进行操作，这些操作都不会影响类的元信息。更多关于 class_rw_t 和 class_ro_t 的资料可查看 [这篇文章](https://zhangbuhuai.com/post/runtime.html)。\n\n### 4. 类和对象相关操作方法\n操作类相关的函数一般以 class 为前缀，操作对象相关函数以 objc 或 object_ 为前缀。可在开篇 Runtime 函数文档查看相关方法。\n\n#### (1) 类相关操作函数\t\n```\n\tconst char * class_getName ( Class cls )           // 获取类名\n\n\tClass class_getSuperclass ( Class cls )            // 获取父类\n\n\tBOOL class_isMetaClass ( Class cls )               // 判断给定的类是不是元类\n\n\tsize_t class_getInstanceSize ( Class cls )         // 获取类的实例大小\n\n\tint class_getVersion ( Class cls )                 // 获取版本号\n\n\tvoid class_setVersion ( Class cls, int version )   // 设置版本号\n\n\n```\n\n#### (2) 成员变量 (ivars) 和属性相关操作函数\n```\n\tIvar class_getInstanceVariable ( Class cls, const char *name )                                           // 获取类中指定名称实例成员变量的信息\n\n\tIvar class_getClassVariable ( Class cls, const char *name )                                              // 获取类成员变量的信息\n\n\tBOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types )    // 在 runtime 时创建的类添加成员变量\n\n\tIvar * class_copyIvarList ( Class cls, unsigned int *outCount )                                          // 获取整个成员变量列表，必须使用 free() 来释放\n\n\n```\n#### (3) method 相关操作函数\n```\n\tBOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types )       // 添加方法，和成员变量不同的是可以为类动态添加方法。如果有同名会返回 NO，修改的话需要使用 method_setImplementation\n\n\tMethod class_getInstanceMethod ( Class cls, SEL name )                         // 获取实例方法\n\n\tMethod class_getClassMethod ( Class cls, SEL name )                            // 获取类方法\n\n\tMethod * class_copyMethodList ( Class cls, unsigned int *outCount )            // 获取所有方法\n\n\tIMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types )    // 实现替换方法\n\n\tIMP class_getMethodImplementation ( Class cls, SEL name )                      // 返回方法的具体实现\n\n\tIMP class_getMethodImplementation_stret ( Class cls, SEL name )                // 返回方法的具体实现\n\n\tBOOL class_respondsToSelector ( Class cls, SEL sel )                           // 类实例是否响应指定的 selector\n\n\n\n```\n#### (4) protocol 相关操作函数\n```\n\tBOOL class_addProtocol ( Class cls, Protocol *protocol )                       // 添加协议\n\n\tBOOL class_conformsToProtocol ( Class cls, Protocol *protocol )                // 返回类是否实现指定的协议\n\n\tProtocol * class_copyProtocolList ( Class cls, unsigned int *outCount )        // 获取类实现的协议列表\n\n\n```\n\n#### (5) 相关示例代码及输出：\n```\n RuntimClass *runtimeClass = [[RuntimClass alloc] init];\n Class cls = runtimeClass.class;\n\n // 类名\n const char *clsName = class_getName(cls);\n NSLog(@\"类名：%s\", clsName);\n NSLog(@\"**********************************\");\n \n // 父类\n Class superCls = class_getSuperclass(cls);\n NSLog(@\"父类名：%s\", class_getName(superCls));\n NSLog(@\"**********************************\");\n \n // 元类\n BOOL isMetaCls = class_isMetaClass(cls);\n NSLog(@\"%s %@元类\", clsName, (isMetaCls ? @\"是\" : @\"不是\"));\n NSLog(@\"**********************************\");\n \n Class metaCls = objc_getMetaClass(class_getName(cls));\n NSLog(@\"%s的元类是：%s\", clsName, class_getName(metaCls));\n NSLog(@\"**********************************\");\n \n // 变量实例大小\n size_t instanceSize = class_getInstanceSize(cls);\n NSLog(@\"%s的所有实例变量大小：%zu\",clsName ,instanceSize);\n NSLog(@\"**********************************\");\n \n // 成员变量\n unsigned int outCount = 0;\n Ivar *ivars = class_copyIvarList(cls, &outCount);\n for (int i = 0; i < outCount; i++) {\n     Ivar ivar = ivars[i];\n     NSLog(@\"成员变量%s在第%d的位置\", ivar_getName(ivar), i);\n     NSLog(@\"**********************************\");\n }\n free(ivars);\n \n Ivar ivar = class_getInstanceVariable(cls, \"_array\");\n if (ivar != NULL) {\n     const char *ivarName = ivar_getName(ivar);\n     NSLog(@\"成员变量：%s\", ivarName);\n     NSLog(@\"**********************************\");\n } else {\n     NSLog(@\"没有此成员变量\");\n     NSLog(@\"**********************************\");\n }\n \n // 属性\n objc_property_t *properties = class_copyPropertyList(cls, &outCount);\n for (int i = 0; i < outCount; i++) {\n     objc_property_t property = properties[i];\n     NSLog(@\"属性名称: %s\", property_getName(property));\n     NSLog(@\"**********************************\");\n }\n free(properties);\n \n objc_property_t arrayProperty = class_getProperty(cls, \"array\");\n if (arrayProperty != NULL) {\n     const char *arryPropertyName = property_getName(arrayProperty);\n     NSLog(@\"属性%s\", arryPropertyName);\n     NSLog(@\"**********************************\");\n }\n \n //方法\n Method *methods = class_copyMethodList(cls, &outCount);   //包含category添加的方法\n for (int i = 0; i < outCount; i++) {\n     Method method = methods[i];\n     SEL methodSignature = method_getName(method);\n     NSLog(@\"方法签名: %s\", methodSignature);\n     NSLog(@\"**********************************\");\n }\n free(methods);\n \n Method method1 = class_getInstanceMethod(cls, @selector(method2));\n if (method1 != NULL) {\n     SEL method1Signature = method_getName(method1);\n     NSLog(@\"方法%s\",method1Signature);\n     NSLog(@\"**********************************\");\n } else {\n     NSLog(@\"未找到此方法\");\n     NSLog(@\"**********************************\");\n }\n \n Method classMethod = class_getClassMethod(cls, @selector(classMethod));\n if (classMethod != NULL) {\n     SEL classMethodName = method_getName(classMethod);\n     NSLog(@\"类方法 %s\", classMethodName);\n     NSLog(@\"**********************************\");\n }\n \n BOOL responds = class_respondsToSelector(cls, @selector(method4WithArg1:arg2:));\n if (responds) {\n     Method respondsMethod = class_getInstanceMethod(cls, @selector(method4WithArg1:arg2:));\n     SEL respondsMethodName = method_getName(respondsMethod);\n     NSLog(@\"%s响应方法%s\", clsName, respondsMethodName);\n     NSLog(@\"**********************************\");\n } else {\n     NSLog(@\"%s不响应此方法\", clsName);\n     NSLog(@\"**********************************\");\n }\n \n IMP imp = class_getMethodImplementation(cls, @selector(method1));\n imp();\n NSLog(@\"**********************************\");\n \n // 协议\n Protocol __unsafe_unretained **protocols = class_copyProtocolList(cls, &outCount);\n for (int i = 0; i < outCount; i++) {\n     Protocol * protocol = protocols[i];\n     const char *protocalName = protocol_getName(protocol);\n     NSLog(@\"协议名称：%s\", protocalName);\n     NSLog(@\"**********************************\");\n }\n Protocol * protocol = protocols[1];\n BOOL conformProtocol = class_conformsToProtocol(cls, protocol);\n NSLog(@\"%s%@遵循协议%s\", clsName, (conformProtocol ? @\"\" : @\"不\"), protocol_getName(protocol));\n NSLog(@\"**********************************\");\n\n输出日志如下：\n\n2019-06-15 18:26:12.595856+0800 RuntimDemo[18732:16102829] 类名：RuntimClass\n2019-06-15 18:26:12.596386+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.596500+0800 RuntimDemo[18732:16102829] 父类名：NSObject\n2019-06-15 18:26:12.596584+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.596721+0800 RuntimDemo[18732:16102829] RuntimClass 不是元类\n2019-06-15 18:26:12.596798+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.596890+0800 RuntimDemo[18732:16102829] RuntimClass的元类是：RuntimClass\n2019-06-15 18:26:12.596966+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.597060+0800 RuntimDemo[18732:16102829] RuntimClass的所有实例变量大小：56\n2019-06-15 18:26:12.597136+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.597251+0800 RuntimDemo[18732:16102829] 成员变量firstInstance在第0的位置\n2019-06-15 18:26:12.597429+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.597622+0800 RuntimDemo[18732:16102829] 成员变量secondInstance在第1的位置\n2019-06-15 18:26:12.597803+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.601663+0800 RuntimDemo[18732:16102829] 成员变量thirdInstance在第2的位置\n2019-06-15 18:26:12.601739+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.601823+0800 RuntimDemo[18732:16102829] 成员变量_array在第3的位置\n2019-06-15 18:26:12.601888+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.601965+0800 RuntimDemo[18732:16102829] 成员变量_string在第4的位置\n2019-06-15 18:26:12.602033+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.602106+0800 RuntimDemo[18732:16102829] 成员变量_index在第5的位置\n2019-06-15 18:26:12.602168+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.602479+0800 RuntimDemo[18732:16102829] 成员变量：_array\n2019-06-15 18:26:12.602681+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.602908+0800 RuntimDemo[18732:16102829] 属性名称: array\n2019-06-15 18:26:12.603056+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.603266+0800 RuntimDemo[18732:16102829] 属性名称: string\n2019-06-15 18:26:12.603464+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.603662+0800 RuntimDemo[18732:16102829] 属性名称: index\n2019-06-15 18:26:12.603887+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.604116+0800 RuntimDemo[18732:16102829] 属性名称: hash\n2019-06-15 18:26:12.604339+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.604568+0800 RuntimDemo[18732:16102829] 属性名称: superclass\n2019-06-15 18:26:12.604777+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.604990+0800 RuntimDemo[18732:16102829] 属性名称: description\n2019-06-15 18:26:12.605190+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.605425+0800 RuntimDemo[18732:16102829] 属性名称: debugDescription\n2019-06-15 18:26:12.605645+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.605936+0800 RuntimDemo[18732:16102829] 属性array\n2019-06-15 18:26:12.606183+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.606395+0800 RuntimDemo[18732:16102829] 方法签名: method2\n2019-06-15 18:26:12.606628+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.606834+0800 RuntimDemo[18732:16102829] 方法签名: method4WithArg1:arg2:\n2019-06-15 18:26:12.607034+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.607246+0800 RuntimDemo[18732:16102829] 方法签名: method1\n2019-06-15 18:26:12.607447+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.607663+0800 RuntimDemo[18732:16102829] 方法签名: runtimeClassProtocol\n2019-06-15 18:26:12.607879+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.608107+0800 RuntimDemo[18732:16102829] 方法签名: method3\n2019-06-15 18:26:12.608328+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.608544+0800 RuntimDemo[18732:16102829] 方法签名: categoryMethod\n2019-06-15 18:26:12.608751+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.609075+0800 RuntimDemo[18732:16102829] 方法签名: setArray:\n2019-06-15 18:26:12.609301+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.609538+0800 RuntimDemo[18732:16102829] 方法签名: .cxx_destruct\n2019-06-15 18:26:12.609716+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.609900+0800 RuntimDemo[18732:16102829] 方法签名: array\n2019-06-15 18:26:12.610099+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.610279+0800 RuntimDemo[18732:16102829] 方法签名: setString:\n2019-06-15 18:26:12.610425+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.610653+0800 RuntimDemo[18732:16102829] 方法签名: string\n2019-06-15 18:26:12.610860+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.611082+0800 RuntimDemo[18732:16102829] 方法签名: index\n2019-06-15 18:26:12.611292+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.611517+0800 RuntimDemo[18732:16102829] 方法签名: setIndex:\n2019-06-15 18:26:12.611719+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.611945+0800 RuntimDemo[18732:16102829] 方法method2\n2019-06-15 18:26:12.612125+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.612359+0800 RuntimDemo[18732:16102829] 类方法 classMethod\n2019-06-15 18:26:12.612575+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.612797+0800 RuntimDemo[18732:16102829] RuntimClass响应方法method4WithArg1:arg2:\n2019-06-15 18:26:12.612966+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.613153+0800 RuntimDemo[18732:16102829] method1 被调用\n2019-06-15 18:26:12.613371+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.613612+0800 RuntimDemo[18732:16102829] 协议名称：RuntimeClassProtocol\n2019-06-15 18:26:12.613829+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.614063+0800 RuntimDemo[18732:16102829] 协议名称：NSCopying\n2019-06-15 18:26:12.614253+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.614446+0800 RuntimDemo[18732:16102829] 协议名称：NSCoding\n2019-06-15 18:26:12.614655+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.614887+0800 RuntimDemo[18732:16102829] RuntimClass遵循协议NSCopying\n2019-06-15 18:26:12.615037+0800 RuntimDemo[18732:16102829] **********************************\n```\n\n### 5. 消息与消息转发\n#### (1) Method 基础数据结构：\n  Method 是 method_t 结构体的指针，method_t 在分析 method_list_t 已写出其结构，其结构中包括 SEL 和 IMP 两种数据结构。\n\n**SEL：**Objective-C 在编译的时候，objc_selector 会依据方法的名字、参数序列、生成一个整型标识的地址\n( int 类型的地址)：这个标识就是 SEL，其结构如下：\n\n```\n\ttypedef struct objc_selector *SEL\n```\n**IMP：**是一个函数指针，指向方法实现的地址。其结构如下：\n```\n\t/// A pointer to the function of a method implementation. \n\t#if !OBJC_OLD_DISPATCH_PROTOTYPES\n\ttypedef void (*IMP)(void /* id, SEL, ... */ ); \n\t#else\n\ttypedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); \n\t#endif\n```\n**SEL 和 IMP 为映射关系：**SEL 通过 Dispatch table 表寻找到对应的 IMP， Dispatch table 表存放 SEL 和 IMP 的映射。我们可以对一个编号 (SEL) 和什么方法 (IMP) 映射做些操作，也就是说我们可以一个 SEL 指向不同的函数指针，这样就可以完成一个方法名在不同时候执行不同的函数体。\n#### (2) 相关操作方法：\n```\n\t// 调用指定方法的实现，返回的是方法实现时的返回，参数 receiver 不能为空，这个比 method_getImplementation 和 method_getName 速度快\n\tvoid method_invoke_stret ( id receiver, Method m, ... )\n\n\t// 调用返回一个数据结构的方法的实现              \n\tid method_invoke ( id receiver, Method m, ... )           \n\n\t// 获取方法名，希望获得方法名的 C 字符串，使用 sel_getName(method_getName(method))          \n\tSEL method_getName ( Method m )                   \n\n\t// 返回方法的实现                  \n\tIMP method_getImplementation ( Method m )    \n\n\t// 获取描述方法参数和返回值类型的字符串                        \n\tconst char * method_getTypeEncoding ( Method m )    \n\n\t// 获取方法的返回值类型的字符串                 \n\tchar * method_copyReturnType ( Method m )         \n\n\t// 获取方法的指定位置参数的类型字符串                    \n\tchar * method_copyArgumentType ( Method m, unsigned int index )      \n\n\t// 通过引用返回方法的返回值类型字符串\n\tvoid method_getReturnType ( Method m, char *dst, size_t dst_len )    \n\n\t// 返回方法的参数的个数\n\tunsigned int method_getNumberOfArguments ( Method m )               \n\n\t// 通过引用返回方法指定位置参数的类型字符串\n\tvoid method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len )\n\n\t// 返回指定方法的方法描述结构体\n\tstruct objc_method_description * method_getDescription ( Method m )  \n\n\t// 设置方法的实现\n\tIMP method_setImplementation ( Method m, IMP imp )           \n\n\t// 交换两个方法的实现\n\tvoid method_exchangeImplementations ( Method m1, Method m2 )     \n\n\t// 返回给定选择器指定的方法的名称    \n\tconst char * sel_getName ( SEL sel )          \n\n\t// 返回 Runtime 系统中注册的方法，方法名映射的选择器                       \n\tSEL sel_registerName ( const char *str )                             \n\n\t// Runtime 系统中注册一个方法\n\tSEL sel_getUid ( const char *str )           \n\n\t// 比较两个选择器                        \n\tBOOL sel_isEqual ( SEL lhs, SEL rhs )                               \n```\n#### (4) Method 调用流程：\n**objc_msgSend 函数：** 这个函数将消息接收者和方法名作为基础参数。消息发送给一个对象时，objc_msgSend 通过对象的 isa 指针获得类的结构体，先在 Cache 里找，找到就执行，没找到就在分发列表里查找方法的 selector，没找到就通过 objc_msgSend 结构体中指向父类的指针找到父类，然后在父类分发列表找，直到 root class（NSObject）。Objc 中发送消息是用中括号把接收者和消息括起来，只到运行时才会把消息和方法实现绑定。为了加快速度，苹果对这个方法做了很多优化，这个方法是用汇编实现的。\nobjc_msgSend 定义如下：\n```\n\tobjc_msgSend(receiver, selector, arg1, arg2, ...)\n```\nobjc_msgSend 内部实现大致流程：首先在 Class 中的缓存查找 imp（没缓存则初始化缓存），如果没找到就去父类的 Class 查找，如果一直查到到根类仍旧没有实现，则用 *_objc_msgForward* 函数指针代替 imp， 最后执行 imp。 *_objc_msgForward*  是用于消息转发的，当方法没有被寻找到的时候，就会触发消息转发流程。\n\n**消息转发流程：**当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息，如果是以 [receiver message] 的方式调用方法，那么如果 receiver 无法响应 message 消息时，编译器就会报错。但如果是 perform... 的形式来调用，则需要等到运行时才能确定 receiver 是否能接受 message 消息。如果不能，则程序崩溃。消息转发的流程，可以分为三个阶段: 方法解析、重定向、消息转发。\n\n*tips:* 通常，当不能确定一个对象是否能接收某个消息时，会先调用 respondsToSelector: 来判断一下：\n```\nif ([self respondsToSelector:@selector(method)]) {\n    [self performSelector:@selector(method)];\n}\n```\n**方法解析：**当 runtime 在方法缓存列表和方法分发列表（包括超类）中找不到要执行的方法时，首先会进入方法解析阶段，此时可以在方法解析中动态添加方法实现。具体操作的函数如下：\n```\n\t// 实例方法找不到实现的情况，可以在方法解析中动态添加方法实现\n\t+ (BOOL)resolveInstanceMethod:(SEL)sel     \n\n\t//类方法找不到实现的情况，可以在方法解析中动态添加方法实现\n\t+ (BOOL)resolveClassMethod:(SEL)sel\n\n\t//动态添加一个方法，Class cls 是要指定的类，runtime 会到这个类中去找方法， SEL name 是要解析的方法，IMP 是动态添加的方法实现的 imp ，const char *types : 类型编码，是个字符串\n\tclass_addMethod(Class cls, SEL name, IMP imp, const char *types)      \n```\n[类型编码文档](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1)\n\n**重定向：**在消息转发机制执行前，系统会再给我们一次偷梁换柱的机会通过重载 *forwardingTargetForSelector* 方法替换消息的接受者为其他对象，毕竟消息转发需要耗费更多的时间，如果此方法返回 nil 或是 self，则会进入消息转发阶段。但是替换的对象千万不要是 self，那样会进入死循环。\n```\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    if (aSelector == @selector(mysteriousMethod:)) {\n       return alternateObject;\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n```\n**消息转发：**\n如果以上两种都没法处理未知消息就需要完整消息转发了，调用如下方法：\n``` \n\t//这一步是最后机会将消息转发给其它对象，对象会将未处理的消息相关的 selector，target 和参数都封装在 anInvocation 中。forwardInvocation :像未知消息分发中心，将未知消息转发给其它对象。注意的是 forwardInvocation: 方法只有在消息接收对象无法正常响应消息时才被调用。\n\t- (void)forwardInvocation:(NSInvocation *)anInvocation\n\n\t//必须重写这个方法，消息转发使用这个方法获得的信息创建 NSInvocation 对象。\n\t- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n```\n[消息转发更详细资料](http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/)\n\n#### (5) Method Swizzling：\nObjective-C 中的 Method Swizzling 允许我们动态地替换方法的实现，实现 Hook 功能，是一种比子类化更加灵活的“重写”方法的方式。讲 Method 结构的时候提到过：原则上方法的名称 name 和方法的实现 imp 是一一对应的，而 Method Swizzling 的原理就是动态地改变它们的对应关系，达到替换方法实现的目的，如下代码实现了 NSArray 异常操作的崩溃拦截功能：\n```\n#import \"NSArray+SafeArray.h\"\n#import <objc/runtime.h>\n\n/** \n 在 iOS 中 NSNumber、NSArray、NSDictionary 等这些类都是类簇，一个 NSArray 的实现可能由多个类组成。所以如果想对 NSArray 进行 Swizzling，必须获取到其“真身”进行 Swizzling，直接对 NSArray 进行操作是无效的。\n \n 下面列举了 NSArray 和 NSDictionary 本类的类名，可以通过Runtime函数取出本类。\n NSArray                __NSArrayI\n NSMutableArray         __NSArrayM\n NSDictionary           __NSDictionaryI\n NSMutableDictionary\t__NSDictionaryM\n */\n\n@implementation NSArray (SafeArray)\n\n// 注意下面的load方法中，不应该调用父类的load方法\n+ (void)load {\n    Method fromMethod = class_getInstanceMethod(objc_getClass(\"__NSArrayI\"), @selector(objectAtIndex:));\n    Method toMethod = class_getInstanceMethod(objc_getClass(\"__NSArrayI\"), @selector(safe_objectAtIndex:));\n    method_exchangeImplementations(fromMethod, toMethod);\n}\n\n// 为了避免和系统的方法冲突在 swizzling 方法前面加前缀\n- (id)safe_objectAtIndex:(NSUInteger)index {\n    if (self.count-1 < index) {\n        // 如果越界就进入异常拦截\n        @try {\n            return [self safe_objectAtIndex:index];\n        }\n        @catch (NSException *exception) {\n            // 崩溃后收集日志\n            NSLog(@\"---------- %s Crash Because Method %s  ----------\\n\", class_getName(self.class), __func__);\n            NSLog(@\"%@\", [exception callStackSymbols]);\n            return nil;\n        }\n        @finally {}\n    } else {\n        // 如果没有问题，则正常进行方法调用\n        return [self safe_objectAtIndex:index];\n    }\n}\n@end\n\n```\n**使用 Method Swizzling 注意的点：**\n\n**1 ）在 +load 方法中实现 Method Swizzling 的逻辑而不是在 +initialize ：**\n\n+load 和 +initialize 是 Objective-C runtime 会自动调用的两个类方法，但是它们的调用时机是不一样的。+load 方法是在类被加载的时候调用的，而 +initialize 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法调用。也就是说 +initialize 方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 +initialize 方法是永远不会被调用的。此外 +load 方法还有一个非常重要的特性，那就是子类、父类和分类中的 +load 方法的实现是被区别对待的。也就是说在 Objective-C runtime 自动调用 +load 方法时，分类中的 +load 方法并不会对主类中的 +load 方法造成覆盖。所以在 +load 方法是实现 Method Swizzling 逻辑是最佳选择。\n\n**2 ）用 dispatch_once 来进行调度：**\n\n+load 方法在类加载的时候会被 runtime 自动调用一次，但是它并没有限制程序员对 +load 方法的手动调用，所以使用 dispatch_once 确保代码不管有多少线程都只被执行一次。\n\n**3 ）需要调用 class_addMethod 方法，并且以它的结果为依据分别处理两种不同的情况：**\n\n使用 Method Swizzling 的目的通常都是为了给程序增加功能，而不是完全替换某个功能，所以我们一般都需要在自定义的实现中调用原始的实现，所以这里就会有两种情况需要我们分别进行处理：\n\n*第一种情况：*主类本身有实现需要替换的方法，也就是 class_addMethod 方法返回 NO 时，直接交换两个方法的实现就可以了。\n\n*第二种情况：*主类本身没有实现需要替换的方法，而是继承了父类的实现，即 class_addMethod 方法返回 YES。这时调用 class_getInstanceMethod 函数获取到的 originalSelector 指向的就是父类的方法，我们再通过执行 lass_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); 将父类的实现替换到我们自定义的方法中，这样就达到了在自定义方法的实现中调用父类实现的目的。\n\n**4）Selector，Method 和 Implementation 的关系：**\n\n一个类维护一个运行时可接收的消息分发表，分发表中每个入口是一个 Method，其中 key 是一个特定的名称即 SEL，与其对应的实现是 IMP 即指向底层 C 函数的指针。\n\n[Runtime Method Swizzling 开发实例汇总](https://juejin.im/entry/584912648e450a006c4be90a)\n### 6. Category 和 Protocol\n#### (1) Category 数据结构：\n```\nstruct category_t {\n    const char *name; \n    classref_t cls;\n    struct method_list_t *instanceMethods;         // 实例方法列表\n    struct method_list_t *classMethods;            // 类方法列表，Meta Class方法列表的子集\n    struct protocol_list_t *protocols;             // 分类所实现的协议列表\n    struct property_list_t *instanceProperties;    \n    // Fields below this point are not always present on disk.\n    struct property_list_t *_classProperties;      \n\n    method_list_t *methodsForMeta(bool isMeta) {\n        if (isMeta) return classMethods;\n        else return instanceMethods;\n    }\n\n    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);\n};\n```\n#### (2) Category 的用途：\n\n 1 ) 给现有的类添加方法\n\n 2 ) 将一个类的实现拆分成多个独立的源文件\n\n 3 ) 声明私有的方法\n\n*注意:* Category 有一个非常容易误用的场景，那就是用 Category 来覆写父类或主类的方法。虽然目前 Objective-C 是允许这么做的，但是这种使用场景是非常不推荐的。使用 Category 来覆写方法有很多缺点，比如不能覆写 Category 中的方法、无法调用主类中的原始实现等，且很容易造成无法预估的行为。 \n#### (3) Category 的实现原理：\n1 ）在编译时期，会将 Category 中实现的方法生成一个结构体 method_list_t ，将声明的属性生成一个结构体 property_list_t ，然后通过这些结构体生成一个结构体 category_t 并保存。\n\n2 ）在运行时期，Runtime 会拿到编译时期我们保存下来的结构体 category_t 然后将结构体 category_t 中的实例方法列表、协议列表、属性列表添加到主类中。\n\n3 ）将结构体 category_t 中的类方法列表、协议列表添加到主类的 metaClass 中。\n\n*注意点 (1)：*category_t 中的方法列表是插入到主类的方法列表前面，所以这里 Category 中实现的方法并不会真正的覆盖掉主类中的方法，只是将 Category 的方法插到方法列表的前面去了，运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会停止查找，即会出现覆盖方法的这种假象了。\n\n*注意点 (2)：*Category 添加实例变量，因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局。\n\n关键代码在 objc-runtime-new.mm 中的 _read_images 方法中实现，如下：\n```\n/***********************************************************************\n* _read_images\n* Perform initial processing of the headers in the linked \n* list beginning with headerList. \n*\n* Called by: map_images_nolock\n*\n* Locking: runtimeLock acquired by map_images\n**********************************************************************/\nvoid _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)\n{\n    header_info *hi;\n    uint32_t hIndex;\n    size_t count;\n    size_t i;\n    Class *resolvedFutureClasses = nil;\n    size_t resolvedFutureClassCount = 0;\n    static bool doneOnce;\n    TimeLogger ts(PrintImageTimes);\n\n    runtimeLock.assertLocked();\n\n#define EACH_HEADER \\\n    hIndex = 0;         \\\n    hIndex < hCount && (hi = hList[hIndex]); \\\n    hIndex++\n\n    if (!doneOnce) {\n        doneOnce = YES;\n\n        if (DisableTaggedPointers) {\n            disableTaggedPointers();\n        }\n        \n        initializeTaggedPointerObfuscator();\n\n        if (PrintConnecting) {\n            _objc_inform(\"CLASS: found %d classes during launch\", totalClasses);\n        }\n\n        // namedClasses\n        // Preoptimized classes don't go in this table.\n        // 4/3 is NXMapTable's load factor\n        int namedClassesSize = \n            (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * 4 / 3;\n        gdb_objc_realized_classes =\n            NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);\n        \n        allocatedClasses = NXCreateHashTable(NXPtrPrototype, 0, nil);\n        \n        ts.log(\"IMAGE TIMES: first time tasks\");\n    }\n\n    // Discover categories. \n    for (EACH_HEADER) {\n        category_t **catlist = \n            _getObjc2CategoryList(hi, &count);\n        bool hasClassProperties = hi->info()->hasCategoryClassProperties();\n\n        for (i = 0; i < count; i++) {\n            category_t *cat = catlist[i];\n            Class cls = remapClass(cat->cls);\n\n            if (!cls) {\n                // Category's target class is missing (probably weak-linked).\n                // Disavow any knowledge of this category.\n                catlist[i] = nil;\n                if (PrintConnecting) {\n                    _objc_inform(\"CLASS: IGNORING category \\?\\?\\?(%s) %p with \"\n                                 \"missing weak-linked target class\", \n                                 cat->name, cat);\n                }\n                continue;\n            }\n\n            // Process this category. \n            // First, register the category with its target class. \n            // Then, rebuild the class's method lists (etc) if \n            // the class is realized. \n            bool classExists = NO;\n            if (cat->instanceMethods ||  cat->protocols  \n                ||  cat->instanceProperties) \n            {\n                addUnattachedCategoryForClass(cat, cls, hi);\n                if (cls->isRealized()) {\n                    remethodizeClass(cls);\n                    classExists = YES;\n                }\n                if (PrintConnecting) {\n                    _objc_inform(\"CLASS: found category -%s(%s) %s\", \n                                 cls->nameForLogging(), cat->name, \n                                 classExists ? \"on existing class\" : \"\");\n                }\n            }\n\n            if (cat->classMethods  ||  cat->protocols  \n                ||  (hasClassProperties && cat->_classProperties)) \n            {\n                addUnattachedCategoryForClass(cat, cls->ISA(), hi);\n                if (cls->ISA()->isRealized()) {\n                    remethodizeClass(cls->ISA());\n                }\n                if (PrintConnecting) {\n                    _objc_inform(\"CLASS: found category +%s(%s)\", \n                                 cls->nameForLogging(), cat->name);\n                }\n            }\n        }\n    }\n\n    ts.log(\"IMAGE TIMES: discover categories\");\n#undef EACH_HEADER\n}\n```\n上面代码主要完成了一下以下几件事：\n\n1 ）将 Category 和它的主类（或元类）注册到哈希表中\n\n2 ）如果主类（或元类）已实现，那么重建它的方法列表\n\n3 ）Category 中的实例方法和属性被整合到主类中；而类方法则被整合到元类中\n\n4 ）对协议的处理比较特殊，Category 中的协议被同时整合到了主类和元类中\n\n上述代码中通过 static void remethodizeClass(Class cls) 函数来重新整理类的数据结构，代码如下：\n```\nstatic void remethodizeClass(Class cls)\n{\n    category_list *cats;\n    bool isMeta;\n\n    runtimeLock.assertLocked();\n\n    isMeta = cls->isMetaClass();\n\n    // Re-methodizing: check for more categories\n    if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) {\n        if (PrintConnecting) {\n            _objc_inform(\"CLASS: attaching categories to class '%s' %s\", \n                         cls->nameForLogging(), isMeta ? \"(meta)\" : \"\");\n        }\n        \n        attachCategories(cls, cats, true /*flush caches*/);        \n        free(cats);\n    }\n}\n```\n这个函数的主要作用是将 Category 中的方法、属性和协议整合到类（主类或元类）中，更新类的数据字段 data() 中 method_lists（或 method_list）、properties 和 protocols 的值。上述代码中真正处理 Category 的方法是 attachCategories 方法，源码如下：\n```\n// Attach method lists and properties and protocols from categories to a class.\n// Assumes the categories in cats are all loaded and sorted by load order, \n// oldest categories first.\nstatic void \nattachCategories(Class cls, category_list *cats, bool flush_caches)\n{\n    if (!cats) return;\n    if (PrintReplacedMethods) printReplacements(cls, cats);\n\n    bool isMeta = cls->isMetaClass();\n\n    // fixme rearrange to remove these intermediate allocations\n    method_list_t **mlists = (method_list_t **)\n        malloc(cats->count * sizeof(*mlists));\n    property_list_t **proplists = (property_list_t **)\n        malloc(cats->count * sizeof(*proplists));\n    protocol_list_t **protolists = (protocol_list_t **)\n        malloc(cats->count * sizeof(*protolists));\n\n    // Count backwards through cats to get newest categories first\n    int mcount = 0;\n    int propcount = 0;\n    int protocount = 0;\n    int i = cats->count;\n    bool fromBundle = NO;\n    while (i--) {\n        auto& entry = cats->list[i];\n\n        method_list_t *mlist = entry.cat->methodsForMeta(isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist;\n            fromBundle |= entry.hi->isBundle();\n        }\n\n        property_list_t *proplist = \n            entry.cat->propertiesForMeta(isMeta, entry.hi);\n        if (proplist) {\n            proplists[propcount++] = proplist;\n        }\n\n        protocol_list_t *protolist = entry.cat->protocols;\n        if (protolist) {\n            protolists[protocount++] = protolist;\n        }\n    }\n\n    auto rw = cls->data();\n\n    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);\n    rw->methods.attachLists(mlists, mcount);\n    free(mlists);\n    if (flush_caches  &&  mcount > 0) flushCaches(cls);\n\n    rw->properties.attachLists(proplists, propcount);\n    free(proplists);\n\n    rw->protocols.attachLists(protolists, protocount);\n    free(protolists);\n}\n```\n#### (4) Protocol\nProtocol 结构如下：\n```\ntypedef uintptr_t protocol_ref_t;  // protocol_t *, but unremapped\n```\nprotocol_ref_t 指向 protocol_t，而 protocol_t 继承自 objc_object，所以 Protocol 是对象结构体，protocol_t 关键结构如下：\n```\nstruct protocol_t : objc_object {\n    const char *mangledName;\n    struct protocol_list_t *protocols;\n    method_list_t *instanceMethods;\n    method_list_t *classMethods;\n    method_list_t *optionalInstanceMethods;\n    method_list_t *optionalClassMethods;\n    property_list_t *instanceProperties;\n    uint32_t size;   // sizeof(protocol_t)\n    uint32_t flags;\n    // Fields below this point are not always present on disk.\n    const char **_extendedMethodTypes;\n    const char *_demangledName;\n    property_list_t *_classProperties;\n}\n```\n\n#### (5) Category 和 Protocol 的操作方法\n```\n// 返回指定的协议\nProtocol * objc_getProtocol ( const char *name );\n\n// 获取运行时所知道的所有协议的数组\nProtocol ** objc_copyProtocolList ( unsigned int *outCount );\n\n// 创建新的协议实例\nProtocol * objc_allocateProtocol ( const char *name );\n\n// 在运行时中注册新创建的协议，创建一个新协议后必须使用这个进行注册这个新协议，但是注册后不能够再修改和添加新方法。\nvoid objc_registerProtocol ( Protocol *proto ); \n\n// 为协议添加方法\nvoid protocol_addMethodDescription ( Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod );\n\n// 添加一个已注册的协议到协议中\nvoid protocol_addProtocol ( Protocol *proto, Protocol *addition );\n\n// 为协议添加属性\nvoid protocol_addProperty ( Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty );\n\n// 返回协议名\nconst char * protocol_getName ( Protocol *p );\n\n// 测试两个协议是否相等\nBOOL protocol_isEqual ( Protocol *proto, Protocol *other );\n\n// 获取协议中指定条件的方法的方法描述数组\nstruct objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount );\n\n// 获取协议中指定方法的方法描述\nstruct objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod );\n\n// 获取协议中的属性列表\nobjc_property_t * protocol_copyPropertyList ( Protocol *proto, unsigned int *outCount );\n\n// 获取协议的指定属性\nobjc_property_t protocol_getProperty ( Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty );\n\n// 获取协议采用的协议\nProtocol ** protocol_copyProtocolList ( Protocol *proto, unsigned int *outCount );\n\n// 查看协议是否采用了另一个协议\nBOOL protocol_conformsToProtocol ( Protocol *proto, Protocol *other );\n```\n\n#### (7) Extention\n**Extention 格式如下：**\n```\n@interface ClassName()\n//私有属性\n//私有方法，如果不实现，编译时会报警\n@end\n```\n\n**(2) Extension 的作用**\n\n1 )  为一个类添加原来没有的变量、方法、属性\n2 )  一般的类扩展写到 .m 文件中\n3 )  一般的私有属性写到 .m 文件中的类扩展中\n\n**(3) Category 和 Extension 的区别**\n\n1 )  Category 中原则上只能增加方法（能添加属性的的原因只是通过 runtime 解决无 setter / getter 的问题而已）。Extension 不仅可以增加方法，还可以增加实例变量（或者属性），只是该实例变量默认是 Private 类型的。\n\n2 )  Extension 中声明的方法没被实现，编译器会报警，但是 Category 中的方法没被实现编译器是不会有任何警告的。Extention 添加的方法是在编译阶段被添加到类中，而 Category 添加的方法是在运行时添加到类中。所以相对于两者各有不同特性。\n\n3 )  Extention 不能像 Category 那样拥有独立的实现部分。也就是说，Extention 所声明的方法必须依托对应类的实现部分来实现。\n\n4 )  定义在 .m 文件中的 Extention 方法为私有的，Extention 是在 .m 文件中声明私有方法的非常好的方式。\n\n### 7. Runtime 的应用\n**(1) 利用 Method Swizzling 特性实现用户行为收集，预防数组字典越界奔溃， 代码解耦等**\n\n**(2) 获取系统提供的库相关信息**\n\n**(3) 为类动态添加方法**\n\n## Swift Runtime\n已查阅到的资料，待消化总结：\n\n[https://github.com/apple/swift/blob/master/docs/Runtime.md](https://github.com/apple/swift/blob/master/docs/Runtime.md)\n\n[https://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&mid=403068491&idx=1&sn=c95f07e3d38c92ba56933502cc3e1800#rd](https://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&mid=403068491&idx=1&sn=c95f07e3d38c92ba56933502cc3e1800#rd)\n\n[https://nshipster.com/swift-objc-runtime/](https://nshipster.com/swift-objc-runtime/)\n\n[https://academy.realm.io/posts/mobilization-roy-marmelstein-objective-c-runtime-swift-dynamic/](https://academy.realm.io/posts/mobilization-roy-marmelstein-objective-c-runtime-swift-dynamic/)","source":"_posts/iOS-Runtime.md","raw":"---\ntitle: iOS-Runtime\ndate: 2019-05-30 10:25:47\ntags: iOS\n---\n\nRuntime 总结相关示例代码：[https://github.com/terryfine/BlogDemo/tree/master/RuntimDemo](https://github.com/terryfine/BlogDemo/tree/master/RuntimDemo)\n## Objc Runtime\n  源代码下载地址：[http://www.opensource.apple.com/source/objc4/](http://www.opensource.apple.com/source/objc4/)\n\n  Runtime 函数文档: [https://developer.apple.com/documentation/objectivec/objective-c_runtime](https://developer.apple.com/documentation/objectivec/objective-c_runtime)\n\n  苹果官方 Runtime 编程指南：\n  [https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048)\n\n### 1. 概念\n Objective-C 是一门动态语言，它将很多静态语言在编译和链接时做的事情推迟到运行时来处理。\n\n 这种动态特性意味着 Objective-C 不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。\n 对于 Objective-C 来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。\n\n Runtime 就是使用 C 和汇编写的一个运行时库，一般我们说 Runtime，不但包含运行时库的意思，还包含了运行时、运行时系统等概念。\n\n**Objc Runtime 使得 C 具有了面向对象能力，可以在程序运行时创建、检查、修改类、对象和它们的方法**。\n\n### 2. Runtime 的作用：\n#### (1) 封装\n Runtime 库中，对象可以用 C 语言中的结构体表示，而方法可以用 C 函数来实现，再加上了一些其他的特性。这些结构体和函数被 runtime 函数封装后，就可以在程序运行时创建、检查、修改类、对象和它们的方法了。\n### (2) 找到方法的最终执行代码\n 当程序中执行 [receiver message] 时，会向消息接收者（receiver）发送一条消息 message，runtime 会根据消息接收者是否能响应该消息而做出不同的反应，即消息转发的流程。\n### 3. 类和对象（Class 和 Object）相关的基本数据结构\n#### (1) 关键词：\n Class：指向了 objc_class 结构体的指针 \n\tid：参数类型，指向某个类实例的指针 \n\tMethod：代表了类中的某个方法的类型\n\tSEL：方法选择器，全名是 selector\n\tIMP：函数指针，由编译器生成，方法实现的代码就是由 IMP 指定\n\tIvar：成员变量的类型\n\tProperty：属性存储器\n\tCache：方法调用的缓存器，为方法调用的性能进行优化\n\n#### (2) objc_class 和 objc_object 数据结构：\n```\ntypedef struct objc_class *Class;\ntypedef struct objc_object *id;\n```\n#### (3) objc_object 和 isa\nobjc_object 源代码在 objc-private.h line 75, 关键代码如下：\n```\nstruct objc_object {\nprivate:\n    isa_t isa;\n\npublic:\n\n    // ISA() assumes this is NOT a tagged pointer object\n    Class ISA();\n\n    // getIsa() allows this to be a tagged pointer object\n    Class getIsa();\n}\n```\nobjc_object 中的 isa，对应类型为联合体 isa_t，源代码在 objc-private.h line 61, 关键代码定义如下：\n```\nstruct {\n    uintptr_t nonpointer        : 1;                                         \\         //0:普通指针，1:优化过，使用位域存储更多信息\n    uintptr_t has_assoc         : 1;                                         \\         //对象是否含有或曾经含有关联引用\n    uintptr_t has_cxx_dtor      : 1;                                         \\         //表示是否有 C++ 析构函数或OC的 dealloc\n    uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\         //存放着 Class、Meta-Class 对象的内存地址信息\n    uintptr_t magic             : 6;                                         \\         //用于在调试时分辨对象是否未完成初始化\n    uintptr_t weakly_referenced : 1;                                         \\         //是否被弱引用指向\n    uintptr_t deallocating      : 1;                                         \\         //对象是否正在释放\n    uintptr_t has_sidetable_rc  : 1;                                         \\         //是否需要使用 sidetable 来存储引用计数\n    uintptr_t extra_rc          : 8                                                    //引用计数能够用 8 个二进制位存储时，直接存储在这里\n}\n```\n#### (4) objc_class\nobjc_class 源代码可在 objc-runtime-new.h line 1111 看到，由于 objc_class 继承自 objc_object， 所以其关键结构可简化如下:\n```\nstruct objc_class : objc_object {\n    isa_t isa;                 // Class ISA;\n    Class superclass;\n    cache_t cache;             // formerly cache pointer and vtable\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n\n    class_rw_t *data() { \n        return bits.data();\n    }\n}\n```\nobjc_object 用来描述 OC 中的实例，当用口语描述实例时，总会说 「XX类的实例x」或「x是XX的实例」。objc_object 的 isa 在程序结构上表达类似的含义，它指向了该实例所对应的类，类在 runtime 中被描述成 objc_class 结构。\nObjective-C 中的类本质上也是对象，称之为类对象，在 Objective-C 中有一个非常特殊的类 NSObject ，绝大部分的类都继承自它。它是 Objective-C 中的两个根类（rootclass）之一，另外一个是 NSProxy。\nNSObject 只有一个成员变量 isa。所有继承自 NSObject 的类也都会有这个成员变量。\n\n#### (5) 元类（metaclass）、根类（root class）、根元类（root metaclass）\n本质上 Objective-C 中的类也是对象，它也是某个类的实例，这个类我们称之为元类（metaclass）。元类也是对象（元类对象），元类也是某个类的实例，这个类我们称之为根元类（root metaclass）。\n不过，有一点比较特殊，那就是所有的元类所属的类都是同一个根元类（当然根元类也是元类，所以它所属的类也是根元类，即它本身）。根元类指的就是根类的元类，具体来说就是根类 NSObject 对应的元类。\n\n通过调用类方法，比如 [NSObject new]，给类对象发送消息。同样的，类对象能否响应这个消息也要通过 isa 找到类对象所属的类（元类）才能知道。也就是说，实例方法是保存在类中的，而类方法是保存在元类中的。理论上我们也可以给元类发送消息，但是 Objective-C 倾向于隐藏元类，不想让大家知道元类的存在。元类是为了保持 Objective-C 对象模型在设计上的完整性而引入的，比如用来保存类方法等，它主要是用来给编译器使用的。\n\n下图是为类（class），元类（metaclass），根类（root class），根元类（root metaclass）关系\n![](iOS-Runtime/object_model.png)\n#### (6) superclass\n指向该类的父类，如果该类已经是最顶层的根类（如 NSObject 或 NSProxy），则 superclass 为 NULL。\n#### (7) cache_t\ncache_t 是一个散列表，用来缓存曾经调用过的方法，提高方法的查找速度。\n源代码可在 objc-runtime-new.h line 59 找到，其关键结构如下:\n```\nstruct cache_t {\n    struct bucket_t *_buckets;     // 散列表\n    mask_t _mask;                  // 散列表的长度 -1\n    mask_t _occupied;              // 已经缓存的方法数量\n}\n\nstruct bucket_t {\n    cache_key_t _key;              // SEL 作为 key\n    MethodCacheIMP _imp;           // 函数的内存地址\n};\n```\n**buckets：**指向 Method 数据结构指针的数组。这个数组可能包含不超过 mask+1 个元素。需要注意的是，指针可能是 NULL，表示这个缓存 bucket 没有被占用，另外被占用的 bucket 可能是不连续的。这个数组可能会随着时间而增长。\n\n**mask：**一个整数，指定分配的缓存 bucket 的总数。在方法查找过程中，Objective-C runtime 使用这个字段来确定开始线性查找数组的索引未知。指向方法 selector 的指针与该字段做一个 AND 位操作（index = (mask & selector)）。这可以作为一个简单的 hash 散列算法。\n\n**occupied：**一个整数，指定实际占用的缓存 bucket 的总数。\n\n#### (8) class_data_bits_t\nclass_data_bits_t 是一个结构体，里面包含了一个 class_rw_t 类型的指针 data。class_rw_t 内部有个 class_ro_t 的指针 ro。class_rw_t 是可读可写的，class_ro_t 是只读的。 class_data_bits_t 源代码可以在 objc-runtime-new.h line 870 看到。\n\n**class_rw_t** 结构如下：\n```\nstruct class_rw_t {\n    // Be warned that Symbolication knows the layout of this structure.\n    uint32_t flags;\n    uint32_t version;\n\n    const class_ro_t *ro;             // 保存类的原始数据(不包含分类内容和动态添加的方法)\n    method_array_t methods;           // 方法列表(如果是类对象存储的是对象方法,元类对象存储的是类方法)\n    property_array_t properties;      // 属性列表\n    protocol_array_t protocols;       // 协议列表\n    Class firstSubclass;              // 第一个子类\n    Class nextSiblingClass;           // 兄弟类\n}\n\n```\n\n**class_ro_t** 储存了类的初始信息，不包括分类和后来动态添加的内容。class_ro_t 关键代码如下：\n```\nstruct class_ro_t {\n    uint32_t flags;\n    uint32_t instanceStart;\n    uint32_t instanceSize;\n#ifdef __LP64__\n    uint32_t reserved;\n#endif\n\n    const uint8_t * ivarLayout;\n    \n    const char * name;                    // 类名\n    method_list_t * baseMethodList;       // 原始方法列表\n    protocol_list_t * baseProtocols;      // 原始协议列表\n    const ivar_list_t * ivars;            // 成员变量列表\n\n    const uint8_t * weakIvarLayout;\n    property_list_t *baseProperties;      // 属性列表\n\n    method_list_t *baseMethods() const {\n        return baseMethodList;\n    }\n}\n\n```\n**method_list_t** 数组包含了多个 method_t，其中 method_t 也是结构体 ，其关键结构如下：\n```\nstruct method_t {\n    SEL name;               // 函数名\n    const char *types;      // 方法参数 (包含了返回值类型,参数类型)\n    MethodListIMP imp;      // 方法的实现 (指向函数的指针)\n}\n```\n**ivar_list_t** 数组包含了多个 ivar_t 类型的结构体 ivar，ivar_t 结构如下：\n\n```\nstruct ivar_t {\n    int32_t *offset;               // 变量在内存中相对所属对象内存空间起始地址的偏移量,偏移量大小根据类型来定\n    const char *name;              // 变量名\n    const char *type;              // 变量类型\n    // alignment is sometimes -1; use alignment() instead\n    uint32_t alignment_raw;\n    uint32_t size;\n\n    uint32_t alignment() const {\n        if (alignment_raw == ~(uint32_t)0) return 1U << WORD_SHIFT;\n        return 1 << alignment_raw;\n    }\n}\n```\n**property_list_t** 数组包含多个 property_t，property_t 结构如下：\n```\nstruct property_t {\n    const char *name;             \n    const char *attributes;        \n}\n```\n\nclass_ro_t 包含的类信息（方法、属性、协议等）都是在编译期就可以确定的，暂且称为元信息吧，在之后的逻辑中，它们显然是不希望被改变的；后续在用户层，无论是方法还是别的扩展，都是在 class_rw_t 上进行操作，这些操作都不会影响类的元信息。更多关于 class_rw_t 和 class_ro_t 的资料可查看 [这篇文章](https://zhangbuhuai.com/post/runtime.html)。\n\n### 4. 类和对象相关操作方法\n操作类相关的函数一般以 class 为前缀，操作对象相关函数以 objc 或 object_ 为前缀。可在开篇 Runtime 函数文档查看相关方法。\n\n#### (1) 类相关操作函数\t\n```\n\tconst char * class_getName ( Class cls )           // 获取类名\n\n\tClass class_getSuperclass ( Class cls )            // 获取父类\n\n\tBOOL class_isMetaClass ( Class cls )               // 判断给定的类是不是元类\n\n\tsize_t class_getInstanceSize ( Class cls )         // 获取类的实例大小\n\n\tint class_getVersion ( Class cls )                 // 获取版本号\n\n\tvoid class_setVersion ( Class cls, int version )   // 设置版本号\n\n\n```\n\n#### (2) 成员变量 (ivars) 和属性相关操作函数\n```\n\tIvar class_getInstanceVariable ( Class cls, const char *name )                                           // 获取类中指定名称实例成员变量的信息\n\n\tIvar class_getClassVariable ( Class cls, const char *name )                                              // 获取类成员变量的信息\n\n\tBOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types )    // 在 runtime 时创建的类添加成员变量\n\n\tIvar * class_copyIvarList ( Class cls, unsigned int *outCount )                                          // 获取整个成员变量列表，必须使用 free() 来释放\n\n\n```\n#### (3) method 相关操作函数\n```\n\tBOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types )       // 添加方法，和成员变量不同的是可以为类动态添加方法。如果有同名会返回 NO，修改的话需要使用 method_setImplementation\n\n\tMethod class_getInstanceMethod ( Class cls, SEL name )                         // 获取实例方法\n\n\tMethod class_getClassMethod ( Class cls, SEL name )                            // 获取类方法\n\n\tMethod * class_copyMethodList ( Class cls, unsigned int *outCount )            // 获取所有方法\n\n\tIMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types )    // 实现替换方法\n\n\tIMP class_getMethodImplementation ( Class cls, SEL name )                      // 返回方法的具体实现\n\n\tIMP class_getMethodImplementation_stret ( Class cls, SEL name )                // 返回方法的具体实现\n\n\tBOOL class_respondsToSelector ( Class cls, SEL sel )                           // 类实例是否响应指定的 selector\n\n\n\n```\n#### (4) protocol 相关操作函数\n```\n\tBOOL class_addProtocol ( Class cls, Protocol *protocol )                       // 添加协议\n\n\tBOOL class_conformsToProtocol ( Class cls, Protocol *protocol )                // 返回类是否实现指定的协议\n\n\tProtocol * class_copyProtocolList ( Class cls, unsigned int *outCount )        // 获取类实现的协议列表\n\n\n```\n\n#### (5) 相关示例代码及输出：\n```\n RuntimClass *runtimeClass = [[RuntimClass alloc] init];\n Class cls = runtimeClass.class;\n\n // 类名\n const char *clsName = class_getName(cls);\n NSLog(@\"类名：%s\", clsName);\n NSLog(@\"**********************************\");\n \n // 父类\n Class superCls = class_getSuperclass(cls);\n NSLog(@\"父类名：%s\", class_getName(superCls));\n NSLog(@\"**********************************\");\n \n // 元类\n BOOL isMetaCls = class_isMetaClass(cls);\n NSLog(@\"%s %@元类\", clsName, (isMetaCls ? @\"是\" : @\"不是\"));\n NSLog(@\"**********************************\");\n \n Class metaCls = objc_getMetaClass(class_getName(cls));\n NSLog(@\"%s的元类是：%s\", clsName, class_getName(metaCls));\n NSLog(@\"**********************************\");\n \n // 变量实例大小\n size_t instanceSize = class_getInstanceSize(cls);\n NSLog(@\"%s的所有实例变量大小：%zu\",clsName ,instanceSize);\n NSLog(@\"**********************************\");\n \n // 成员变量\n unsigned int outCount = 0;\n Ivar *ivars = class_copyIvarList(cls, &outCount);\n for (int i = 0; i < outCount; i++) {\n     Ivar ivar = ivars[i];\n     NSLog(@\"成员变量%s在第%d的位置\", ivar_getName(ivar), i);\n     NSLog(@\"**********************************\");\n }\n free(ivars);\n \n Ivar ivar = class_getInstanceVariable(cls, \"_array\");\n if (ivar != NULL) {\n     const char *ivarName = ivar_getName(ivar);\n     NSLog(@\"成员变量：%s\", ivarName);\n     NSLog(@\"**********************************\");\n } else {\n     NSLog(@\"没有此成员变量\");\n     NSLog(@\"**********************************\");\n }\n \n // 属性\n objc_property_t *properties = class_copyPropertyList(cls, &outCount);\n for (int i = 0; i < outCount; i++) {\n     objc_property_t property = properties[i];\n     NSLog(@\"属性名称: %s\", property_getName(property));\n     NSLog(@\"**********************************\");\n }\n free(properties);\n \n objc_property_t arrayProperty = class_getProperty(cls, \"array\");\n if (arrayProperty != NULL) {\n     const char *arryPropertyName = property_getName(arrayProperty);\n     NSLog(@\"属性%s\", arryPropertyName);\n     NSLog(@\"**********************************\");\n }\n \n //方法\n Method *methods = class_copyMethodList(cls, &outCount);   //包含category添加的方法\n for (int i = 0; i < outCount; i++) {\n     Method method = methods[i];\n     SEL methodSignature = method_getName(method);\n     NSLog(@\"方法签名: %s\", methodSignature);\n     NSLog(@\"**********************************\");\n }\n free(methods);\n \n Method method1 = class_getInstanceMethod(cls, @selector(method2));\n if (method1 != NULL) {\n     SEL method1Signature = method_getName(method1);\n     NSLog(@\"方法%s\",method1Signature);\n     NSLog(@\"**********************************\");\n } else {\n     NSLog(@\"未找到此方法\");\n     NSLog(@\"**********************************\");\n }\n \n Method classMethod = class_getClassMethod(cls, @selector(classMethod));\n if (classMethod != NULL) {\n     SEL classMethodName = method_getName(classMethod);\n     NSLog(@\"类方法 %s\", classMethodName);\n     NSLog(@\"**********************************\");\n }\n \n BOOL responds = class_respondsToSelector(cls, @selector(method4WithArg1:arg2:));\n if (responds) {\n     Method respondsMethod = class_getInstanceMethod(cls, @selector(method4WithArg1:arg2:));\n     SEL respondsMethodName = method_getName(respondsMethod);\n     NSLog(@\"%s响应方法%s\", clsName, respondsMethodName);\n     NSLog(@\"**********************************\");\n } else {\n     NSLog(@\"%s不响应此方法\", clsName);\n     NSLog(@\"**********************************\");\n }\n \n IMP imp = class_getMethodImplementation(cls, @selector(method1));\n imp();\n NSLog(@\"**********************************\");\n \n // 协议\n Protocol __unsafe_unretained **protocols = class_copyProtocolList(cls, &outCount);\n for (int i = 0; i < outCount; i++) {\n     Protocol * protocol = protocols[i];\n     const char *protocalName = protocol_getName(protocol);\n     NSLog(@\"协议名称：%s\", protocalName);\n     NSLog(@\"**********************************\");\n }\n Protocol * protocol = protocols[1];\n BOOL conformProtocol = class_conformsToProtocol(cls, protocol);\n NSLog(@\"%s%@遵循协议%s\", clsName, (conformProtocol ? @\"\" : @\"不\"), protocol_getName(protocol));\n NSLog(@\"**********************************\");\n\n输出日志如下：\n\n2019-06-15 18:26:12.595856+0800 RuntimDemo[18732:16102829] 类名：RuntimClass\n2019-06-15 18:26:12.596386+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.596500+0800 RuntimDemo[18732:16102829] 父类名：NSObject\n2019-06-15 18:26:12.596584+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.596721+0800 RuntimDemo[18732:16102829] RuntimClass 不是元类\n2019-06-15 18:26:12.596798+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.596890+0800 RuntimDemo[18732:16102829] RuntimClass的元类是：RuntimClass\n2019-06-15 18:26:12.596966+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.597060+0800 RuntimDemo[18732:16102829] RuntimClass的所有实例变量大小：56\n2019-06-15 18:26:12.597136+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.597251+0800 RuntimDemo[18732:16102829] 成员变量firstInstance在第0的位置\n2019-06-15 18:26:12.597429+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.597622+0800 RuntimDemo[18732:16102829] 成员变量secondInstance在第1的位置\n2019-06-15 18:26:12.597803+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.601663+0800 RuntimDemo[18732:16102829] 成员变量thirdInstance在第2的位置\n2019-06-15 18:26:12.601739+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.601823+0800 RuntimDemo[18732:16102829] 成员变量_array在第3的位置\n2019-06-15 18:26:12.601888+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.601965+0800 RuntimDemo[18732:16102829] 成员变量_string在第4的位置\n2019-06-15 18:26:12.602033+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.602106+0800 RuntimDemo[18732:16102829] 成员变量_index在第5的位置\n2019-06-15 18:26:12.602168+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.602479+0800 RuntimDemo[18732:16102829] 成员变量：_array\n2019-06-15 18:26:12.602681+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.602908+0800 RuntimDemo[18732:16102829] 属性名称: array\n2019-06-15 18:26:12.603056+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.603266+0800 RuntimDemo[18732:16102829] 属性名称: string\n2019-06-15 18:26:12.603464+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.603662+0800 RuntimDemo[18732:16102829] 属性名称: index\n2019-06-15 18:26:12.603887+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.604116+0800 RuntimDemo[18732:16102829] 属性名称: hash\n2019-06-15 18:26:12.604339+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.604568+0800 RuntimDemo[18732:16102829] 属性名称: superclass\n2019-06-15 18:26:12.604777+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.604990+0800 RuntimDemo[18732:16102829] 属性名称: description\n2019-06-15 18:26:12.605190+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.605425+0800 RuntimDemo[18732:16102829] 属性名称: debugDescription\n2019-06-15 18:26:12.605645+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.605936+0800 RuntimDemo[18732:16102829] 属性array\n2019-06-15 18:26:12.606183+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.606395+0800 RuntimDemo[18732:16102829] 方法签名: method2\n2019-06-15 18:26:12.606628+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.606834+0800 RuntimDemo[18732:16102829] 方法签名: method4WithArg1:arg2:\n2019-06-15 18:26:12.607034+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.607246+0800 RuntimDemo[18732:16102829] 方法签名: method1\n2019-06-15 18:26:12.607447+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.607663+0800 RuntimDemo[18732:16102829] 方法签名: runtimeClassProtocol\n2019-06-15 18:26:12.607879+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.608107+0800 RuntimDemo[18732:16102829] 方法签名: method3\n2019-06-15 18:26:12.608328+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.608544+0800 RuntimDemo[18732:16102829] 方法签名: categoryMethod\n2019-06-15 18:26:12.608751+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.609075+0800 RuntimDemo[18732:16102829] 方法签名: setArray:\n2019-06-15 18:26:12.609301+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.609538+0800 RuntimDemo[18732:16102829] 方法签名: .cxx_destruct\n2019-06-15 18:26:12.609716+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.609900+0800 RuntimDemo[18732:16102829] 方法签名: array\n2019-06-15 18:26:12.610099+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.610279+0800 RuntimDemo[18732:16102829] 方法签名: setString:\n2019-06-15 18:26:12.610425+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.610653+0800 RuntimDemo[18732:16102829] 方法签名: string\n2019-06-15 18:26:12.610860+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.611082+0800 RuntimDemo[18732:16102829] 方法签名: index\n2019-06-15 18:26:12.611292+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.611517+0800 RuntimDemo[18732:16102829] 方法签名: setIndex:\n2019-06-15 18:26:12.611719+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.611945+0800 RuntimDemo[18732:16102829] 方法method2\n2019-06-15 18:26:12.612125+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.612359+0800 RuntimDemo[18732:16102829] 类方法 classMethod\n2019-06-15 18:26:12.612575+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.612797+0800 RuntimDemo[18732:16102829] RuntimClass响应方法method4WithArg1:arg2:\n2019-06-15 18:26:12.612966+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.613153+0800 RuntimDemo[18732:16102829] method1 被调用\n2019-06-15 18:26:12.613371+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.613612+0800 RuntimDemo[18732:16102829] 协议名称：RuntimeClassProtocol\n2019-06-15 18:26:12.613829+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.614063+0800 RuntimDemo[18732:16102829] 协议名称：NSCopying\n2019-06-15 18:26:12.614253+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.614446+0800 RuntimDemo[18732:16102829] 协议名称：NSCoding\n2019-06-15 18:26:12.614655+0800 RuntimDemo[18732:16102829] **********************************\n2019-06-15 18:26:12.614887+0800 RuntimDemo[18732:16102829] RuntimClass遵循协议NSCopying\n2019-06-15 18:26:12.615037+0800 RuntimDemo[18732:16102829] **********************************\n```\n\n### 5. 消息与消息转发\n#### (1) Method 基础数据结构：\n  Method 是 method_t 结构体的指针，method_t 在分析 method_list_t 已写出其结构，其结构中包括 SEL 和 IMP 两种数据结构。\n\n**SEL：**Objective-C 在编译的时候，objc_selector 会依据方法的名字、参数序列、生成一个整型标识的地址\n( int 类型的地址)：这个标识就是 SEL，其结构如下：\n\n```\n\ttypedef struct objc_selector *SEL\n```\n**IMP：**是一个函数指针，指向方法实现的地址。其结构如下：\n```\n\t/// A pointer to the function of a method implementation. \n\t#if !OBJC_OLD_DISPATCH_PROTOTYPES\n\ttypedef void (*IMP)(void /* id, SEL, ... */ ); \n\t#else\n\ttypedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); \n\t#endif\n```\n**SEL 和 IMP 为映射关系：**SEL 通过 Dispatch table 表寻找到对应的 IMP， Dispatch table 表存放 SEL 和 IMP 的映射。我们可以对一个编号 (SEL) 和什么方法 (IMP) 映射做些操作，也就是说我们可以一个 SEL 指向不同的函数指针，这样就可以完成一个方法名在不同时候执行不同的函数体。\n#### (2) 相关操作方法：\n```\n\t// 调用指定方法的实现，返回的是方法实现时的返回，参数 receiver 不能为空，这个比 method_getImplementation 和 method_getName 速度快\n\tvoid method_invoke_stret ( id receiver, Method m, ... )\n\n\t// 调用返回一个数据结构的方法的实现              \n\tid method_invoke ( id receiver, Method m, ... )           \n\n\t// 获取方法名，希望获得方法名的 C 字符串，使用 sel_getName(method_getName(method))          \n\tSEL method_getName ( Method m )                   \n\n\t// 返回方法的实现                  \n\tIMP method_getImplementation ( Method m )    \n\n\t// 获取描述方法参数和返回值类型的字符串                        \n\tconst char * method_getTypeEncoding ( Method m )    \n\n\t// 获取方法的返回值类型的字符串                 \n\tchar * method_copyReturnType ( Method m )         \n\n\t// 获取方法的指定位置参数的类型字符串                    \n\tchar * method_copyArgumentType ( Method m, unsigned int index )      \n\n\t// 通过引用返回方法的返回值类型字符串\n\tvoid method_getReturnType ( Method m, char *dst, size_t dst_len )    \n\n\t// 返回方法的参数的个数\n\tunsigned int method_getNumberOfArguments ( Method m )               \n\n\t// 通过引用返回方法指定位置参数的类型字符串\n\tvoid method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len )\n\n\t// 返回指定方法的方法描述结构体\n\tstruct objc_method_description * method_getDescription ( Method m )  \n\n\t// 设置方法的实现\n\tIMP method_setImplementation ( Method m, IMP imp )           \n\n\t// 交换两个方法的实现\n\tvoid method_exchangeImplementations ( Method m1, Method m2 )     \n\n\t// 返回给定选择器指定的方法的名称    \n\tconst char * sel_getName ( SEL sel )          \n\n\t// 返回 Runtime 系统中注册的方法，方法名映射的选择器                       \n\tSEL sel_registerName ( const char *str )                             \n\n\t// Runtime 系统中注册一个方法\n\tSEL sel_getUid ( const char *str )           \n\n\t// 比较两个选择器                        \n\tBOOL sel_isEqual ( SEL lhs, SEL rhs )                               \n```\n#### (4) Method 调用流程：\n**objc_msgSend 函数：** 这个函数将消息接收者和方法名作为基础参数。消息发送给一个对象时，objc_msgSend 通过对象的 isa 指针获得类的结构体，先在 Cache 里找，找到就执行，没找到就在分发列表里查找方法的 selector，没找到就通过 objc_msgSend 结构体中指向父类的指针找到父类，然后在父类分发列表找，直到 root class（NSObject）。Objc 中发送消息是用中括号把接收者和消息括起来，只到运行时才会把消息和方法实现绑定。为了加快速度，苹果对这个方法做了很多优化，这个方法是用汇编实现的。\nobjc_msgSend 定义如下：\n```\n\tobjc_msgSend(receiver, selector, arg1, arg2, ...)\n```\nobjc_msgSend 内部实现大致流程：首先在 Class 中的缓存查找 imp（没缓存则初始化缓存），如果没找到就去父类的 Class 查找，如果一直查到到根类仍旧没有实现，则用 *_objc_msgForward* 函数指针代替 imp， 最后执行 imp。 *_objc_msgForward*  是用于消息转发的，当方法没有被寻找到的时候，就会触发消息转发流程。\n\n**消息转发流程：**当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息，如果是以 [receiver message] 的方式调用方法，那么如果 receiver 无法响应 message 消息时，编译器就会报错。但如果是 perform... 的形式来调用，则需要等到运行时才能确定 receiver 是否能接受 message 消息。如果不能，则程序崩溃。消息转发的流程，可以分为三个阶段: 方法解析、重定向、消息转发。\n\n*tips:* 通常，当不能确定一个对象是否能接收某个消息时，会先调用 respondsToSelector: 来判断一下：\n```\nif ([self respondsToSelector:@selector(method)]) {\n    [self performSelector:@selector(method)];\n}\n```\n**方法解析：**当 runtime 在方法缓存列表和方法分发列表（包括超类）中找不到要执行的方法时，首先会进入方法解析阶段，此时可以在方法解析中动态添加方法实现。具体操作的函数如下：\n```\n\t// 实例方法找不到实现的情况，可以在方法解析中动态添加方法实现\n\t+ (BOOL)resolveInstanceMethod:(SEL)sel     \n\n\t//类方法找不到实现的情况，可以在方法解析中动态添加方法实现\n\t+ (BOOL)resolveClassMethod:(SEL)sel\n\n\t//动态添加一个方法，Class cls 是要指定的类，runtime 会到这个类中去找方法， SEL name 是要解析的方法，IMP 是动态添加的方法实现的 imp ，const char *types : 类型编码，是个字符串\n\tclass_addMethod(Class cls, SEL name, IMP imp, const char *types)      \n```\n[类型编码文档](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1)\n\n**重定向：**在消息转发机制执行前，系统会再给我们一次偷梁换柱的机会通过重载 *forwardingTargetForSelector* 方法替换消息的接受者为其他对象，毕竟消息转发需要耗费更多的时间，如果此方法返回 nil 或是 self，则会进入消息转发阶段。但是替换的对象千万不要是 self，那样会进入死循环。\n```\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    if (aSelector == @selector(mysteriousMethod:)) {\n       return alternateObject;\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n```\n**消息转发：**\n如果以上两种都没法处理未知消息就需要完整消息转发了，调用如下方法：\n``` \n\t//这一步是最后机会将消息转发给其它对象，对象会将未处理的消息相关的 selector，target 和参数都封装在 anInvocation 中。forwardInvocation :像未知消息分发中心，将未知消息转发给其它对象。注意的是 forwardInvocation: 方法只有在消息接收对象无法正常响应消息时才被调用。\n\t- (void)forwardInvocation:(NSInvocation *)anInvocation\n\n\t//必须重写这个方法，消息转发使用这个方法获得的信息创建 NSInvocation 对象。\n\t- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector\n```\n[消息转发更详细资料](http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/)\n\n#### (5) Method Swizzling：\nObjective-C 中的 Method Swizzling 允许我们动态地替换方法的实现，实现 Hook 功能，是一种比子类化更加灵活的“重写”方法的方式。讲 Method 结构的时候提到过：原则上方法的名称 name 和方法的实现 imp 是一一对应的，而 Method Swizzling 的原理就是动态地改变它们的对应关系，达到替换方法实现的目的，如下代码实现了 NSArray 异常操作的崩溃拦截功能：\n```\n#import \"NSArray+SafeArray.h\"\n#import <objc/runtime.h>\n\n/** \n 在 iOS 中 NSNumber、NSArray、NSDictionary 等这些类都是类簇，一个 NSArray 的实现可能由多个类组成。所以如果想对 NSArray 进行 Swizzling，必须获取到其“真身”进行 Swizzling，直接对 NSArray 进行操作是无效的。\n \n 下面列举了 NSArray 和 NSDictionary 本类的类名，可以通过Runtime函数取出本类。\n NSArray                __NSArrayI\n NSMutableArray         __NSArrayM\n NSDictionary           __NSDictionaryI\n NSMutableDictionary\t__NSDictionaryM\n */\n\n@implementation NSArray (SafeArray)\n\n// 注意下面的load方法中，不应该调用父类的load方法\n+ (void)load {\n    Method fromMethod = class_getInstanceMethod(objc_getClass(\"__NSArrayI\"), @selector(objectAtIndex:));\n    Method toMethod = class_getInstanceMethod(objc_getClass(\"__NSArrayI\"), @selector(safe_objectAtIndex:));\n    method_exchangeImplementations(fromMethod, toMethod);\n}\n\n// 为了避免和系统的方法冲突在 swizzling 方法前面加前缀\n- (id)safe_objectAtIndex:(NSUInteger)index {\n    if (self.count-1 < index) {\n        // 如果越界就进入异常拦截\n        @try {\n            return [self safe_objectAtIndex:index];\n        }\n        @catch (NSException *exception) {\n            // 崩溃后收集日志\n            NSLog(@\"---------- %s Crash Because Method %s  ----------\\n\", class_getName(self.class), __func__);\n            NSLog(@\"%@\", [exception callStackSymbols]);\n            return nil;\n        }\n        @finally {}\n    } else {\n        // 如果没有问题，则正常进行方法调用\n        return [self safe_objectAtIndex:index];\n    }\n}\n@end\n\n```\n**使用 Method Swizzling 注意的点：**\n\n**1 ）在 +load 方法中实现 Method Swizzling 的逻辑而不是在 +initialize ：**\n\n+load 和 +initialize 是 Objective-C runtime 会自动调用的两个类方法，但是它们的调用时机是不一样的。+load 方法是在类被加载的时候调用的，而 +initialize 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法调用。也就是说 +initialize 方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 +initialize 方法是永远不会被调用的。此外 +load 方法还有一个非常重要的特性，那就是子类、父类和分类中的 +load 方法的实现是被区别对待的。也就是说在 Objective-C runtime 自动调用 +load 方法时，分类中的 +load 方法并不会对主类中的 +load 方法造成覆盖。所以在 +load 方法是实现 Method Swizzling 逻辑是最佳选择。\n\n**2 ）用 dispatch_once 来进行调度：**\n\n+load 方法在类加载的时候会被 runtime 自动调用一次，但是它并没有限制程序员对 +load 方法的手动调用，所以使用 dispatch_once 确保代码不管有多少线程都只被执行一次。\n\n**3 ）需要调用 class_addMethod 方法，并且以它的结果为依据分别处理两种不同的情况：**\n\n使用 Method Swizzling 的目的通常都是为了给程序增加功能，而不是完全替换某个功能，所以我们一般都需要在自定义的实现中调用原始的实现，所以这里就会有两种情况需要我们分别进行处理：\n\n*第一种情况：*主类本身有实现需要替换的方法，也就是 class_addMethod 方法返回 NO 时，直接交换两个方法的实现就可以了。\n\n*第二种情况：*主类本身没有实现需要替换的方法，而是继承了父类的实现，即 class_addMethod 方法返回 YES。这时调用 class_getInstanceMethod 函数获取到的 originalSelector 指向的就是父类的方法，我们再通过执行 lass_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); 将父类的实现替换到我们自定义的方法中，这样就达到了在自定义方法的实现中调用父类实现的目的。\n\n**4）Selector，Method 和 Implementation 的关系：**\n\n一个类维护一个运行时可接收的消息分发表，分发表中每个入口是一个 Method，其中 key 是一个特定的名称即 SEL，与其对应的实现是 IMP 即指向底层 C 函数的指针。\n\n[Runtime Method Swizzling 开发实例汇总](https://juejin.im/entry/584912648e450a006c4be90a)\n### 6. Category 和 Protocol\n#### (1) Category 数据结构：\n```\nstruct category_t {\n    const char *name; \n    classref_t cls;\n    struct method_list_t *instanceMethods;         // 实例方法列表\n    struct method_list_t *classMethods;            // 类方法列表，Meta Class方法列表的子集\n    struct protocol_list_t *protocols;             // 分类所实现的协议列表\n    struct property_list_t *instanceProperties;    \n    // Fields below this point are not always present on disk.\n    struct property_list_t *_classProperties;      \n\n    method_list_t *methodsForMeta(bool isMeta) {\n        if (isMeta) return classMethods;\n        else return instanceMethods;\n    }\n\n    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);\n};\n```\n#### (2) Category 的用途：\n\n 1 ) 给现有的类添加方法\n\n 2 ) 将一个类的实现拆分成多个独立的源文件\n\n 3 ) 声明私有的方法\n\n*注意:* Category 有一个非常容易误用的场景，那就是用 Category 来覆写父类或主类的方法。虽然目前 Objective-C 是允许这么做的，但是这种使用场景是非常不推荐的。使用 Category 来覆写方法有很多缺点，比如不能覆写 Category 中的方法、无法调用主类中的原始实现等，且很容易造成无法预估的行为。 \n#### (3) Category 的实现原理：\n1 ）在编译时期，会将 Category 中实现的方法生成一个结构体 method_list_t ，将声明的属性生成一个结构体 property_list_t ，然后通过这些结构体生成一个结构体 category_t 并保存。\n\n2 ）在运行时期，Runtime 会拿到编译时期我们保存下来的结构体 category_t 然后将结构体 category_t 中的实例方法列表、协议列表、属性列表添加到主类中。\n\n3 ）将结构体 category_t 中的类方法列表、协议列表添加到主类的 metaClass 中。\n\n*注意点 (1)：*category_t 中的方法列表是插入到主类的方法列表前面，所以这里 Category 中实现的方法并不会真正的覆盖掉主类中的方法，只是将 Category 的方法插到方法列表的前面去了，运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会停止查找，即会出现覆盖方法的这种假象了。\n\n*注意点 (2)：*Category 添加实例变量，因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局。\n\n关键代码在 objc-runtime-new.mm 中的 _read_images 方法中实现，如下：\n```\n/***********************************************************************\n* _read_images\n* Perform initial processing of the headers in the linked \n* list beginning with headerList. \n*\n* Called by: map_images_nolock\n*\n* Locking: runtimeLock acquired by map_images\n**********************************************************************/\nvoid _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)\n{\n    header_info *hi;\n    uint32_t hIndex;\n    size_t count;\n    size_t i;\n    Class *resolvedFutureClasses = nil;\n    size_t resolvedFutureClassCount = 0;\n    static bool doneOnce;\n    TimeLogger ts(PrintImageTimes);\n\n    runtimeLock.assertLocked();\n\n#define EACH_HEADER \\\n    hIndex = 0;         \\\n    hIndex < hCount && (hi = hList[hIndex]); \\\n    hIndex++\n\n    if (!doneOnce) {\n        doneOnce = YES;\n\n        if (DisableTaggedPointers) {\n            disableTaggedPointers();\n        }\n        \n        initializeTaggedPointerObfuscator();\n\n        if (PrintConnecting) {\n            _objc_inform(\"CLASS: found %d classes during launch\", totalClasses);\n        }\n\n        // namedClasses\n        // Preoptimized classes don't go in this table.\n        // 4/3 is NXMapTable's load factor\n        int namedClassesSize = \n            (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * 4 / 3;\n        gdb_objc_realized_classes =\n            NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);\n        \n        allocatedClasses = NXCreateHashTable(NXPtrPrototype, 0, nil);\n        \n        ts.log(\"IMAGE TIMES: first time tasks\");\n    }\n\n    // Discover categories. \n    for (EACH_HEADER) {\n        category_t **catlist = \n            _getObjc2CategoryList(hi, &count);\n        bool hasClassProperties = hi->info()->hasCategoryClassProperties();\n\n        for (i = 0; i < count; i++) {\n            category_t *cat = catlist[i];\n            Class cls = remapClass(cat->cls);\n\n            if (!cls) {\n                // Category's target class is missing (probably weak-linked).\n                // Disavow any knowledge of this category.\n                catlist[i] = nil;\n                if (PrintConnecting) {\n                    _objc_inform(\"CLASS: IGNORING category \\?\\?\\?(%s) %p with \"\n                                 \"missing weak-linked target class\", \n                                 cat->name, cat);\n                }\n                continue;\n            }\n\n            // Process this category. \n            // First, register the category with its target class. \n            // Then, rebuild the class's method lists (etc) if \n            // the class is realized. \n            bool classExists = NO;\n            if (cat->instanceMethods ||  cat->protocols  \n                ||  cat->instanceProperties) \n            {\n                addUnattachedCategoryForClass(cat, cls, hi);\n                if (cls->isRealized()) {\n                    remethodizeClass(cls);\n                    classExists = YES;\n                }\n                if (PrintConnecting) {\n                    _objc_inform(\"CLASS: found category -%s(%s) %s\", \n                                 cls->nameForLogging(), cat->name, \n                                 classExists ? \"on existing class\" : \"\");\n                }\n            }\n\n            if (cat->classMethods  ||  cat->protocols  \n                ||  (hasClassProperties && cat->_classProperties)) \n            {\n                addUnattachedCategoryForClass(cat, cls->ISA(), hi);\n                if (cls->ISA()->isRealized()) {\n                    remethodizeClass(cls->ISA());\n                }\n                if (PrintConnecting) {\n                    _objc_inform(\"CLASS: found category +%s(%s)\", \n                                 cls->nameForLogging(), cat->name);\n                }\n            }\n        }\n    }\n\n    ts.log(\"IMAGE TIMES: discover categories\");\n#undef EACH_HEADER\n}\n```\n上面代码主要完成了一下以下几件事：\n\n1 ）将 Category 和它的主类（或元类）注册到哈希表中\n\n2 ）如果主类（或元类）已实现，那么重建它的方法列表\n\n3 ）Category 中的实例方法和属性被整合到主类中；而类方法则被整合到元类中\n\n4 ）对协议的处理比较特殊，Category 中的协议被同时整合到了主类和元类中\n\n上述代码中通过 static void remethodizeClass(Class cls) 函数来重新整理类的数据结构，代码如下：\n```\nstatic void remethodizeClass(Class cls)\n{\n    category_list *cats;\n    bool isMeta;\n\n    runtimeLock.assertLocked();\n\n    isMeta = cls->isMetaClass();\n\n    // Re-methodizing: check for more categories\n    if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) {\n        if (PrintConnecting) {\n            _objc_inform(\"CLASS: attaching categories to class '%s' %s\", \n                         cls->nameForLogging(), isMeta ? \"(meta)\" : \"\");\n        }\n        \n        attachCategories(cls, cats, true /*flush caches*/);        \n        free(cats);\n    }\n}\n```\n这个函数的主要作用是将 Category 中的方法、属性和协议整合到类（主类或元类）中，更新类的数据字段 data() 中 method_lists（或 method_list）、properties 和 protocols 的值。上述代码中真正处理 Category 的方法是 attachCategories 方法，源码如下：\n```\n// Attach method lists and properties and protocols from categories to a class.\n// Assumes the categories in cats are all loaded and sorted by load order, \n// oldest categories first.\nstatic void \nattachCategories(Class cls, category_list *cats, bool flush_caches)\n{\n    if (!cats) return;\n    if (PrintReplacedMethods) printReplacements(cls, cats);\n\n    bool isMeta = cls->isMetaClass();\n\n    // fixme rearrange to remove these intermediate allocations\n    method_list_t **mlists = (method_list_t **)\n        malloc(cats->count * sizeof(*mlists));\n    property_list_t **proplists = (property_list_t **)\n        malloc(cats->count * sizeof(*proplists));\n    protocol_list_t **protolists = (protocol_list_t **)\n        malloc(cats->count * sizeof(*protolists));\n\n    // Count backwards through cats to get newest categories first\n    int mcount = 0;\n    int propcount = 0;\n    int protocount = 0;\n    int i = cats->count;\n    bool fromBundle = NO;\n    while (i--) {\n        auto& entry = cats->list[i];\n\n        method_list_t *mlist = entry.cat->methodsForMeta(isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist;\n            fromBundle |= entry.hi->isBundle();\n        }\n\n        property_list_t *proplist = \n            entry.cat->propertiesForMeta(isMeta, entry.hi);\n        if (proplist) {\n            proplists[propcount++] = proplist;\n        }\n\n        protocol_list_t *protolist = entry.cat->protocols;\n        if (protolist) {\n            protolists[protocount++] = protolist;\n        }\n    }\n\n    auto rw = cls->data();\n\n    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);\n    rw->methods.attachLists(mlists, mcount);\n    free(mlists);\n    if (flush_caches  &&  mcount > 0) flushCaches(cls);\n\n    rw->properties.attachLists(proplists, propcount);\n    free(proplists);\n\n    rw->protocols.attachLists(protolists, protocount);\n    free(protolists);\n}\n```\n#### (4) Protocol\nProtocol 结构如下：\n```\ntypedef uintptr_t protocol_ref_t;  // protocol_t *, but unremapped\n```\nprotocol_ref_t 指向 protocol_t，而 protocol_t 继承自 objc_object，所以 Protocol 是对象结构体，protocol_t 关键结构如下：\n```\nstruct protocol_t : objc_object {\n    const char *mangledName;\n    struct protocol_list_t *protocols;\n    method_list_t *instanceMethods;\n    method_list_t *classMethods;\n    method_list_t *optionalInstanceMethods;\n    method_list_t *optionalClassMethods;\n    property_list_t *instanceProperties;\n    uint32_t size;   // sizeof(protocol_t)\n    uint32_t flags;\n    // Fields below this point are not always present on disk.\n    const char **_extendedMethodTypes;\n    const char *_demangledName;\n    property_list_t *_classProperties;\n}\n```\n\n#### (5) Category 和 Protocol 的操作方法\n```\n// 返回指定的协议\nProtocol * objc_getProtocol ( const char *name );\n\n// 获取运行时所知道的所有协议的数组\nProtocol ** objc_copyProtocolList ( unsigned int *outCount );\n\n// 创建新的协议实例\nProtocol * objc_allocateProtocol ( const char *name );\n\n// 在运行时中注册新创建的协议，创建一个新协议后必须使用这个进行注册这个新协议，但是注册后不能够再修改和添加新方法。\nvoid objc_registerProtocol ( Protocol *proto ); \n\n// 为协议添加方法\nvoid protocol_addMethodDescription ( Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod );\n\n// 添加一个已注册的协议到协议中\nvoid protocol_addProtocol ( Protocol *proto, Protocol *addition );\n\n// 为协议添加属性\nvoid protocol_addProperty ( Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty );\n\n// 返回协议名\nconst char * protocol_getName ( Protocol *p );\n\n// 测试两个协议是否相等\nBOOL protocol_isEqual ( Protocol *proto, Protocol *other );\n\n// 获取协议中指定条件的方法的方法描述数组\nstruct objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount );\n\n// 获取协议中指定方法的方法描述\nstruct objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod );\n\n// 获取协议中的属性列表\nobjc_property_t * protocol_copyPropertyList ( Protocol *proto, unsigned int *outCount );\n\n// 获取协议的指定属性\nobjc_property_t protocol_getProperty ( Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty );\n\n// 获取协议采用的协议\nProtocol ** protocol_copyProtocolList ( Protocol *proto, unsigned int *outCount );\n\n// 查看协议是否采用了另一个协议\nBOOL protocol_conformsToProtocol ( Protocol *proto, Protocol *other );\n```\n\n#### (7) Extention\n**Extention 格式如下：**\n```\n@interface ClassName()\n//私有属性\n//私有方法，如果不实现，编译时会报警\n@end\n```\n\n**(2) Extension 的作用**\n\n1 )  为一个类添加原来没有的变量、方法、属性\n2 )  一般的类扩展写到 .m 文件中\n3 )  一般的私有属性写到 .m 文件中的类扩展中\n\n**(3) Category 和 Extension 的区别**\n\n1 )  Category 中原则上只能增加方法（能添加属性的的原因只是通过 runtime 解决无 setter / getter 的问题而已）。Extension 不仅可以增加方法，还可以增加实例变量（或者属性），只是该实例变量默认是 Private 类型的。\n\n2 )  Extension 中声明的方法没被实现，编译器会报警，但是 Category 中的方法没被实现编译器是不会有任何警告的。Extention 添加的方法是在编译阶段被添加到类中，而 Category 添加的方法是在运行时添加到类中。所以相对于两者各有不同特性。\n\n3 )  Extention 不能像 Category 那样拥有独立的实现部分。也就是说，Extention 所声明的方法必须依托对应类的实现部分来实现。\n\n4 )  定义在 .m 文件中的 Extention 方法为私有的，Extention 是在 .m 文件中声明私有方法的非常好的方式。\n\n### 7. Runtime 的应用\n**(1) 利用 Method Swizzling 特性实现用户行为收集，预防数组字典越界奔溃， 代码解耦等**\n\n**(2) 获取系统提供的库相关信息**\n\n**(3) 为类动态添加方法**\n\n## Swift Runtime\n已查阅到的资料，待消化总结：\n\n[https://github.com/apple/swift/blob/master/docs/Runtime.md](https://github.com/apple/swift/blob/master/docs/Runtime.md)\n\n[https://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&mid=403068491&idx=1&sn=c95f07e3d38c92ba56933502cc3e1800#rd](https://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&mid=403068491&idx=1&sn=c95f07e3d38c92ba56933502cc3e1800#rd)\n\n[https://nshipster.com/swift-objc-runtime/](https://nshipster.com/swift-objc-runtime/)\n\n[https://academy.realm.io/posts/mobilization-roy-marmelstein-objective-c-runtime-swift-dynamic/](https://academy.realm.io/posts/mobilization-roy-marmelstein-objective-c-runtime-swift-dynamic/)","slug":"iOS-Runtime","published":1,"updated":"2019-06-19T03:13:41.157Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx2nwu2k000hu78ed7k1jl23","content":"<p>Runtime 总结相关示例代码：<a href=\"https://github.com/terryfine/BlogDemo/tree/master/RuntimDemo\" target=\"_blank\" rel=\"noopener\">https://github.com/terryfine/BlogDemo/tree/master/RuntimDemo</a></p>\n<h2 id=\"Objc-Runtime\"><a href=\"#Objc-Runtime\" class=\"headerlink\" title=\"Objc Runtime\"></a>Objc Runtime</h2><p>  源代码下载地址：<a href=\"http://www.opensource.apple.com/source/objc4/\" target=\"_blank\" rel=\"noopener\">http://www.opensource.apple.com/source/objc4/</a></p>\n<p>  Runtime 函数文档: <a href=\"https://developer.apple.com/documentation/objectivec/objective-c_runtime\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/documentation/objectivec/objective-c_runtime</a></p>\n<p>  苹果官方 Runtime 编程指南：<br>  <a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048</a></p>\n<h3 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1. 概念\"></a>1. 概念</h3><p> Objective-C 是一门动态语言，它将很多静态语言在编译和链接时做的事情推迟到运行时来处理。</p>\n<p> 这种动态特性意味着 Objective-C 不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。<br> 对于 Objective-C 来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。</p>\n<p> Runtime 就是使用 C 和汇编写的一个运行时库，一般我们说 Runtime，不但包含运行时库的意思，还包含了运行时、运行时系统等概念。</p>\n<p><strong>Objc Runtime 使得 C 具有了面向对象能力，可以在程序运行时创建、检查、修改类、对象和它们的方法</strong>。</p>\n<h3 id=\"2-Runtime-的作用：\"><a href=\"#2-Runtime-的作用：\" class=\"headerlink\" title=\"2. Runtime 的作用：\"></a>2. Runtime 的作用：</h3><h4 id=\"1-封装\"><a href=\"#1-封装\" class=\"headerlink\" title=\"(1) 封装\"></a>(1) 封装</h4><p> Runtime 库中，对象可以用 C 语言中的结构体表示，而方法可以用 C 函数来实现，再加上了一些其他的特性。这些结构体和函数被 runtime 函数封装后，就可以在程序运行时创建、检查、修改类、对象和它们的方法了。</p>\n<h3 id=\"2-找到方法的最终执行代码\"><a href=\"#2-找到方法的最终执行代码\" class=\"headerlink\" title=\"(2) 找到方法的最终执行代码\"></a>(2) 找到方法的最终执行代码</h3><p> 当程序中执行 [receiver message] 时，会向消息接收者（receiver）发送一条消息 message，runtime 会根据消息接收者是否能响应该消息而做出不同的反应，即消息转发的流程。</p>\n<h3 id=\"3-类和对象（Class-和-Object）相关的基本数据结构\"><a href=\"#3-类和对象（Class-和-Object）相关的基本数据结构\" class=\"headerlink\" title=\"3. 类和对象（Class 和 Object）相关的基本数据结构\"></a>3. 类和对象（Class 和 Object）相关的基本数据结构</h3><h4 id=\"1-关键词：\"><a href=\"#1-关键词：\" class=\"headerlink\" title=\"(1) 关键词：\"></a>(1) 关键词：</h4><p> Class：指向了 objc_class 结构体的指针<br>    id：参数类型，指向某个类实例的指针<br>    Method：代表了类中的某个方法的类型<br>    SEL：方法选择器，全名是 selector<br>    IMP：函数指针，由编译器生成，方法实现的代码就是由 IMP 指定<br>    Ivar：成员变量的类型<br>    Property：属性存储器<br>    Cache：方法调用的缓存器，为方法调用的性能进行优化</p>\n<h4 id=\"2-objc-class-和-objc-object-数据结构：\"><a href=\"#2-objc-class-和-objc-object-数据结构：\" class=\"headerlink\" title=\"(2) objc_class 和 objc_object 数据结构：\"></a>(2) objc_class 和 objc_object 数据结构：</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_class</span> *<span class=\"title\">Class</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_object</span> *<span class=\"title\">id</span>;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-objc-object-和-isa\"><a href=\"#3-objc-object-和-isa\" class=\"headerlink\" title=\"(3) objc_object 和 isa\"></a>(3) objc_object 和 isa</h4><p>objc_object 源代码在 objc-private.h line 75, 关键代码如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_object</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">isa_t</span> isa;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class=\"line\">    <span class=\"function\">Class <span class=\"title\">ISA</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// getIsa() allows this to be a tagged pointer object</span></span><br><span class=\"line\">    <span class=\"function\">Class <span class=\"title\">getIsa</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>objc_object 中的 isa，对应类型为联合体 isa_t，源代码在 objc-private.h line 61, 关键代码定义如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> nonpointer        : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//0:普通指针，1:优化过，使用位域存储更多信息</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> has_assoc         : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//对象是否含有或曾经含有关联引用</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> has_cxx_dtor      : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//表示是否有 C++ 析构函数或OC的 dealloc</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> shiftcls          : <span class=\"number\">44</span>; <span class=\"comment\">/*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/</span> \\         <span class=\"comment\">//存放着 Class、Meta-Class 对象的内存地址信息</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> magic             : <span class=\"number\">6</span>;                                         \\         <span class=\"comment\">//用于在调试时分辨对象是否未完成初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> weakly_referenced : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//是否被弱引用指向</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> deallocating      : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//对象是否正在释放</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> has_sidetable_rc  : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//是否需要使用 sidetable 来存储引用计数</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> extra_rc          : <span class=\"number\">8</span>                                                    <span class=\"comment\">//引用计数能够用 8 个二进制位存储时，直接存储在这里</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-objc-class\"><a href=\"#4-objc-class\" class=\"headerlink\" title=\"(4) objc_class\"></a>(4) objc_class</h4><p>objc_class 源代码可在 objc-runtime-new.h line 1111 看到，由于 objc_class 继承自 objc_object， 所以其关键结构可简化如下:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_class</span> :</span> objc_object &#123;</span><br><span class=\"line\">    <span class=\"keyword\">isa_t</span> isa;                 <span class=\"comment\">// Class ISA;</span></span><br><span class=\"line\">    Class superclass;</span><br><span class=\"line\">    <span class=\"keyword\">cache_t</span> cache;             <span class=\"comment\">// formerly cache pointer and vtable</span></span><br><span class=\"line\">    <span class=\"keyword\">class_data_bits_t</span> bits;    <span class=\"comment\">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">class_rw_t</span> *data() &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> bits.data();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>objc_object 用来描述 OC 中的实例，当用口语描述实例时，总会说 「XX类的实例x」或「x是XX的实例」。objc_object 的 isa 在程序结构上表达类似的含义，它指向了该实例所对应的类，类在 runtime 中被描述成 objc_class 结构。<br>Objective-C 中的类本质上也是对象，称之为类对象，在 Objective-C 中有一个非常特殊的类 NSObject ，绝大部分的类都继承自它。它是 Objective-C 中的两个根类（rootclass）之一，另外一个是 NSProxy。<br>NSObject 只有一个成员变量 isa。所有继承自 NSObject 的类也都会有这个成员变量。</p>\n<h4 id=\"5-元类（metaclass）、根类（root-class）、根元类（root-metaclass）\"><a href=\"#5-元类（metaclass）、根类（root-class）、根元类（root-metaclass）\" class=\"headerlink\" title=\"(5) 元类（metaclass）、根类（root class）、根元类（root metaclass）\"></a>(5) 元类（metaclass）、根类（root class）、根元类（root metaclass）</h4><p>本质上 Objective-C 中的类也是对象，它也是某个类的实例，这个类我们称之为元类（metaclass）。元类也是对象（元类对象），元类也是某个类的实例，这个类我们称之为根元类（root metaclass）。<br>不过，有一点比较特殊，那就是所有的元类所属的类都是同一个根元类（当然根元类也是元类，所以它所属的类也是根元类，即它本身）。根元类指的就是根类的元类，具体来说就是根类 NSObject 对应的元类。</p>\n<p>通过调用类方法，比如 [NSObject new]，给类对象发送消息。同样的，类对象能否响应这个消息也要通过 isa 找到类对象所属的类（元类）才能知道。也就是说，实例方法是保存在类中的，而类方法是保存在元类中的。理论上我们也可以给元类发送消息，但是 Objective-C 倾向于隐藏元类，不想让大家知道元类的存在。元类是为了保持 Objective-C 对象模型在设计上的完整性而引入的，比如用来保存类方法等，它主要是用来给编译器使用的。</p>\n<p>下图是为类（class），元类（metaclass），根类（root class），根元类（root metaclass）关系<br><img src=\"/2019/05/30/iOS-Runtime/object_model.png\" alt=\"\"></p>\n<h4 id=\"6-superclass\"><a href=\"#6-superclass\" class=\"headerlink\" title=\"(6) superclass\"></a>(6) superclass</h4><p>指向该类的父类，如果该类已经是最顶层的根类（如 NSObject 或 NSProxy），则 superclass 为 NULL。</p>\n<h4 id=\"7-cache-t\"><a href=\"#7-cache-t\" class=\"headerlink\" title=\"(7) cache_t\"></a>(7) cache_t</h4><p>cache_t 是一个散列表，用来缓存曾经调用过的方法，提高方法的查找速度。<br>源代码可在 objc-runtime-new.h line 59 找到，其关键结构如下:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cache_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket_t</span> *_<span class=\"title\">buckets</span>;</span>     <span class=\"comment\">// 散列表</span></span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> _mask;                  <span class=\"comment\">// 散列表的长度 -1</span></span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> _occupied;              <span class=\"comment\">// 已经缓存的方法数量</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">cache_key_t</span> _key;              <span class=\"comment\">// SEL 作为 key</span></span><br><span class=\"line\">    MethodCacheIMP _imp;           <span class=\"comment\">// 函数的内存地址</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>buckets：</strong>指向 Method 数据结构指针的数组。这个数组可能包含不超过 mask+1 个元素。需要注意的是，指针可能是 NULL，表示这个缓存 bucket 没有被占用，另外被占用的 bucket 可能是不连续的。这个数组可能会随着时间而增长。</p>\n<p><strong>mask：</strong>一个整数，指定分配的缓存 bucket 的总数。在方法查找过程中，Objective-C runtime 使用这个字段来确定开始线性查找数组的索引未知。指向方法 selector 的指针与该字段做一个 AND 位操作（index = (mask &amp; selector)）。这可以作为一个简单的 hash 散列算法。</p>\n<p><strong>occupied：</strong>一个整数，指定实际占用的缓存 bucket 的总数。</p>\n<h4 id=\"8-class-data-bits-t\"><a href=\"#8-class-data-bits-t\" class=\"headerlink\" title=\"(8) class_data_bits_t\"></a>(8) class_data_bits_t</h4><p>class_data_bits_t 是一个结构体，里面包含了一个 class_rw_t 类型的指针 data。class_rw_t 内部有个 class_ro_t 的指针 ro。class_rw_t 是可读可写的，class_ro_t 是只读的。 class_data_bits_t 源代码可以在 objc-runtime-new.h line 870 看到。</p>\n<p><strong>class_rw_t</strong> 结构如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">class_rw_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> flags;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> version;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">class_ro_t</span> *ro;             <span class=\"comment\">// 保存类的原始数据(不包含分类内容和动态添加的方法)</span></span><br><span class=\"line\">    <span class=\"keyword\">method_array_t</span> methods;           <span class=\"comment\">// 方法列表(如果是类对象存储的是对象方法,元类对象存储的是类方法)</span></span><br><span class=\"line\">    <span class=\"keyword\">property_array_t</span> properties;      <span class=\"comment\">// 属性列表</span></span><br><span class=\"line\">    <span class=\"keyword\">protocol_array_t</span> protocols;       <span class=\"comment\">// 协议列表</span></span><br><span class=\"line\">    Class firstSubclass;              <span class=\"comment\">// 第一个子类</span></span><br><span class=\"line\">    Class nextSiblingClass;           <span class=\"comment\">// 兄弟类</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>class_ro_t</strong> 储存了类的初始信息，不包括分类和后来动态添加的内容。class_ro_t 关键代码如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">class_ro_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> flags;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> instanceStart;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> instanceSize;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __LP64__</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> reserved;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">uint8_t</span> * ivarLayout;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * name;                    <span class=\"comment\">// 类名</span></span><br><span class=\"line\">    <span class=\"keyword\">method_list_t</span> * baseMethodList;       <span class=\"comment\">// 原始方法列表</span></span><br><span class=\"line\">    <span class=\"keyword\">protocol_list_t</span> * baseProtocols;      <span class=\"comment\">// 原始协议列表</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">ivar_list_t</span> * ivars;            <span class=\"comment\">// 成员变量列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">uint8_t</span> * weakIvarLayout;</span><br><span class=\"line\">    <span class=\"keyword\">property_list_t</span> *baseProperties;      <span class=\"comment\">// 属性列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">method_list_t</span> *baseMethods() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> baseMethodList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>method_list_t</strong> 数组包含了多个 method_t，其中 method_t 也是结构体 ，其关键结构如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">method_t</span> &#123;</span></span><br><span class=\"line\">    SEL name;               <span class=\"comment\">// 函数名</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types;      <span class=\"comment\">// 方法参数 (包含了返回值类型,参数类型)</span></span><br><span class=\"line\">    MethodListIMP imp;      <span class=\"comment\">// 方法的实现 (指向函数的指针)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>ivar_list_t</strong> 数组包含了多个 ivar_t 类型的结构体 ivar，ivar_t 结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ivar_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int32_t</span> *offset;               <span class=\"comment\">// 变量在内存中相对所属对象内存空间起始地址的偏移量,偏移量大小根据类型来定</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;              <span class=\"comment\">// 变量名</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *type;              <span class=\"comment\">// 变量类型</span></span><br><span class=\"line\">    <span class=\"comment\">// alignment is sometimes -1; use alignment() instead</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> alignment_raw;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> alignment() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (alignment_raw == ~(<span class=\"keyword\">uint32_t</span>)<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1U</span> &lt;&lt; WORD_SHIFT;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> &lt;&lt; alignment_raw;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>property_list_t</strong> 数组包含多个 property_t，property_t 结构如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">property_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;             </span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *attributes;        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>class_ro_t 包含的类信息（方法、属性、协议等）都是在编译期就可以确定的，暂且称为元信息吧，在之后的逻辑中，它们显然是不希望被改变的；后续在用户层，无论是方法还是别的扩展，都是在 class_rw_t 上进行操作，这些操作都不会影响类的元信息。更多关于 class_rw_t 和 class_ro_t 的资料可查看 <a href=\"https://zhangbuhuai.com/post/runtime.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</p>\n<h3 id=\"4-类和对象相关操作方法\"><a href=\"#4-类和对象相关操作方法\" class=\"headerlink\" title=\"4. 类和对象相关操作方法\"></a>4. 类和对象相关操作方法</h3><p>操作类相关的函数一般以 class 为前缀，操作对象相关函数以 objc 或 object_ 为前缀。可在开篇 Runtime 函数文档查看相关方法。</p>\n<h4 id=\"1-类相关操作函数\"><a href=\"#1-类相关操作函数\" class=\"headerlink\" title=\"(1) 类相关操作函数\"></a>(1) 类相关操作函数</h4><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const <span class=\"keyword\">char</span> * class_getName ( <span class=\"keyword\">Class</span> cls )           <span class=\"comment\">// 获取类名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Class</span> class_getSuperclass ( <span class=\"keyword\">Class</span> cls )            <span class=\"comment\">// 获取父类</span></span><br><span class=\"line\"></span><br><span class=\"line\">BOOL class_isMetaClass ( <span class=\"keyword\">Class</span> cls )               <span class=\"comment\">// 判断给定的类是不是元类</span></span><br><span class=\"line\"></span><br><span class=\"line\">size_t class_getInstanceSize ( <span class=\"keyword\">Class</span> cls )         <span class=\"comment\">// 获取类的实例大小</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> class_getVersion ( <span class=\"keyword\">Class</span> cls )                 <span class=\"comment\">// 获取版本号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> class_setVersion ( <span class=\"keyword\">Class</span> cls, <span class=\"keyword\">int</span> version )   <span class=\"comment\">// 设置版本号</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-成员变量-ivars-和属性相关操作函数\"><a href=\"#2-成员变量-ivars-和属性相关操作函数\" class=\"headerlink\" title=\"(2) 成员变量 (ivars) 和属性相关操作函数\"></a>(2) 成员变量 (ivars) 和属性相关操作函数</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Ivar <span class=\"title\">class_getInstanceVariable</span> <span class=\"params\">( Class cls, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name )</span>                                           <span class=\"comment\">// 获取类中指定名称实例成员变量的信息</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">Ivar <span class=\"title\">class_getClassVariable</span> <span class=\"params\">( Class cls, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name )</span>                                              <span class=\"comment\">// 获取类成员变量的信息</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">class_addIvar</span> <span class=\"params\">( Class cls, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">uint8_t</span> alignment, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types )</span>    <span class=\"comment\">// 在 runtime 时创建的类添加成员变量</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">Ivar * <span class=\"title\">class_copyIvarList</span> <span class=\"params\">( Class cls, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *outCount )</span>                                          <span class=\"comment\">// 获取整个成员变量列表，必须使用 free() 来释放</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-method-相关操作函数\"><a href=\"#3-method-相关操作函数\" class=\"headerlink\" title=\"(3) method 相关操作函数\"></a>(3) method 相关操作函数</h4><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BOOL class_addMethod ( <span class=\"keyword\">Class</span> cls, SEL name, IMP imp, <span class=\"keyword\">const</span> char *types )       <span class=\"comment\">// 添加方法，和成员变量不同的是可以为类动态添加方法。如果有同名会返回 NO，修改的话需要使用 method_setImplementation</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">Method</span> <span class=\"title\">class_getInstanceMethod</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL name )</span>                         // 获取实例方法</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Method</span> <span class=\"title\">class_getClassMethod</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL name )</span>                            // 获取类方法</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Method</span> * <span class=\"title\">class_copyMethodList</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, unsigned int *outCount )</span>            // 获取所有方法</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">IMP</span> <span class=\"title\">class_replaceMethod</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL name, IMP imp, <span class=\"keyword\">const</span> char *types )</span>    // 实现替换方法</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">IMP</span> <span class=\"title\">class_getMethodImplementation</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL name )</span>                      // 返回方法的具体实现</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">IMP</span> <span class=\"title\">class_getMethodImplementation_stret</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL name )</span>                // 返回方法的具体实现</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">BOOL</span> <span class=\"title\">class_respondsToSelector</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL sel )</span>                           // 类实例是否响应指定的 <span class=\"title\">selector</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"4-protocol-相关操作函数\"><a href=\"#4-protocol-相关操作函数\" class=\"headerlink\" title=\"(4) protocol 相关操作函数\"></a>(4) protocol 相关操作函数</h4><figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">BOOL</span> class_addProtocol ( Class <span class=\"keyword\">cls</span>, Protocol *protocol )                       <span class=\"comment\">// 添加协议</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">BOOL</span> class_conformsToProtocol ( Class <span class=\"keyword\">cls</span>, Protocol *protocol )                <span class=\"comment\">// 返回类是否实现指定的协议</span></span><br><span class=\"line\"></span><br><span class=\"line\">Protocol * class_copyProtocolList ( Class <span class=\"keyword\">cls</span>, unsigned int *outCount )        <span class=\"comment\">// 获取类实现的协议列表</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"5-相关示例代码及输出：\"><a href=\"#5-相关示例代码及输出：\" class=\"headerlink\" title=\"(5) 相关示例代码及输出：\"></a>(5) 相关示例代码及输出：</h4><figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> RuntimClass *runtimeClass = [[RuntimClass alloc] init]<span class=\"comment\">;</span></span><br><span class=\"line\"> Class cls = runtimeClass.class<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> // 类名</span><br><span class=\"line\"> const char *clsName = class_getName(cls)<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"类名：%s\", clsName)<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> // 父类</span><br><span class=\"line\"> Class superCls = class_getSuperclass(cls)<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"父类名：%s\", class_getName(superCls))<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> // 元类</span><br><span class=\"line\"> BOOL isMetaCls = class_isMetaClass(cls)<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"%s %@元类\", clsName, (isMetaCls ? @\"是\" : @\"不是\"))<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> Class metaCls = objc_getMetaClass(class_getName(cls))<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"%s的元类是：%s\", clsName, class_getName(metaCls))<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> // 变量实例大小</span><br><span class=\"line\"> size_t instanceSize = class_getInstanceSize(cls)<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"%s的所有实例变量大小：%zu\",clsName ,instanceSize)<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> // 成员变量</span><br><span class=\"line\"> unsigned int outCount = <span class=\"number\">0</span><span class=\"comment\">;</span></span><br><span class=\"line\"> Ivar *ivars = class_copyIvarList(cls, &amp;outCount)<span class=\"comment\">;</span></span><br><span class=\"line\"> for (int i = <span class=\"number\">0</span><span class=\"comment\">; i &lt; outCount; i++) &#123;</span></span><br><span class=\"line\">     Ivar ivar = ivars[i]<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"成员变量%s在第%d的位置\", ivar_getName(ivar), i)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> free(ivars)<span class=\"comment\">;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> Ivar ivar = class_getInstanceVariable(cls, \"_array\")<span class=\"comment\">;</span></span><br><span class=\"line\"> if (ivar != NULL) &#123;</span><br><span class=\"line\">     const char *ivarName = ivar_getName(ivar)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"成员变量：%s\", ivarName)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125; else &#123;</span><br><span class=\"line\">     NSLog(@\"没有此成员变量\")<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> // 属性</span><br><span class=\"line\"> objc_property_t *properties = class_copyPropertyList(cls, &amp;outCount)<span class=\"comment\">;</span></span><br><span class=\"line\"> for (int i = <span class=\"number\">0</span><span class=\"comment\">; i &lt; outCount; i++) &#123;</span></span><br><span class=\"line\">     objc_property_t property = properties[i]<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"属性名称: %s\", property_getName(property))<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> free(properties)<span class=\"comment\">;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> objc_property_t arrayProperty = class_getProperty(cls, \"array\")<span class=\"comment\">;</span></span><br><span class=\"line\"> if (arrayProperty != NULL) &#123;</span><br><span class=\"line\">     const char *arryPropertyName = property_getName(arrayProperty)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"属性%s\", arryPropertyName)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> //方法</span><br><span class=\"line\"> Method *methods = class_copyMethodList(cls, &amp;outCount)<span class=\"comment\">;   //包含category添加的方法</span></span><br><span class=\"line\"> for (int i = <span class=\"number\">0</span><span class=\"comment\">; i &lt; outCount; i++) &#123;</span></span><br><span class=\"line\">     Method method = methods[i]<span class=\"comment\">;</span></span><br><span class=\"line\">     SEL methodSignature = method_getName(method)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"方法签名: %s\", methodSignature)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> free(methods)<span class=\"comment\">;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> Method method1 = class_getInstanceMethod(cls, @selector(method2))<span class=\"comment\">;</span></span><br><span class=\"line\"> if (method1 != NULL) &#123;</span><br><span class=\"line\">     SEL method1Signature = method_getName(method1)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"方法%s\",method1Signature)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125; else &#123;</span><br><span class=\"line\">     NSLog(@\"未找到此方法\")<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> Method classMethod = class_getClassMethod(cls, @selector(classMethod))<span class=\"comment\">;</span></span><br><span class=\"line\"> if (classMethod != NULL) &#123;</span><br><span class=\"line\">     SEL classMethodName = method_getName(classMethod)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"类方法 %s\", classMethodName)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> BOOL responds = class_respondsToSelector(cls, @selector(method4WithArg1:arg2:))<span class=\"comment\">;</span></span><br><span class=\"line\"> if (responds) &#123;</span><br><span class=\"line\">     Method respondsMethod = class_getInstanceMethod(cls, @selector(method4WithArg1:arg2:))<span class=\"comment\">;</span></span><br><span class=\"line\">     SEL respondsMethodName = method_getName(respondsMethod)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"%s响应方法%s\", clsName, respondsMethodName)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125; else &#123;</span><br><span class=\"line\">     NSLog(@\"%s不响应此方法\", clsName)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> IMP imp = class_getMethodImplementation(cls, @selector(method1))<span class=\"comment\">;</span></span><br><span class=\"line\"> imp()<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> // 协议</span><br><span class=\"line\"> Protocol __unsafe_unretained **protocols = class_copyProtocolList(cls, &amp;outCount)<span class=\"comment\">;</span></span><br><span class=\"line\"> for (int i = <span class=\"number\">0</span><span class=\"comment\">; i &lt; outCount; i++) &#123;</span></span><br><span class=\"line\">     Protocol * protocol = protocols[i]<span class=\"comment\">;</span></span><br><span class=\"line\">     const char *protocalName = protocol_getName(protocol)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"协议名称：%s\", protocalName)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> Protocol * protocol = protocols[<span class=\"number\">1</span>]<span class=\"comment\">;</span></span><br><span class=\"line\"> BOOL conformProtocol = class_conformsToProtocol(cls, protocol)<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"%s%@遵循协议%s\", clsName, (conformProtocol ? @\"\" : @\"不\"), protocol_getName(protocol))<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">输出日志如下：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.595856</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 类名：RuntimClass</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.596386</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.596500</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 父类名：NSObject</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.596584</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.596721</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] RuntimClass 不是元类</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.596798</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.596890</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] RuntimClass的元类是：RuntimClass</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.596966</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.597060</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] RuntimClass的所有实例变量大小：<span class=\"number\">56</span></span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.597136</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.597251</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 成员变量firstInstance在第<span class=\"number\">0</span>的位置</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.597429</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.597622</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 成员变量secondInstance在第<span class=\"number\">1</span>的位置</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.597803</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.601663</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 成员变量thirdInstance在第<span class=\"number\">2</span>的位置</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.601739</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.601823</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 成员变量_array在第<span class=\"number\">3</span>的位置</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.601888</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.601965</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 成员变量_string在第<span class=\"number\">4</span>的位置</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.602033</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.602106</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 成员变量_index在第<span class=\"number\">5</span>的位置</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.602168</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.602479</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 成员变量：_array</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.602681</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.602908</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 属性名称: array</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.603056</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.603266</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 属性名称: string</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.603464</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.603662</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 属性名称: index</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.603887</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.604116</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 属性名称: hash</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.604339</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.604568</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 属性名称: superclass</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.604777</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.604990</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 属性名称: description</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.605190</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.605425</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 属性名称: debugDescription</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.605645</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.605936</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 属性array</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.606183</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.606395</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: method2</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.606628</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.606834</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: method4WithArg1:arg2:</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.607034</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.607246</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: method1</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.607447</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.607663</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: runtimeClassProtocol</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.607879</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.608107</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: method3</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.608328</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.608544</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: categoryMethod</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.608751</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.609075</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: setArray:</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.609301</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.609538</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: .cxx_destruct</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.609716</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.609900</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: array</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.610099</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.610279</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: setString:</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.610425</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.610653</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: string</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.610860</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.611082</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: index</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.611292</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.611517</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: setIndex:</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.611719</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.611945</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法method2</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.612125</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.612359</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 类方法 classMethod</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.612575</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.612797</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] RuntimClass响应方法method4WithArg1:arg2:</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.612966</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.613153</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] method1 被调用</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.613371</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.613612</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 协议名称：RuntimeClassProtocol</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.613829</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.614063</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 协议名称：NSCopying</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.614253</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.614446</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 协议名称：NSCoding</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.614655</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.614887</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] RuntimClass遵循协议NSCopying</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.615037</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-消息与消息转发\"><a href=\"#5-消息与消息转发\" class=\"headerlink\" title=\"5. 消息与消息转发\"></a>5. 消息与消息转发</h3><h4 id=\"1-Method-基础数据结构：\"><a href=\"#1-Method-基础数据结构：\" class=\"headerlink\" title=\"(1) Method 基础数据结构：\"></a>(1) Method 基础数据结构：</h4><p>  Method 是 method_t 结构体的指针，method_t 在分析 method_list_t 已写出其结构，其结构中包括 SEL 和 IMP 两种数据结构。</p>\n<p><strong>SEL：</strong>Objective-C 在编译的时候，objc_selector 会依据方法的名字、参数序列、生成一个整型标识的地址<br>( int 类型的地址)：这个标识就是 SEL，其结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_selector</span> *<span class=\"title\">SEL</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>IMP：</strong>是一个函数指针，指向方法实现的地址。其结构如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// A pointer to the function of a method implementation. </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*IMP)</span><span class=\"params\">(<span class=\"keyword\">void</span> <span class=\"comment\">/* id, SEL, ... */</span> )</span></span>; </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong>SEL 和 IMP 为映射关系：</strong>SEL 通过 Dispatch table 表寻找到对应的 IMP， Dispatch table 表存放 SEL 和 IMP 的映射。我们可以对一个编号 (SEL) 和什么方法 (IMP) 映射做些操作，也就是说我们可以一个 SEL 指向不同的函数指针，这样就可以完成一个方法名在不同时候执行不同的函数体。</p>\n<h4 id=\"2-相关操作方法：\"><a href=\"#2-相关操作方法：\" class=\"headerlink\" title=\"(2) 相关操作方法：\"></a>(2) 相关操作方法：</h4><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用指定方法的实现，返回的是方法实现时的返回，参数 receiver 不能为空，这个比 method_getImplementation 和 method_getName 速度快</span></span><br><span class=\"line\">void method_invoke_stret ( id receiver, <span class=\"function\"><span class=\"keyword\">Method</span> <span class=\"title\">m</span>, ... )</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 调用返回一个数据结构的方法的实现              </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">id</span> <span class=\"title\">method_invoke</span> <span class=\"params\">( id receiver, <span class=\"keyword\">Method</span> m, ... )</span>           </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 获取方法名，希望获得方法名的 <span class=\"title\">C</span> 字符串，使用 <span class=\"title\">sel_getName</span><span class=\"params\">(method_getName(<span class=\"keyword\">method</span>)</span>)          </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">SEL</span> <span class=\"title\">method_getName</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m )</span>                   </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 返回方法的实现                  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">IMP</span> <span class=\"title\">method_getImplementation</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m )</span>    </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 获取描述方法参数和返回值类型的字符串                        </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">const</span> <span class=\"title\">char</span> * <span class=\"title\">method_getTypeEncoding</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m )</span>    </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 获取方法的返回值类型的字符串                 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">char</span> * <span class=\"title\">method_copyReturnType</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m )</span>         </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 获取方法的指定位置参数的类型字符串                    </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">char</span> * <span class=\"title\">method_copyArgumentType</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m, unsigned int <span class=\"keyword\">index</span> )</span>      </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 通过引用返回方法的返回值类型字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">void</span> <span class=\"title\">method_getReturnType</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m, char *dst, size_t dst_len )</span>    </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 返回方法的参数的个数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">unsigned</span> <span class=\"title\">int</span> <span class=\"title\">method_getNumberOfArguments</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m )</span>               </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 通过引用返回方法指定位置参数的类型字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">void</span> <span class=\"title\">method_getArgumentType</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m, unsigned int <span class=\"keyword\">index</span>, char *dst, size_t dst_len )</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 返回指定方法的方法描述结构体</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">struct</span> <span class=\"title\">objc_method_description</span> * <span class=\"title\">method_getDescription</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m )</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 设置方法的实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">IMP</span> <span class=\"title\">method_setImplementation</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m, IMP imp )</span>           </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 交换两个方法的实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">void</span> <span class=\"title\">method_exchangeImplementations</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m1, <span class=\"keyword\">Method</span> m2 )</span>     </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 返回给定选择器指定的方法的名称    </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">const</span> <span class=\"title\">char</span> * <span class=\"title\">sel_getName</span> <span class=\"params\">( SEL sel )</span>          </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 返回 <span class=\"title\">Runtime</span> 系统中注册的方法，方法名映射的选择器                       </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">SEL</span> <span class=\"title\">sel_registerName</span> <span class=\"params\">( <span class=\"keyword\">const</span> char *str )</span>                             </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">Runtime</span> 系统中注册一个方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">SEL</span> <span class=\"title\">sel_getUid</span> <span class=\"params\">( <span class=\"keyword\">const</span> char *str )</span>           </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 比较两个选择器                        </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">BOOL</span> <span class=\"title\">sel_isEqual</span> <span class=\"params\">( SEL lhs, SEL rhs )</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"4-Method-调用流程：\"><a href=\"#4-Method-调用流程：\" class=\"headerlink\" title=\"(4) Method 调用流程：\"></a>(4) Method 调用流程：</h4><p><strong>objc_msgSend 函数：</strong> 这个函数将消息接收者和方法名作为基础参数。消息发送给一个对象时，objc_msgSend 通过对象的 isa 指针获得类的结构体，先在 Cache 里找，找到就执行，没找到就在分发列表里查找方法的 selector，没找到就通过 objc_msgSend 结构体中指向父类的指针找到父类，然后在父类分发列表找，直到 root class（NSObject）。Objc 中发送消息是用中括号把接收者和消息括起来，只到运行时才会把消息和方法实现绑定。为了加快速度，苹果对这个方法做了很多优化，这个方法是用汇编实现的。<br>objc_msgSend 定义如下：<br><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">objc_msgSend</span>(<span class=\"params\">receiver, selector, arg1, arg2, ...</span>)</span></span><br></pre></td></tr></table></figure></p>\n<p>objc_msgSend 内部实现大致流程：首先在 Class 中的缓存查找 imp（没缓存则初始化缓存），如果没找到就去父类的 Class 查找，如果一直查到到根类仍旧没有实现，则用 <em>_objc_msgForward</em> 函数指针代替 imp， 最后执行 imp。 <em>_objc_msgForward</em>  是用于消息转发的，当方法没有被寻找到的时候，就会触发消息转发流程。</p>\n<p><strong>消息转发流程：</strong>当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息，如果是以 [receiver message] 的方式调用方法，那么如果 receiver 无法响应 message 消息时，编译器就会报错。但如果是 perform… 的形式来调用，则需要等到运行时才能确定 receiver 是否能接受 message 消息。如果不能，则程序崩溃。消息转发的流程，可以分为三个阶段: 方法解析、重定向、消息转发。</p>\n<p><em>tips:</em> 通常，当不能确定一个对象是否能接收某个消息时，会先调用 respondsToSelector: 来判断一下：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">if</span> ([self <span class=\"attribute\">respondsToSelector</span>:<span class=\"variable\">@selector</span>(method)]) &#123;</span><br><span class=\"line\">    <span class=\"selector-attr\">[self performSelector:@selector(method)]</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>方法解析：</strong>当 runtime 在方法缓存列表和方法分发列表（包括超类）中找不到要执行的方法时，首先会进入方法解析阶段，此时可以在方法解析中动态添加方法实现。具体操作的函数如下：<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实例方法找不到实现的情况，可以在方法解析中动态添加方法实现</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel     </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//类方法找不到实现的情况，可以在方法解析中动态添加方法实现</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveClassMethod:(SEL)sel</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//动态添加一个方法，Class cls 是要指定的类，runtime 会到这个类中去找方法， SEL name 是要解析的方法，IMP 是动态添加的方法实现的 imp ，const char *types : 类型编码，是个字符串</span></span><br><span class=\"line\">class_addMethod(Class cls, SEL name, IMP imp, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types)</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1\" target=\"_blank\" rel=\"noopener\">类型编码文档</a></p>\n<p><strong>重定向：</strong>在消息转发机制执行前，系统会再给我们一次偷梁换柱的机会通过重载 <em>forwardingTargetForSelector</em> 方法替换消息的接受者为其他对象，毕竟消息转发需要耗费更多的时间，如果此方法返回 nil 或是 self，则会进入消息转发阶段。但是替换的对象千万不要是 self，那样会进入死循环。<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">-</span> (id)<span class=\"selector-tag\">forwardingTargetForSelector</span><span class=\"selector-pseudo\">:(SEL)aSelector</span> &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">if</span> (aSelector == <span class=\"variable\">@selector</span>(<span class=\"attribute\">mysteriousMethod</span>:)) &#123;</span><br><span class=\"line\">       <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">alternateObject</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> <span class=\"selector-attr\">[super forwardingTargetForSelector:aSelector]</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>消息转发：</strong><br>如果以上两种都没法处理未知消息就需要完整消息转发了，调用如下方法：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这一步是最后机会将消息转发给其它对象，对象会将未处理的消息相关的 selector，target 和参数都封装在 anInvocation 中。forwardInvocation :像未知消息分发中心，将未知消息转发给其它对象。注意的是 forwardInvocation: 方法只有在消息接收对象无法正常响应消息时才被调用。</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">forwardInvocation</span><span class=\"selector-pseudo\">:(NSInvocation</span> *)<span class=\"selector-tag\">anInvocation</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//必须重写这个方法，消息转发使用这个方法获得的信息创建 NSInvocation 对象。</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (NSMethodSignature *)<span class=\"selector-tag\">methodSignatureForSelector</span><span class=\"selector-pseudo\">:(SEL)aSelector</span></span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/\" target=\"_blank\" rel=\"noopener\">消息转发更详细资料</a></p>\n<h4 id=\"5-Method-Swizzling：\"><a href=\"#5-Method-Swizzling：\" class=\"headerlink\" title=\"(5) Method Swizzling：\"></a>(5) Method Swizzling：</h4><p>Objective-C 中的 Method Swizzling 允许我们动态地替换方法的实现，实现 Hook 功能，是一种比子类化更加灵活的“重写”方法的方式。讲 Method 结构的时候提到过：原则上方法的名称 name 和方法的实现 imp 是一一对应的，而 Method Swizzling 的原理就是动态地改变它们的对应关系，达到替换方法实现的目的，如下代码实现了 NSArray 异常操作的崩溃拦截功能：<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"NSArray+SafeArray.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> 在 iOS 中 NSNumber、NSArray、NSDictionary 等这些类都是类簇，一个 NSArray 的实现可能由多个类组成。所以如果想对 NSArray 进行 Swizzling，必须获取到其“真身”进行 Swizzling，直接对 NSArray 进行操作是无效的。</span></span><br><span class=\"line\"><span class=\"comment\"> </span></span><br><span class=\"line\"><span class=\"comment\"> 下面列举了 NSArray 和 NSDictionary 本类的类名，可以通过Runtime函数取出本类。</span></span><br><span class=\"line\"><span class=\"comment\"> NSArray                __NSArrayI</span></span><br><span class=\"line\"><span class=\"comment\"> NSMutableArray         __NSArrayM</span></span><br><span class=\"line\"><span class=\"comment\"> NSDictionary           __NSDictionaryI</span></span><br><span class=\"line\"><span class=\"comment\"> NSMutableDictionary\t__NSDictionaryM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSArray</span> (<span class=\"title\">SafeArray</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意下面的load方法中，不应该调用父类的load方法</span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)load &#123;</span><br><span class=\"line\">    Method fromMethod = class_getInstanceMethod(objc_getClass(<span class=\"string\">\"__NSArrayI\"</span>), <span class=\"keyword\">@selector</span>(objectAtIndex:));</span><br><span class=\"line\">    Method toMethod = class_getInstanceMethod(objc_getClass(<span class=\"string\">\"__NSArrayI\"</span>), <span class=\"keyword\">@selector</span>(safe_objectAtIndex:));</span><br><span class=\"line\">    method_exchangeImplementations(fromMethod, toMethod);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为了避免和系统的方法冲突在 swizzling 方法前面加前缀</span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)safe_objectAtIndex:(<span class=\"built_in\">NSUInteger</span>)index &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.count<span class=\"number\">-1</span> &lt; index) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果越界就进入异常拦截</span></span><br><span class=\"line\">        <span class=\"keyword\">@try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> safe_objectAtIndex:index];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">@catch</span> (<span class=\"built_in\">NSException</span> *exception) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 崩溃后收集日志</span></span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"---------- %s Crash Because Method %s  ----------\\n\"</span>, class_getName(<span class=\"keyword\">self</span>.class), __func__);</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [exception callStackSymbols]);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">@finally</span> &#123;&#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有问题，则正常进行方法调用</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> safe_objectAtIndex:index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>使用 Method Swizzling 注意的点：</strong></p>\n<p><strong>1 ）在 +load 方法中实现 Method Swizzling 的逻辑而不是在 +initialize ：</strong></p>\n<p>+load 和 +initialize 是 Objective-C runtime 会自动调用的两个类方法，但是它们的调用时机是不一样的。+load 方法是在类被加载的时候调用的，而 +initialize 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法调用。也就是说 +initialize 方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 +initialize 方法是永远不会被调用的。此外 +load 方法还有一个非常重要的特性，那就是子类、父类和分类中的 +load 方法的实现是被区别对待的。也就是说在 Objective-C runtime 自动调用 +load 方法时，分类中的 +load 方法并不会对主类中的 +load 方法造成覆盖。所以在 +load 方法是实现 Method Swizzling 逻辑是最佳选择。</p>\n<p><strong>2 ）用 dispatch_once 来进行调度：</strong></p>\n<p>+load 方法在类加载的时候会被 runtime 自动调用一次，但是它并没有限制程序员对 +load 方法的手动调用，所以使用 dispatch_once 确保代码不管有多少线程都只被执行一次。</p>\n<p><strong>3 ）需要调用 class_addMethod 方法，并且以它的结果为依据分别处理两种不同的情况：</strong></p>\n<p>使用 Method Swizzling 的目的通常都是为了给程序增加功能，而不是完全替换某个功能，所以我们一般都需要在自定义的实现中调用原始的实现，所以这里就会有两种情况需要我们分别进行处理：</p>\n<p><em>第一种情况：</em>主类本身有实现需要替换的方法，也就是 class_addMethod 方法返回 NO 时，直接交换两个方法的实现就可以了。</p>\n<p><em>第二种情况：</em>主类本身没有实现需要替换的方法，而是继承了父类的实现，即 class_addMethod 方法返回 YES。这时调用 class_getInstanceMethod 函数获取到的 originalSelector 指向的就是父类的方法，我们再通过执行 lass_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); 将父类的实现替换到我们自定义的方法中，这样就达到了在自定义方法的实现中调用父类实现的目的。</p>\n<p><strong>4）Selector，Method 和 Implementation 的关系：</strong></p>\n<p>一个类维护一个运行时可接收的消息分发表，分发表中每个入口是一个 Method，其中 key 是一个特定的名称即 SEL，与其对应的实现是 IMP 即指向底层 C 函数的指针。</p>\n<p><a href=\"https://juejin.im/entry/584912648e450a006c4be90a\" target=\"_blank\" rel=\"noopener\">Runtime Method Swizzling 开发实例汇总</a></p>\n<h3 id=\"6-Category-和-Protocol\"><a href=\"#6-Category-和-Protocol\" class=\"headerlink\" title=\"6. Category 和 Protocol\"></a>6. Category 和 Protocol</h3><h4 id=\"1-Category-数据结构：\"><a href=\"#1-Category-数据结构：\" class=\"headerlink\" title=\"(1) Category 数据结构：\"></a>(1) Category 数据结构：</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">category_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name; </span><br><span class=\"line\">    <span class=\"keyword\">classref_t</span> cls;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">method_list_t</span> *<span class=\"title\">instanceMethods</span>;</span>         <span class=\"comment\">// 实例方法列表</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">method_list_t</span> *<span class=\"title\">classMethods</span>;</span>            <span class=\"comment\">// 类方法列表，Meta Class方法列表的子集</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">protocol_list_t</span> *<span class=\"title\">protocols</span>;</span>             <span class=\"comment\">// 分类所实现的协议列表</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">property_list_t</span> *<span class=\"title\">instanceProperties</span>;</span>    </span><br><span class=\"line\">    <span class=\"comment\">// Fields below this point are not always present on disk.</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">property_list_t</span> *_<span class=\"title\">classProperties</span>;</span>      </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">method_list_t</span> *methodsForMeta(<span class=\"keyword\">bool</span> isMeta) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isMeta) <span class=\"keyword\">return</span> classMethods;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> instanceMethods;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">property_list_t</span> *propertiesForMeta(<span class=\"keyword\">bool</span> isMeta, struct header_info *hi);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-Category-的用途：\"><a href=\"#2-Category-的用途：\" class=\"headerlink\" title=\"(2) Category 的用途：\"></a>(2) Category 的用途：</h4><p> 1 ) 给现有的类添加方法</p>\n<p> 2 ) 将一个类的实现拆分成多个独立的源文件</p>\n<p> 3 ) 声明私有的方法</p>\n<p><em>注意:</em> Category 有一个非常容易误用的场景，那就是用 Category 来覆写父类或主类的方法。虽然目前 Objective-C 是允许这么做的，但是这种使用场景是非常不推荐的。使用 Category 来覆写方法有很多缺点，比如不能覆写 Category 中的方法、无法调用主类中的原始实现等，且很容易造成无法预估的行为。 </p>\n<h4 id=\"3-Category-的实现原理：\"><a href=\"#3-Category-的实现原理：\" class=\"headerlink\" title=\"(3) Category 的实现原理：\"></a>(3) Category 的实现原理：</h4><p>1 ）在编译时期，会将 Category 中实现的方法生成一个结构体 method_list_t ，将声明的属性生成一个结构体 property_list_t ，然后通过这些结构体生成一个结构体 category_t 并保存。</p>\n<p>2 ）在运行时期，Runtime 会拿到编译时期我们保存下来的结构体 category_t 然后将结构体 category_t 中的实例方法列表、协议列表、属性列表添加到主类中。</p>\n<p>3 ）将结构体 category_t 中的类方法列表、协议列表添加到主类的 metaClass 中。</p>\n<p><em>注意点 (1)：</em>category_t 中的方法列表是插入到主类的方法列表前面，所以这里 Category 中实现的方法并不会真正的覆盖掉主类中的方法，只是将 Category 的方法插到方法列表的前面去了，运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会停止查找，即会出现覆盖方法的这种假象了。</p>\n<p><em>注意点 (2)：</em>Category 添加实例变量，因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局。</p>\n<p>关键代码在 objc-runtime-new.mm 中的 _read_images 方法中实现，如下：<br><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/<span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span>*</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\"><span class=\"bullet\">* </span><span class=\"emphasis\">_read_</span>images</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\"><span class=\"bullet\">* </span>Perform initial processing of </span>the<span class=\"markdown\"> headers in </span>the<span class=\"markdown\"> linked </span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\"><span class=\"bullet\">* </span>list beginning with headerList. </span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">*</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\"><span class=\"bullet\">* </span>Called by: map<span class=\"emphasis\">_images_</span>nolock</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">*</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\"><span class=\"bullet\">* </span>Locking: runtimeLock acquired by map_images</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\"><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span>/</span></span></span><br><span class=\"line\"><span class=\"keyword\">void</span> _read_images(header_info **hList, uint32_t hCount, <span class=\"built_in\">int</span> totalClasses, <span class=\"built_in\">int</span> unoptimizedTotalClasses)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    header_info *hi;</span><br><span class=\"line\">    uint32_t hIndex;</span><br><span class=\"line\">    size_t count;</span><br><span class=\"line\">    size_t i;</span><br><span class=\"line\">    Class *resolvedFutureClasses = nil;</span><br><span class=\"line\">    size_t resolvedFutureClassCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> doneOnce;</span><br><span class=\"line\">    TimeLogger ts(PrintImageTimes);</span><br><span class=\"line\"></span><br><span class=\"line\">    runtimeLock.assertLocked();</span><br><span class=\"line\"></span><br><span class=\"line\">#define EACH_HEADER \\</span><br><span class=\"line\">    hIndex = <span class=\"number\">0</span>;         \\</span><br><span class=\"line\">    hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \\</span><br><span class=\"line\">    hIndex++</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!doneOnce) &#123;</span><br><span class=\"line\">        doneOnce = YES;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (DisableTaggedPointers) &#123;</span><br><span class=\"line\">            disableTaggedPointers();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        initializeTaggedPointerObfuscator();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PrintConnecting) &#123;</span><br><span class=\"line\">            _objc_inform(<span class=\"string\">\"CLASS: found %d classes during launch\"</span>, totalClasses);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// namedClasses</span></span><br><span class=\"line\">        <span class=\"comment\">// Preoptimized classes don't go in this table.</span></span><br><span class=\"line\">        <span class=\"comment\">// 4/3 is NXMapTable's load factor</span></span><br><span class=\"line\">        <span class=\"built_in\">int</span> namedClassesSize = </span><br><span class=\"line\">            (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * <span class=\"number\">4</span> / <span class=\"number\">3</span>;</span><br><span class=\"line\">        gdb_objc_realized_classes =</span><br><span class=\"line\">            NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);</span><br><span class=\"line\">        </span><br><span class=\"line\">        allocatedClasses = NXCreateHashTable(NXPtrPrototype, <span class=\"number\">0</span>, nil);</span><br><span class=\"line\">        </span><br><span class=\"line\">        ts.log(<span class=\"string\">\"IMAGE TIMES: first time tasks\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Discover categories. </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (EACH_HEADER) &#123;</span><br><span class=\"line\">        category_t **catlist = </span><br><span class=\"line\">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class=\"line\">        <span class=\"built_in\">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">            category_t *cat = catlist[i];</span><br><span class=\"line\">            Class cls = remapClass(cat-&gt;cls);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!cls) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Category's target class is missing (probably weak-linked).</span></span><br><span class=\"line\">                <span class=\"comment\">// Disavow any knowledge of this category.</span></span><br><span class=\"line\">                catlist[i] = nil;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (PrintConnecting) &#123;</span><br><span class=\"line\">                    _objc_inform(<span class=\"string\">\"CLASS: IGNORING category \\?\\?\\?(%s) %p with \"</span></span><br><span class=\"line\">                                 <span class=\"string\">\"missing weak-linked target class\"</span>, </span><br><span class=\"line\">                                 cat-&gt;name, cat);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Process this category. </span></span><br><span class=\"line\">            <span class=\"comment\">// First, register the category with its target class. </span></span><br><span class=\"line\">            <span class=\"comment\">// Then, rebuild the class's method lists (etc) if </span></span><br><span class=\"line\">            <span class=\"comment\">// the class is realized. </span></span><br><span class=\"line\">            <span class=\"built_in\">bool</span> classExists = NO;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class=\"line\">                ||  cat-&gt;instanceProperties) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class=\"line\">                    remethodizeClass(cls);</span><br><span class=\"line\">                    classExists = YES;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (PrintConnecting) &#123;</span><br><span class=\"line\">                    _objc_inform(<span class=\"string\">\"CLASS: found category -%s(%s) %s\"</span>, </span><br><span class=\"line\">                                 cls-&gt;nameForLogging(), cat-&gt;name, </span><br><span class=\"line\">                                 classExists ? <span class=\"string\">\"on existing class\"</span> : <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class=\"line\">                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class=\"line\">                    remethodizeClass(cls-&gt;ISA());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (PrintConnecting) &#123;</span><br><span class=\"line\">                    _objc_inform(<span class=\"string\">\"CLASS: found category +%s(%s)\"</span>, </span><br><span class=\"line\">                                 cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ts.log(<span class=\"string\">\"IMAGE TIMES: discover categories\"</span>);</span><br><span class=\"line\">#undef EACH_HEADER</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码主要完成了一下以下几件事：</p>\n<p>1 ）将 Category 和它的主类（或元类）注册到哈希表中</p>\n<p>2 ）如果主类（或元类）已实现，那么重建它的方法列表</p>\n<p>3 ）Category 中的实例方法和属性被整合到主类中；而类方法则被整合到元类中</p>\n<p>4 ）对协议的处理比较特殊，Category 中的协议被同时整合到了主类和元类中</p>\n<p>上述代码中通过 static void remethodizeClass(Class cls) 函数来重新整理类的数据结构，代码如下：<br><figure class=\"highlight zephir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> void remethodizeClass(<span class=\"class\"><span class=\"keyword\">Class</span> <span class=\"title\">cls</span>)</span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    category_list *cats;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isMeta;</span><br><span class=\"line\"></span><br><span class=\"line\">    runtimeLock.assertLocked();</span><br><span class=\"line\"></span><br><span class=\"line\">    isMeta = cls-&gt;isMetaClass();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Re-methodizing: check for more categories</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((cats = unattachedCategoriesForClass(cls, <span class=\"keyword\">false</span><span class=\"comment\">/*not realizing*/</span>))) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PrintConnecting) &#123;</span><br><span class=\"line\">            _objc_inform(<span class=\"string\">\"CLASS: attaching categories to class '%s' %s\"</span>, </span><br><span class=\"line\">                         cls-&gt;nameForLogging(), isMeta ? <span class=\"string\">\"(meta)\"</span> : <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        attachCategories(cls, cats, <span class=\"keyword\">true</span> <span class=\"comment\">/*flush caches*/</span>);        </span><br><span class=\"line\">        free(cats);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个函数的主要作用是将 Category 中的方法、属性和协议整合到类（主类或元类）中，更新类的数据字段 data() 中 method_lists（或 method_list）、properties 和 protocols 的值。上述代码中真正处理 Category 的方法是 attachCategories 方法，源码如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Attach method lists and properties and protocols from categories to a class.</span></span><br><span class=\"line\"><span class=\"comment\">// Assumes the categories in cats are all loaded and sorted by load order, </span></span><br><span class=\"line\"><span class=\"comment\">// oldest categories first.</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> </span><br><span class=\"line\">attachCategories(Class cls, category_list *cats, <span class=\"keyword\">bool</span> flush_caches)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cats) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// fixme rearrange to remove these intermediate allocations</span></span><br><span class=\"line\">    <span class=\"keyword\">method_list_t</span> **mlists = (<span class=\"keyword\">method_list_t</span> **)</span><br><span class=\"line\">        <span class=\"built_in\">malloc</span>(cats-&gt;count * <span class=\"keyword\">sizeof</span>(*mlists));</span><br><span class=\"line\">    <span class=\"keyword\">property_list_t</span> **proplists = (<span class=\"keyword\">property_list_t</span> **)</span><br><span class=\"line\">        <span class=\"built_in\">malloc</span>(cats-&gt;count * <span class=\"keyword\">sizeof</span>(*proplists));</span><br><span class=\"line\">    <span class=\"keyword\">protocol_list_t</span> **protolists = (<span class=\"keyword\">protocol_list_t</span> **)</span><br><span class=\"line\">        <span class=\"built_in\">malloc</span>(cats-&gt;count * <span class=\"keyword\">sizeof</span>(*protolists));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Count backwards through cats to get newest categories first</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mcount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> propcount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> protocount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = cats-&gt;count;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> fromBundle = NO;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span>&amp; entry = cats-&gt;<span class=\"built_in\">list</span>[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">method_list_t</span> *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mlist) &#123;</span><br><span class=\"line\">            mlists[mcount++] = mlist;</span><br><span class=\"line\">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">property_list_t</span> *proplist = </span><br><span class=\"line\">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (proplist) &#123;</span><br><span class=\"line\">            proplists[propcount++] = proplist;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">protocol_list_t</span> *protolist = entry.cat-&gt;protocols;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (protolist) &#123;</span><br><span class=\"line\">            protolists[protocount++] = protolist;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> rw = cls-&gt;data();</span><br><span class=\"line\"></span><br><span class=\"line\">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class=\"line\">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(mlists);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class=\"number\">0</span>) flushCaches(cls);</span><br><span class=\"line\"></span><br><span class=\"line\">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(proplists);</span><br><span class=\"line\"></span><br><span class=\"line\">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(protolists);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-Protocol\"><a href=\"#4-Protocol\" class=\"headerlink\" title=\"(4) Protocol\"></a>(4) Protocol</h4><p>Protocol 结构如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">uintptr_t</span> <span class=\"keyword\">protocol_ref_t</span>;  <span class=\"comment\">// protocol_t *, but unremapped</span></span><br></pre></td></tr></table></figure></p>\n<p>protocol_ref_t 指向 protocol_t，而 protocol_t 继承自 objc_object，所以 Protocol 是对象结构体，protocol_t 关键结构如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">protocol_t</span> :</span> objc_object &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *mangledName;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">protocol_list_t</span> *<span class=\"title\">protocols</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">method_list_t</span> *instanceMethods;</span><br><span class=\"line\">    <span class=\"keyword\">method_list_t</span> *classMethods;</span><br><span class=\"line\">    <span class=\"keyword\">method_list_t</span> *optionalInstanceMethods;</span><br><span class=\"line\">    <span class=\"keyword\">method_list_t</span> *optionalClassMethods;</span><br><span class=\"line\">    <span class=\"keyword\">property_list_t</span> *instanceProperties;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> size;   <span class=\"comment\">// sizeof(protocol_t)</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> flags;</span><br><span class=\"line\">    <span class=\"comment\">// Fields below this point are not always present on disk.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **_extendedMethodTypes;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *_demangledName;</span><br><span class=\"line\">    <span class=\"keyword\">property_list_t</span> *_classProperties;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-Category-和-Protocol-的操作方法\"><a href=\"#5-Category-和-Protocol-的操作方法\" class=\"headerlink\" title=\"(5) Category 和 Protocol 的操作方法\"></a>(5) Category 和 Protocol 的操作方法</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回指定的协议</span></span><br><span class=\"line\"><span class=\"function\">Protocol * <span class=\"title\">objc_getProtocol</span> <span class=\"params\">( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取运行时所知道的所有协议的数组</span></span><br><span class=\"line\"><span class=\"function\">Protocol ** <span class=\"title\">objc_copyProtocolList</span> <span class=\"params\">( <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *outCount )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建新的协议实例</span></span><br><span class=\"line\"><span class=\"function\">Protocol * <span class=\"title\">objc_allocateProtocol</span> <span class=\"params\">( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在运行时中注册新创建的协议，创建一个新协议后必须使用这个进行注册这个新协议，但是注册后不能够再修改和添加新方法。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">objc_registerProtocol</span> <span class=\"params\">( Protocol *proto )</span></span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为协议添加方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">protocol_addMethodDescription</span> <span class=\"params\">( Protocol *proto, SEL name, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types, BOOL isRequiredMethod, BOOL isInstanceMethod )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加一个已注册的协议到协议中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">protocol_addProtocol</span> <span class=\"params\">( Protocol *proto, Protocol *addition )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为协议添加属性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">protocol_addProperty</span> <span class=\"params\">( Protocol *proto, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, <span class=\"keyword\">const</span> <span class=\"keyword\">objc_property_attribute_t</span> *attributes, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回协议名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * <span class=\"title\">protocol_getName</span> <span class=\"params\">( Protocol *p )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试两个协议是否相等</span></span><br><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">protocol_isEqual</span> <span class=\"params\">( Protocol *proto, Protocol *other )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取协议中指定条件的方法的方法描述数组</span></span><br><span class=\"line\"><span class=\"function\">struct objc_method_description * <span class=\"title\">protocol_copyMethodDescriptionList</span> <span class=\"params\">( Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *outCount )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取协议中指定方法的方法描述</span></span><br><span class=\"line\"><span class=\"function\">struct objc_method_description <span class=\"title\">protocol_getMethodDescription</span> <span class=\"params\">( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取协议中的属性列表</span></span><br><span class=\"line\"><span class=\"keyword\">objc_property_t</span> * protocol_copyPropertyList ( Protocol *proto, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *outCount );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取协议的指定属性</span></span><br><span class=\"line\"><span class=\"keyword\">objc_property_t</span> protocol_getProperty ( Protocol *proto, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, BOOL isRequiredProperty, BOOL isInstanceProperty );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取协议采用的协议</span></span><br><span class=\"line\"><span class=\"function\">Protocol ** <span class=\"title\">protocol_copyProtocolList</span> <span class=\"params\">( Protocol *proto, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *outCount )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查看协议是否采用了另一个协议</span></span><br><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">protocol_conformsToProtocol</span> <span class=\"params\">( Protocol *proto, Protocol *other )</span></span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"7-Extention\"><a href=\"#7-Extention\" class=\"headerlink\" title=\"(7) Extention\"></a>(7) Extention</h4><p><strong>Extention 格式如下：</strong><br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@interface</span> ClassName()</span><br><span class=\"line\"><span class=\"comment\">//私有属性</span></span><br><span class=\"line\"><span class=\"comment\">//私有方法，如果不实现，编译时会报警</span></span><br><span class=\"line\"><span class=\"variable\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>(2) Extension 的作用</strong></p>\n<p>1 )  为一个类添加原来没有的变量、方法、属性<br>2 )  一般的类扩展写到 .m 文件中<br>3 )  一般的私有属性写到 .m 文件中的类扩展中</p>\n<p><strong>(3) Category 和 Extension 的区别</strong></p>\n<p>1 )  Category 中原则上只能增加方法（能添加属性的的原因只是通过 runtime 解决无 setter / getter 的问题而已）。Extension 不仅可以增加方法，还可以增加实例变量（或者属性），只是该实例变量默认是 Private 类型的。</p>\n<p>2 )  Extension 中声明的方法没被实现，编译器会报警，但是 Category 中的方法没被实现编译器是不会有任何警告的。Extention 添加的方法是在编译阶段被添加到类中，而 Category 添加的方法是在运行时添加到类中。所以相对于两者各有不同特性。</p>\n<p>3 )  Extention 不能像 Category 那样拥有独立的实现部分。也就是说，Extention 所声明的方法必须依托对应类的实现部分来实现。</p>\n<p>4 )  定义在 .m 文件中的 Extention 方法为私有的，Extention 是在 .m 文件中声明私有方法的非常好的方式。</p>\n<h3 id=\"7-Runtime-的应用\"><a href=\"#7-Runtime-的应用\" class=\"headerlink\" title=\"7. Runtime 的应用\"></a>7. Runtime 的应用</h3><p><strong>(1) 利用 Method Swizzling 特性实现用户行为收集，预防数组字典越界奔溃， 代码解耦等</strong></p>\n<p><strong>(2) 获取系统提供的库相关信息</strong></p>\n<p><strong>(3) 为类动态添加方法</strong></p>\n<h2 id=\"Swift-Runtime\"><a href=\"#Swift-Runtime\" class=\"headerlink\" title=\"Swift Runtime\"></a>Swift Runtime</h2><p>已查阅到的资料，待消化总结：</p>\n<p><a href=\"https://github.com/apple/swift/blob/master/docs/Runtime.md\" target=\"_blank\" rel=\"noopener\">https://github.com/apple/swift/blob/master/docs/Runtime.md</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&amp;mid=403068491&amp;idx=1&amp;sn=c95f07e3d38c92ba56933502cc3e1800#rd\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&amp;mid=403068491&amp;idx=1&amp;sn=c95f07e3d38c92ba56933502cc3e1800#rd</a></p>\n<p><a href=\"https://nshipster.com/swift-objc-runtime/\" target=\"_blank\" rel=\"noopener\">https://nshipster.com/swift-objc-runtime/</a></p>\n<p><a href=\"https://academy.realm.io/posts/mobilization-roy-marmelstein-objective-c-runtime-swift-dynamic/\" target=\"_blank\" rel=\"noopener\">https://academy.realm.io/posts/mobilization-roy-marmelstein-objective-c-runtime-swift-dynamic/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Runtime 总结相关示例代码：<a href=\"https://github.com/terryfine/BlogDemo/tree/master/RuntimDemo\" target=\"_blank\" rel=\"noopener\">https://github.com/terryfine/BlogDemo/tree/master/RuntimDemo</a></p>\n<h2 id=\"Objc-Runtime\"><a href=\"#Objc-Runtime\" class=\"headerlink\" title=\"Objc Runtime\"></a>Objc Runtime</h2><p>  源代码下载地址：<a href=\"http://www.opensource.apple.com/source/objc4/\" target=\"_blank\" rel=\"noopener\">http://www.opensource.apple.com/source/objc4/</a></p>\n<p>  Runtime 函数文档: <a href=\"https://developer.apple.com/documentation/objectivec/objective-c_runtime\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/documentation/objectivec/objective-c_runtime</a></p>\n<p>  苹果官方 Runtime 编程指南：<br>  <a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048</a></p>\n<h3 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1. 概念\"></a>1. 概念</h3><p> Objective-C 是一门动态语言，它将很多静态语言在编译和链接时做的事情推迟到运行时来处理。</p>\n<p> 这种动态特性意味着 Objective-C 不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。<br> 对于 Objective-C 来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。</p>\n<p> Runtime 就是使用 C 和汇编写的一个运行时库，一般我们说 Runtime，不但包含运行时库的意思，还包含了运行时、运行时系统等概念。</p>\n<p><strong>Objc Runtime 使得 C 具有了面向对象能力，可以在程序运行时创建、检查、修改类、对象和它们的方法</strong>。</p>\n<h3 id=\"2-Runtime-的作用：\"><a href=\"#2-Runtime-的作用：\" class=\"headerlink\" title=\"2. Runtime 的作用：\"></a>2. Runtime 的作用：</h3><h4 id=\"1-封装\"><a href=\"#1-封装\" class=\"headerlink\" title=\"(1) 封装\"></a>(1) 封装</h4><p> Runtime 库中，对象可以用 C 语言中的结构体表示，而方法可以用 C 函数来实现，再加上了一些其他的特性。这些结构体和函数被 runtime 函数封装后，就可以在程序运行时创建、检查、修改类、对象和它们的方法了。</p>\n<h3 id=\"2-找到方法的最终执行代码\"><a href=\"#2-找到方法的最终执行代码\" class=\"headerlink\" title=\"(2) 找到方法的最终执行代码\"></a>(2) 找到方法的最终执行代码</h3><p> 当程序中执行 [receiver message] 时，会向消息接收者（receiver）发送一条消息 message，runtime 会根据消息接收者是否能响应该消息而做出不同的反应，即消息转发的流程。</p>\n<h3 id=\"3-类和对象（Class-和-Object）相关的基本数据结构\"><a href=\"#3-类和对象（Class-和-Object）相关的基本数据结构\" class=\"headerlink\" title=\"3. 类和对象（Class 和 Object）相关的基本数据结构\"></a>3. 类和对象（Class 和 Object）相关的基本数据结构</h3><h4 id=\"1-关键词：\"><a href=\"#1-关键词：\" class=\"headerlink\" title=\"(1) 关键词：\"></a>(1) 关键词：</h4><p> Class：指向了 objc_class 结构体的指针<br>    id：参数类型，指向某个类实例的指针<br>    Method：代表了类中的某个方法的类型<br>    SEL：方法选择器，全名是 selector<br>    IMP：函数指针，由编译器生成，方法实现的代码就是由 IMP 指定<br>    Ivar：成员变量的类型<br>    Property：属性存储器<br>    Cache：方法调用的缓存器，为方法调用的性能进行优化</p>\n<h4 id=\"2-objc-class-和-objc-object-数据结构：\"><a href=\"#2-objc-class-和-objc-object-数据结构：\" class=\"headerlink\" title=\"(2) objc_class 和 objc_object 数据结构：\"></a>(2) objc_class 和 objc_object 数据结构：</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_class</span> *<span class=\"title\">Class</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_object</span> *<span class=\"title\">id</span>;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-objc-object-和-isa\"><a href=\"#3-objc-object-和-isa\" class=\"headerlink\" title=\"(3) objc_object 和 isa\"></a>(3) objc_object 和 isa</h4><p>objc_object 源代码在 objc-private.h line 75, 关键代码如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_object</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">isa_t</span> isa;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class=\"line\">    <span class=\"function\">Class <span class=\"title\">ISA</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// getIsa() allows this to be a tagged pointer object</span></span><br><span class=\"line\">    <span class=\"function\">Class <span class=\"title\">getIsa</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>objc_object 中的 isa，对应类型为联合体 isa_t，源代码在 objc-private.h line 61, 关键代码定义如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> nonpointer        : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//0:普通指针，1:优化过，使用位域存储更多信息</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> has_assoc         : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//对象是否含有或曾经含有关联引用</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> has_cxx_dtor      : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//表示是否有 C++ 析构函数或OC的 dealloc</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> shiftcls          : <span class=\"number\">44</span>; <span class=\"comment\">/*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/</span> \\         <span class=\"comment\">//存放着 Class、Meta-Class 对象的内存地址信息</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> magic             : <span class=\"number\">6</span>;                                         \\         <span class=\"comment\">//用于在调试时分辨对象是否未完成初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> weakly_referenced : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//是否被弱引用指向</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> deallocating      : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//对象是否正在释放</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> has_sidetable_rc  : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//是否需要使用 sidetable 来存储引用计数</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> extra_rc          : <span class=\"number\">8</span>                                                    <span class=\"comment\">//引用计数能够用 8 个二进制位存储时，直接存储在这里</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-objc-class\"><a href=\"#4-objc-class\" class=\"headerlink\" title=\"(4) objc_class\"></a>(4) objc_class</h4><p>objc_class 源代码可在 objc-runtime-new.h line 1111 看到，由于 objc_class 继承自 objc_object， 所以其关键结构可简化如下:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_class</span> :</span> objc_object &#123;</span><br><span class=\"line\">    <span class=\"keyword\">isa_t</span> isa;                 <span class=\"comment\">// Class ISA;</span></span><br><span class=\"line\">    Class superclass;</span><br><span class=\"line\">    <span class=\"keyword\">cache_t</span> cache;             <span class=\"comment\">// formerly cache pointer and vtable</span></span><br><span class=\"line\">    <span class=\"keyword\">class_data_bits_t</span> bits;    <span class=\"comment\">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">class_rw_t</span> *data() &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> bits.data();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>objc_object 用来描述 OC 中的实例，当用口语描述实例时，总会说 「XX类的实例x」或「x是XX的实例」。objc_object 的 isa 在程序结构上表达类似的含义，它指向了该实例所对应的类，类在 runtime 中被描述成 objc_class 结构。<br>Objective-C 中的类本质上也是对象，称之为类对象，在 Objective-C 中有一个非常特殊的类 NSObject ，绝大部分的类都继承自它。它是 Objective-C 中的两个根类（rootclass）之一，另外一个是 NSProxy。<br>NSObject 只有一个成员变量 isa。所有继承自 NSObject 的类也都会有这个成员变量。</p>\n<h4 id=\"5-元类（metaclass）、根类（root-class）、根元类（root-metaclass）\"><a href=\"#5-元类（metaclass）、根类（root-class）、根元类（root-metaclass）\" class=\"headerlink\" title=\"(5) 元类（metaclass）、根类（root class）、根元类（root metaclass）\"></a>(5) 元类（metaclass）、根类（root class）、根元类（root metaclass）</h4><p>本质上 Objective-C 中的类也是对象，它也是某个类的实例，这个类我们称之为元类（metaclass）。元类也是对象（元类对象），元类也是某个类的实例，这个类我们称之为根元类（root metaclass）。<br>不过，有一点比较特殊，那就是所有的元类所属的类都是同一个根元类（当然根元类也是元类，所以它所属的类也是根元类，即它本身）。根元类指的就是根类的元类，具体来说就是根类 NSObject 对应的元类。</p>\n<p>通过调用类方法，比如 [NSObject new]，给类对象发送消息。同样的，类对象能否响应这个消息也要通过 isa 找到类对象所属的类（元类）才能知道。也就是说，实例方法是保存在类中的，而类方法是保存在元类中的。理论上我们也可以给元类发送消息，但是 Objective-C 倾向于隐藏元类，不想让大家知道元类的存在。元类是为了保持 Objective-C 对象模型在设计上的完整性而引入的，比如用来保存类方法等，它主要是用来给编译器使用的。</p>\n<p>下图是为类（class），元类（metaclass），根类（root class），根元类（root metaclass）关系<br><img src=\"/2019/05/30/iOS-Runtime/object_model.png\" alt=\"\"></p>\n<h4 id=\"6-superclass\"><a href=\"#6-superclass\" class=\"headerlink\" title=\"(6) superclass\"></a>(6) superclass</h4><p>指向该类的父类，如果该类已经是最顶层的根类（如 NSObject 或 NSProxy），则 superclass 为 NULL。</p>\n<h4 id=\"7-cache-t\"><a href=\"#7-cache-t\" class=\"headerlink\" title=\"(7) cache_t\"></a>(7) cache_t</h4><p>cache_t 是一个散列表，用来缓存曾经调用过的方法，提高方法的查找速度。<br>源代码可在 objc-runtime-new.h line 59 找到，其关键结构如下:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cache_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket_t</span> *_<span class=\"title\">buckets</span>;</span>     <span class=\"comment\">// 散列表</span></span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> _mask;                  <span class=\"comment\">// 散列表的长度 -1</span></span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> _occupied;              <span class=\"comment\">// 已经缓存的方法数量</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">cache_key_t</span> _key;              <span class=\"comment\">// SEL 作为 key</span></span><br><span class=\"line\">    MethodCacheIMP _imp;           <span class=\"comment\">// 函数的内存地址</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>buckets：</strong>指向 Method 数据结构指针的数组。这个数组可能包含不超过 mask+1 个元素。需要注意的是，指针可能是 NULL，表示这个缓存 bucket 没有被占用，另外被占用的 bucket 可能是不连续的。这个数组可能会随着时间而增长。</p>\n<p><strong>mask：</strong>一个整数，指定分配的缓存 bucket 的总数。在方法查找过程中，Objective-C runtime 使用这个字段来确定开始线性查找数组的索引未知。指向方法 selector 的指针与该字段做一个 AND 位操作（index = (mask &amp; selector)）。这可以作为一个简单的 hash 散列算法。</p>\n<p><strong>occupied：</strong>一个整数，指定实际占用的缓存 bucket 的总数。</p>\n<h4 id=\"8-class-data-bits-t\"><a href=\"#8-class-data-bits-t\" class=\"headerlink\" title=\"(8) class_data_bits_t\"></a>(8) class_data_bits_t</h4><p>class_data_bits_t 是一个结构体，里面包含了一个 class_rw_t 类型的指针 data。class_rw_t 内部有个 class_ro_t 的指针 ro。class_rw_t 是可读可写的，class_ro_t 是只读的。 class_data_bits_t 源代码可以在 objc-runtime-new.h line 870 看到。</p>\n<p><strong>class_rw_t</strong> 结构如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">class_rw_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> flags;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> version;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">class_ro_t</span> *ro;             <span class=\"comment\">// 保存类的原始数据(不包含分类内容和动态添加的方法)</span></span><br><span class=\"line\">    <span class=\"keyword\">method_array_t</span> methods;           <span class=\"comment\">// 方法列表(如果是类对象存储的是对象方法,元类对象存储的是类方法)</span></span><br><span class=\"line\">    <span class=\"keyword\">property_array_t</span> properties;      <span class=\"comment\">// 属性列表</span></span><br><span class=\"line\">    <span class=\"keyword\">protocol_array_t</span> protocols;       <span class=\"comment\">// 协议列表</span></span><br><span class=\"line\">    Class firstSubclass;              <span class=\"comment\">// 第一个子类</span></span><br><span class=\"line\">    Class nextSiblingClass;           <span class=\"comment\">// 兄弟类</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>class_ro_t</strong> 储存了类的初始信息，不包括分类和后来动态添加的内容。class_ro_t 关键代码如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">class_ro_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> flags;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> instanceStart;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> instanceSize;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __LP64__</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> reserved;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">uint8_t</span> * ivarLayout;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * name;                    <span class=\"comment\">// 类名</span></span><br><span class=\"line\">    <span class=\"keyword\">method_list_t</span> * baseMethodList;       <span class=\"comment\">// 原始方法列表</span></span><br><span class=\"line\">    <span class=\"keyword\">protocol_list_t</span> * baseProtocols;      <span class=\"comment\">// 原始协议列表</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">ivar_list_t</span> * ivars;            <span class=\"comment\">// 成员变量列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">uint8_t</span> * weakIvarLayout;</span><br><span class=\"line\">    <span class=\"keyword\">property_list_t</span> *baseProperties;      <span class=\"comment\">// 属性列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">method_list_t</span> *baseMethods() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> baseMethodList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>method_list_t</strong> 数组包含了多个 method_t，其中 method_t 也是结构体 ，其关键结构如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">method_t</span> &#123;</span></span><br><span class=\"line\">    SEL name;               <span class=\"comment\">// 函数名</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types;      <span class=\"comment\">// 方法参数 (包含了返回值类型,参数类型)</span></span><br><span class=\"line\">    MethodListIMP imp;      <span class=\"comment\">// 方法的实现 (指向函数的指针)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>ivar_list_t</strong> 数组包含了多个 ivar_t 类型的结构体 ivar，ivar_t 结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ivar_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int32_t</span> *offset;               <span class=\"comment\">// 变量在内存中相对所属对象内存空间起始地址的偏移量,偏移量大小根据类型来定</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;              <span class=\"comment\">// 变量名</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *type;              <span class=\"comment\">// 变量类型</span></span><br><span class=\"line\">    <span class=\"comment\">// alignment is sometimes -1; use alignment() instead</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> alignment_raw;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> alignment() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (alignment_raw == ~(<span class=\"keyword\">uint32_t</span>)<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1U</span> &lt;&lt; WORD_SHIFT;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> &lt;&lt; alignment_raw;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>property_list_t</strong> 数组包含多个 property_t，property_t 结构如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">property_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;             </span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *attributes;        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>class_ro_t 包含的类信息（方法、属性、协议等）都是在编译期就可以确定的，暂且称为元信息吧，在之后的逻辑中，它们显然是不希望被改变的；后续在用户层，无论是方法还是别的扩展，都是在 class_rw_t 上进行操作，这些操作都不会影响类的元信息。更多关于 class_rw_t 和 class_ro_t 的资料可查看 <a href=\"https://zhangbuhuai.com/post/runtime.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</p>\n<h3 id=\"4-类和对象相关操作方法\"><a href=\"#4-类和对象相关操作方法\" class=\"headerlink\" title=\"4. 类和对象相关操作方法\"></a>4. 类和对象相关操作方法</h3><p>操作类相关的函数一般以 class 为前缀，操作对象相关函数以 objc 或 object_ 为前缀。可在开篇 Runtime 函数文档查看相关方法。</p>\n<h4 id=\"1-类相关操作函数\"><a href=\"#1-类相关操作函数\" class=\"headerlink\" title=\"(1) 类相关操作函数\"></a>(1) 类相关操作函数</h4><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const <span class=\"keyword\">char</span> * class_getName ( <span class=\"keyword\">Class</span> cls )           <span class=\"comment\">// 获取类名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Class</span> class_getSuperclass ( <span class=\"keyword\">Class</span> cls )            <span class=\"comment\">// 获取父类</span></span><br><span class=\"line\"></span><br><span class=\"line\">BOOL class_isMetaClass ( <span class=\"keyword\">Class</span> cls )               <span class=\"comment\">// 判断给定的类是不是元类</span></span><br><span class=\"line\"></span><br><span class=\"line\">size_t class_getInstanceSize ( <span class=\"keyword\">Class</span> cls )         <span class=\"comment\">// 获取类的实例大小</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> class_getVersion ( <span class=\"keyword\">Class</span> cls )                 <span class=\"comment\">// 获取版本号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> class_setVersion ( <span class=\"keyword\">Class</span> cls, <span class=\"keyword\">int</span> version )   <span class=\"comment\">// 设置版本号</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-成员变量-ivars-和属性相关操作函数\"><a href=\"#2-成员变量-ivars-和属性相关操作函数\" class=\"headerlink\" title=\"(2) 成员变量 (ivars) 和属性相关操作函数\"></a>(2) 成员变量 (ivars) 和属性相关操作函数</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Ivar <span class=\"title\">class_getInstanceVariable</span> <span class=\"params\">( Class cls, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name )</span>                                           <span class=\"comment\">// 获取类中指定名称实例成员变量的信息</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">Ivar <span class=\"title\">class_getClassVariable</span> <span class=\"params\">( Class cls, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name )</span>                                              <span class=\"comment\">// 获取类成员变量的信息</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">class_addIvar</span> <span class=\"params\">( Class cls, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">uint8_t</span> alignment, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types )</span>    <span class=\"comment\">// 在 runtime 时创建的类添加成员变量</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">Ivar * <span class=\"title\">class_copyIvarList</span> <span class=\"params\">( Class cls, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *outCount )</span>                                          <span class=\"comment\">// 获取整个成员变量列表，必须使用 free() 来释放</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-method-相关操作函数\"><a href=\"#3-method-相关操作函数\" class=\"headerlink\" title=\"(3) method 相关操作函数\"></a>(3) method 相关操作函数</h4><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BOOL class_addMethod ( <span class=\"keyword\">Class</span> cls, SEL name, IMP imp, <span class=\"keyword\">const</span> char *types )       <span class=\"comment\">// 添加方法，和成员变量不同的是可以为类动态添加方法。如果有同名会返回 NO，修改的话需要使用 method_setImplementation</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">Method</span> <span class=\"title\">class_getInstanceMethod</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL name )</span>                         // 获取实例方法</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Method</span> <span class=\"title\">class_getClassMethod</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL name )</span>                            // 获取类方法</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Method</span> * <span class=\"title\">class_copyMethodList</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, unsigned int *outCount )</span>            // 获取所有方法</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">IMP</span> <span class=\"title\">class_replaceMethod</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL name, IMP imp, <span class=\"keyword\">const</span> char *types )</span>    // 实现替换方法</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">IMP</span> <span class=\"title\">class_getMethodImplementation</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL name )</span>                      // 返回方法的具体实现</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">IMP</span> <span class=\"title\">class_getMethodImplementation_stret</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL name )</span>                // 返回方法的具体实现</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">BOOL</span> <span class=\"title\">class_respondsToSelector</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL sel )</span>                           // 类实例是否响应指定的 <span class=\"title\">selector</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"4-protocol-相关操作函数\"><a href=\"#4-protocol-相关操作函数\" class=\"headerlink\" title=\"(4) protocol 相关操作函数\"></a>(4) protocol 相关操作函数</h4><figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">BOOL</span> class_addProtocol ( Class <span class=\"keyword\">cls</span>, Protocol *protocol )                       <span class=\"comment\">// 添加协议</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">BOOL</span> class_conformsToProtocol ( Class <span class=\"keyword\">cls</span>, Protocol *protocol )                <span class=\"comment\">// 返回类是否实现指定的协议</span></span><br><span class=\"line\"></span><br><span class=\"line\">Protocol * class_copyProtocolList ( Class <span class=\"keyword\">cls</span>, unsigned int *outCount )        <span class=\"comment\">// 获取类实现的协议列表</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"5-相关示例代码及输出：\"><a href=\"#5-相关示例代码及输出：\" class=\"headerlink\" title=\"(5) 相关示例代码及输出：\"></a>(5) 相关示例代码及输出：</h4><figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> RuntimClass *runtimeClass = [[RuntimClass alloc] init]<span class=\"comment\">;</span></span><br><span class=\"line\"> Class cls = runtimeClass.class<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> // 类名</span><br><span class=\"line\"> const char *clsName = class_getName(cls)<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"类名：%s\", clsName)<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> // 父类</span><br><span class=\"line\"> Class superCls = class_getSuperclass(cls)<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"父类名：%s\", class_getName(superCls))<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> // 元类</span><br><span class=\"line\"> BOOL isMetaCls = class_isMetaClass(cls)<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"%s %@元类\", clsName, (isMetaCls ? @\"是\" : @\"不是\"))<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> Class metaCls = objc_getMetaClass(class_getName(cls))<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"%s的元类是：%s\", clsName, class_getName(metaCls))<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> // 变量实例大小</span><br><span class=\"line\"> size_t instanceSize = class_getInstanceSize(cls)<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"%s的所有实例变量大小：%zu\",clsName ,instanceSize)<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> // 成员变量</span><br><span class=\"line\"> unsigned int outCount = <span class=\"number\">0</span><span class=\"comment\">;</span></span><br><span class=\"line\"> Ivar *ivars = class_copyIvarList(cls, &amp;outCount)<span class=\"comment\">;</span></span><br><span class=\"line\"> for (int i = <span class=\"number\">0</span><span class=\"comment\">; i &lt; outCount; i++) &#123;</span></span><br><span class=\"line\">     Ivar ivar = ivars[i]<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"成员变量%s在第%d的位置\", ivar_getName(ivar), i)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> free(ivars)<span class=\"comment\">;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> Ivar ivar = class_getInstanceVariable(cls, \"_array\")<span class=\"comment\">;</span></span><br><span class=\"line\"> if (ivar != NULL) &#123;</span><br><span class=\"line\">     const char *ivarName = ivar_getName(ivar)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"成员变量：%s\", ivarName)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125; else &#123;</span><br><span class=\"line\">     NSLog(@\"没有此成员变量\")<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> // 属性</span><br><span class=\"line\"> objc_property_t *properties = class_copyPropertyList(cls, &amp;outCount)<span class=\"comment\">;</span></span><br><span class=\"line\"> for (int i = <span class=\"number\">0</span><span class=\"comment\">; i &lt; outCount; i++) &#123;</span></span><br><span class=\"line\">     objc_property_t property = properties[i]<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"属性名称: %s\", property_getName(property))<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> free(properties)<span class=\"comment\">;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> objc_property_t arrayProperty = class_getProperty(cls, \"array\")<span class=\"comment\">;</span></span><br><span class=\"line\"> if (arrayProperty != NULL) &#123;</span><br><span class=\"line\">     const char *arryPropertyName = property_getName(arrayProperty)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"属性%s\", arryPropertyName)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> //方法</span><br><span class=\"line\"> Method *methods = class_copyMethodList(cls, &amp;outCount)<span class=\"comment\">;   //包含category添加的方法</span></span><br><span class=\"line\"> for (int i = <span class=\"number\">0</span><span class=\"comment\">; i &lt; outCount; i++) &#123;</span></span><br><span class=\"line\">     Method method = methods[i]<span class=\"comment\">;</span></span><br><span class=\"line\">     SEL methodSignature = method_getName(method)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"方法签名: %s\", methodSignature)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> free(methods)<span class=\"comment\">;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> Method method1 = class_getInstanceMethod(cls, @selector(method2))<span class=\"comment\">;</span></span><br><span class=\"line\"> if (method1 != NULL) &#123;</span><br><span class=\"line\">     SEL method1Signature = method_getName(method1)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"方法%s\",method1Signature)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125; else &#123;</span><br><span class=\"line\">     NSLog(@\"未找到此方法\")<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> Method classMethod = class_getClassMethod(cls, @selector(classMethod))<span class=\"comment\">;</span></span><br><span class=\"line\"> if (classMethod != NULL) &#123;</span><br><span class=\"line\">     SEL classMethodName = method_getName(classMethod)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"类方法 %s\", classMethodName)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> BOOL responds = class_respondsToSelector(cls, @selector(method4WithArg1:arg2:))<span class=\"comment\">;</span></span><br><span class=\"line\"> if (responds) &#123;</span><br><span class=\"line\">     Method respondsMethod = class_getInstanceMethod(cls, @selector(method4WithArg1:arg2:))<span class=\"comment\">;</span></span><br><span class=\"line\">     SEL respondsMethodName = method_getName(respondsMethod)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"%s响应方法%s\", clsName, respondsMethodName)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125; else &#123;</span><br><span class=\"line\">     NSLog(@\"%s不响应此方法\", clsName)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> IMP imp = class_getMethodImplementation(cls, @selector(method1))<span class=\"comment\">;</span></span><br><span class=\"line\"> imp()<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> // 协议</span><br><span class=\"line\"> Protocol __unsafe_unretained **protocols = class_copyProtocolList(cls, &amp;outCount)<span class=\"comment\">;</span></span><br><span class=\"line\"> for (int i = <span class=\"number\">0</span><span class=\"comment\">; i &lt; outCount; i++) &#123;</span></span><br><span class=\"line\">     Protocol * protocol = protocols[i]<span class=\"comment\">;</span></span><br><span class=\"line\">     const char *protocalName = protocol_getName(protocol)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"协议名称：%s\", protocalName)<span class=\"comment\">;</span></span><br><span class=\"line\">     NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> Protocol * protocol = protocols[<span class=\"number\">1</span>]<span class=\"comment\">;</span></span><br><span class=\"line\"> BOOL conformProtocol = class_conformsToProtocol(cls, protocol)<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"%s%@遵循协议%s\", clsName, (conformProtocol ? @\"\" : @\"不\"), protocol_getName(protocol))<span class=\"comment\">;</span></span><br><span class=\"line\"> NSLog(@\"**********************************\")<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">输出日志如下：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.595856</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 类名：RuntimClass</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.596386</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.596500</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 父类名：NSObject</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.596584</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.596721</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] RuntimClass 不是元类</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.596798</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.596890</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] RuntimClass的元类是：RuntimClass</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.596966</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.597060</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] RuntimClass的所有实例变量大小：<span class=\"number\">56</span></span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.597136</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.597251</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 成员变量firstInstance在第<span class=\"number\">0</span>的位置</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.597429</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.597622</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 成员变量secondInstance在第<span class=\"number\">1</span>的位置</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.597803</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.601663</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 成员变量thirdInstance在第<span class=\"number\">2</span>的位置</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.601739</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.601823</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 成员变量_array在第<span class=\"number\">3</span>的位置</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.601888</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.601965</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 成员变量_string在第<span class=\"number\">4</span>的位置</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.602033</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.602106</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 成员变量_index在第<span class=\"number\">5</span>的位置</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.602168</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.602479</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 成员变量：_array</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.602681</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.602908</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 属性名称: array</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.603056</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.603266</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 属性名称: string</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.603464</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.603662</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 属性名称: index</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.603887</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.604116</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 属性名称: hash</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.604339</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.604568</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 属性名称: superclass</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.604777</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.604990</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 属性名称: description</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.605190</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.605425</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 属性名称: debugDescription</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.605645</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.605936</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 属性array</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.606183</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.606395</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: method2</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.606628</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.606834</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: method4WithArg1:arg2:</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.607034</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.607246</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: method1</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.607447</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.607663</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: runtimeClassProtocol</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.607879</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.608107</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: method3</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.608328</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.608544</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: categoryMethod</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.608751</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.609075</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: setArray:</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.609301</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.609538</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: .cxx_destruct</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.609716</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.609900</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: array</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.610099</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.610279</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: setString:</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.610425</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.610653</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: string</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.610860</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.611082</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: index</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.611292</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.611517</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法签名: setIndex:</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.611719</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.611945</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 方法method2</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.612125</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.612359</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 类方法 classMethod</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.612575</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.612797</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] RuntimClass响应方法method4WithArg1:arg2:</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.612966</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.613153</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] method1 被调用</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.613371</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.613612</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 协议名称：RuntimeClassProtocol</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.613829</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.614063</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 协议名称：NSCopying</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26:12.614253</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.614446</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] 协议名称：NSCoding</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.614655</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.614887</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] RuntimClass遵循协议NSCopying</span><br><span class=\"line\"><span class=\"number\">2019-06-15</span> <span class=\"number\">18</span>:<span class=\"number\">26</span>:<span class=\"number\">12.615037</span>+<span class=\"number\">0800</span> RuntimDemo[<span class=\"number\">18732</span>:<span class=\"number\">16102829</span>] **********************************</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-消息与消息转发\"><a href=\"#5-消息与消息转发\" class=\"headerlink\" title=\"5. 消息与消息转发\"></a>5. 消息与消息转发</h3><h4 id=\"1-Method-基础数据结构：\"><a href=\"#1-Method-基础数据结构：\" class=\"headerlink\" title=\"(1) Method 基础数据结构：\"></a>(1) Method 基础数据结构：</h4><p>  Method 是 method_t 结构体的指针，method_t 在分析 method_list_t 已写出其结构，其结构中包括 SEL 和 IMP 两种数据结构。</p>\n<p><strong>SEL：</strong>Objective-C 在编译的时候，objc_selector 会依据方法的名字、参数序列、生成一个整型标识的地址<br>( int 类型的地址)：这个标识就是 SEL，其结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_selector</span> *<span class=\"title\">SEL</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>IMP：</strong>是一个函数指针，指向方法实现的地址。其结构如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// A pointer to the function of a method implementation. </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*IMP)</span><span class=\"params\">(<span class=\"keyword\">void</span> <span class=\"comment\">/* id, SEL, ... */</span> )</span></span>; </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong>SEL 和 IMP 为映射关系：</strong>SEL 通过 Dispatch table 表寻找到对应的 IMP， Dispatch table 表存放 SEL 和 IMP 的映射。我们可以对一个编号 (SEL) 和什么方法 (IMP) 映射做些操作，也就是说我们可以一个 SEL 指向不同的函数指针，这样就可以完成一个方法名在不同时候执行不同的函数体。</p>\n<h4 id=\"2-相关操作方法：\"><a href=\"#2-相关操作方法：\" class=\"headerlink\" title=\"(2) 相关操作方法：\"></a>(2) 相关操作方法：</h4><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用指定方法的实现，返回的是方法实现时的返回，参数 receiver 不能为空，这个比 method_getImplementation 和 method_getName 速度快</span></span><br><span class=\"line\">void method_invoke_stret ( id receiver, <span class=\"function\"><span class=\"keyword\">Method</span> <span class=\"title\">m</span>, ... )</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 调用返回一个数据结构的方法的实现              </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">id</span> <span class=\"title\">method_invoke</span> <span class=\"params\">( id receiver, <span class=\"keyword\">Method</span> m, ... )</span>           </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 获取方法名，希望获得方法名的 <span class=\"title\">C</span> 字符串，使用 <span class=\"title\">sel_getName</span><span class=\"params\">(method_getName(<span class=\"keyword\">method</span>)</span>)          </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">SEL</span> <span class=\"title\">method_getName</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m )</span>                   </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 返回方法的实现                  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">IMP</span> <span class=\"title\">method_getImplementation</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m )</span>    </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 获取描述方法参数和返回值类型的字符串                        </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">const</span> <span class=\"title\">char</span> * <span class=\"title\">method_getTypeEncoding</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m )</span>    </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 获取方法的返回值类型的字符串                 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">char</span> * <span class=\"title\">method_copyReturnType</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m )</span>         </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 获取方法的指定位置参数的类型字符串                    </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">char</span> * <span class=\"title\">method_copyArgumentType</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m, unsigned int <span class=\"keyword\">index</span> )</span>      </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 通过引用返回方法的返回值类型字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">void</span> <span class=\"title\">method_getReturnType</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m, char *dst, size_t dst_len )</span>    </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 返回方法的参数的个数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">unsigned</span> <span class=\"title\">int</span> <span class=\"title\">method_getNumberOfArguments</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m )</span>               </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 通过引用返回方法指定位置参数的类型字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">void</span> <span class=\"title\">method_getArgumentType</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m, unsigned int <span class=\"keyword\">index</span>, char *dst, size_t dst_len )</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 返回指定方法的方法描述结构体</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">struct</span> <span class=\"title\">objc_method_description</span> * <span class=\"title\">method_getDescription</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m )</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 设置方法的实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">IMP</span> <span class=\"title\">method_setImplementation</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m, IMP imp )</span>           </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 交换两个方法的实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">void</span> <span class=\"title\">method_exchangeImplementations</span> <span class=\"params\">( <span class=\"keyword\">Method</span> m1, <span class=\"keyword\">Method</span> m2 )</span>     </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 返回给定选择器指定的方法的名称    </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">const</span> <span class=\"title\">char</span> * <span class=\"title\">sel_getName</span> <span class=\"params\">( SEL sel )</span>          </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 返回 <span class=\"title\">Runtime</span> 系统中注册的方法，方法名映射的选择器                       </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">SEL</span> <span class=\"title\">sel_registerName</span> <span class=\"params\">( <span class=\"keyword\">const</span> char *str )</span>                             </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">Runtime</span> 系统中注册一个方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">SEL</span> <span class=\"title\">sel_getUid</span> <span class=\"params\">( <span class=\"keyword\">const</span> char *str )</span>           </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 比较两个选择器                        </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">BOOL</span> <span class=\"title\">sel_isEqual</span> <span class=\"params\">( SEL lhs, SEL rhs )</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"4-Method-调用流程：\"><a href=\"#4-Method-调用流程：\" class=\"headerlink\" title=\"(4) Method 调用流程：\"></a>(4) Method 调用流程：</h4><p><strong>objc_msgSend 函数：</strong> 这个函数将消息接收者和方法名作为基础参数。消息发送给一个对象时，objc_msgSend 通过对象的 isa 指针获得类的结构体，先在 Cache 里找，找到就执行，没找到就在分发列表里查找方法的 selector，没找到就通过 objc_msgSend 结构体中指向父类的指针找到父类，然后在父类分发列表找，直到 root class（NSObject）。Objc 中发送消息是用中括号把接收者和消息括起来，只到运行时才会把消息和方法实现绑定。为了加快速度，苹果对这个方法做了很多优化，这个方法是用汇编实现的。<br>objc_msgSend 定义如下：<br><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">objc_msgSend</span>(<span class=\"params\">receiver, selector, arg1, arg2, ...</span>)</span></span><br></pre></td></tr></table></figure></p>\n<p>objc_msgSend 内部实现大致流程：首先在 Class 中的缓存查找 imp（没缓存则初始化缓存），如果没找到就去父类的 Class 查找，如果一直查到到根类仍旧没有实现，则用 <em>_objc_msgForward</em> 函数指针代替 imp， 最后执行 imp。 <em>_objc_msgForward</em>  是用于消息转发的，当方法没有被寻找到的时候，就会触发消息转发流程。</p>\n<p><strong>消息转发流程：</strong>当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息，如果是以 [receiver message] 的方式调用方法，那么如果 receiver 无法响应 message 消息时，编译器就会报错。但如果是 perform… 的形式来调用，则需要等到运行时才能确定 receiver 是否能接受 message 消息。如果不能，则程序崩溃。消息转发的流程，可以分为三个阶段: 方法解析、重定向、消息转发。</p>\n<p><em>tips:</em> 通常，当不能确定一个对象是否能接收某个消息时，会先调用 respondsToSelector: 来判断一下：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">if</span> ([self <span class=\"attribute\">respondsToSelector</span>:<span class=\"variable\">@selector</span>(method)]) &#123;</span><br><span class=\"line\">    <span class=\"selector-attr\">[self performSelector:@selector(method)]</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>方法解析：</strong>当 runtime 在方法缓存列表和方法分发列表（包括超类）中找不到要执行的方法时，首先会进入方法解析阶段，此时可以在方法解析中动态添加方法实现。具体操作的函数如下：<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实例方法找不到实现的情况，可以在方法解析中动态添加方法实现</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel     </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//类方法找不到实现的情况，可以在方法解析中动态添加方法实现</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveClassMethod:(SEL)sel</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//动态添加一个方法，Class cls 是要指定的类，runtime 会到这个类中去找方法， SEL name 是要解析的方法，IMP 是动态添加的方法实现的 imp ，const char *types : 类型编码，是个字符串</span></span><br><span class=\"line\">class_addMethod(Class cls, SEL name, IMP imp, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types)</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1\" target=\"_blank\" rel=\"noopener\">类型编码文档</a></p>\n<p><strong>重定向：</strong>在消息转发机制执行前，系统会再给我们一次偷梁换柱的机会通过重载 <em>forwardingTargetForSelector</em> 方法替换消息的接受者为其他对象，毕竟消息转发需要耗费更多的时间，如果此方法返回 nil 或是 self，则会进入消息转发阶段。但是替换的对象千万不要是 self，那样会进入死循环。<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">-</span> (id)<span class=\"selector-tag\">forwardingTargetForSelector</span><span class=\"selector-pseudo\">:(SEL)aSelector</span> &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">if</span> (aSelector == <span class=\"variable\">@selector</span>(<span class=\"attribute\">mysteriousMethod</span>:)) &#123;</span><br><span class=\"line\">       <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">alternateObject</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> <span class=\"selector-attr\">[super forwardingTargetForSelector:aSelector]</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>消息转发：</strong><br>如果以上两种都没法处理未知消息就需要完整消息转发了，调用如下方法：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这一步是最后机会将消息转发给其它对象，对象会将未处理的消息相关的 selector，target 和参数都封装在 anInvocation 中。forwardInvocation :像未知消息分发中心，将未知消息转发给其它对象。注意的是 forwardInvocation: 方法只有在消息接收对象无法正常响应消息时才被调用。</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">forwardInvocation</span><span class=\"selector-pseudo\">:(NSInvocation</span> *)<span class=\"selector-tag\">anInvocation</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//必须重写这个方法，消息转发使用这个方法获得的信息创建 NSInvocation 对象。</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (NSMethodSignature *)<span class=\"selector-tag\">methodSignatureForSelector</span><span class=\"selector-pseudo\">:(SEL)aSelector</span></span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/\" target=\"_blank\" rel=\"noopener\">消息转发更详细资料</a></p>\n<h4 id=\"5-Method-Swizzling：\"><a href=\"#5-Method-Swizzling：\" class=\"headerlink\" title=\"(5) Method Swizzling：\"></a>(5) Method Swizzling：</h4><p>Objective-C 中的 Method Swizzling 允许我们动态地替换方法的实现，实现 Hook 功能，是一种比子类化更加灵活的“重写”方法的方式。讲 Method 结构的时候提到过：原则上方法的名称 name 和方法的实现 imp 是一一对应的，而 Method Swizzling 的原理就是动态地改变它们的对应关系，达到替换方法实现的目的，如下代码实现了 NSArray 异常操作的崩溃拦截功能：<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"NSArray+SafeArray.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> 在 iOS 中 NSNumber、NSArray、NSDictionary 等这些类都是类簇，一个 NSArray 的实现可能由多个类组成。所以如果想对 NSArray 进行 Swizzling，必须获取到其“真身”进行 Swizzling，直接对 NSArray 进行操作是无效的。</span></span><br><span class=\"line\"><span class=\"comment\"> </span></span><br><span class=\"line\"><span class=\"comment\"> 下面列举了 NSArray 和 NSDictionary 本类的类名，可以通过Runtime函数取出本类。</span></span><br><span class=\"line\"><span class=\"comment\"> NSArray                __NSArrayI</span></span><br><span class=\"line\"><span class=\"comment\"> NSMutableArray         __NSArrayM</span></span><br><span class=\"line\"><span class=\"comment\"> NSDictionary           __NSDictionaryI</span></span><br><span class=\"line\"><span class=\"comment\"> NSMutableDictionary\t__NSDictionaryM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSArray</span> (<span class=\"title\">SafeArray</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意下面的load方法中，不应该调用父类的load方法</span></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)load &#123;</span><br><span class=\"line\">    Method fromMethod = class_getInstanceMethod(objc_getClass(<span class=\"string\">\"__NSArrayI\"</span>), <span class=\"keyword\">@selector</span>(objectAtIndex:));</span><br><span class=\"line\">    Method toMethod = class_getInstanceMethod(objc_getClass(<span class=\"string\">\"__NSArrayI\"</span>), <span class=\"keyword\">@selector</span>(safe_objectAtIndex:));</span><br><span class=\"line\">    method_exchangeImplementations(fromMethod, toMethod);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为了避免和系统的方法冲突在 swizzling 方法前面加前缀</span></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)safe_objectAtIndex:(<span class=\"built_in\">NSUInteger</span>)index &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.count<span class=\"number\">-1</span> &lt; index) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果越界就进入异常拦截</span></span><br><span class=\"line\">        <span class=\"keyword\">@try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> safe_objectAtIndex:index];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">@catch</span> (<span class=\"built_in\">NSException</span> *exception) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 崩溃后收集日志</span></span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"---------- %s Crash Because Method %s  ----------\\n\"</span>, class_getName(<span class=\"keyword\">self</span>.class), __func__);</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [exception callStackSymbols]);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">@finally</span> &#123;&#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有问题，则正常进行方法调用</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> safe_objectAtIndex:index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>使用 Method Swizzling 注意的点：</strong></p>\n<p><strong>1 ）在 +load 方法中实现 Method Swizzling 的逻辑而不是在 +initialize ：</strong></p>\n<p>+load 和 +initialize 是 Objective-C runtime 会自动调用的两个类方法，但是它们的调用时机是不一样的。+load 方法是在类被加载的时候调用的，而 +initialize 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法调用。也就是说 +initialize 方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 +initialize 方法是永远不会被调用的。此外 +load 方法还有一个非常重要的特性，那就是子类、父类和分类中的 +load 方法的实现是被区别对待的。也就是说在 Objective-C runtime 自动调用 +load 方法时，分类中的 +load 方法并不会对主类中的 +load 方法造成覆盖。所以在 +load 方法是实现 Method Swizzling 逻辑是最佳选择。</p>\n<p><strong>2 ）用 dispatch_once 来进行调度：</strong></p>\n<p>+load 方法在类加载的时候会被 runtime 自动调用一次，但是它并没有限制程序员对 +load 方法的手动调用，所以使用 dispatch_once 确保代码不管有多少线程都只被执行一次。</p>\n<p><strong>3 ）需要调用 class_addMethod 方法，并且以它的结果为依据分别处理两种不同的情况：</strong></p>\n<p>使用 Method Swizzling 的目的通常都是为了给程序增加功能，而不是完全替换某个功能，所以我们一般都需要在自定义的实现中调用原始的实现，所以这里就会有两种情况需要我们分别进行处理：</p>\n<p><em>第一种情况：</em>主类本身有实现需要替换的方法，也就是 class_addMethod 方法返回 NO 时，直接交换两个方法的实现就可以了。</p>\n<p><em>第二种情况：</em>主类本身没有实现需要替换的方法，而是继承了父类的实现，即 class_addMethod 方法返回 YES。这时调用 class_getInstanceMethod 函数获取到的 originalSelector 指向的就是父类的方法，我们再通过执行 lass_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); 将父类的实现替换到我们自定义的方法中，这样就达到了在自定义方法的实现中调用父类实现的目的。</p>\n<p><strong>4）Selector，Method 和 Implementation 的关系：</strong></p>\n<p>一个类维护一个运行时可接收的消息分发表，分发表中每个入口是一个 Method，其中 key 是一个特定的名称即 SEL，与其对应的实现是 IMP 即指向底层 C 函数的指针。</p>\n<p><a href=\"https://juejin.im/entry/584912648e450a006c4be90a\" target=\"_blank\" rel=\"noopener\">Runtime Method Swizzling 开发实例汇总</a></p>\n<h3 id=\"6-Category-和-Protocol\"><a href=\"#6-Category-和-Protocol\" class=\"headerlink\" title=\"6. Category 和 Protocol\"></a>6. Category 和 Protocol</h3><h4 id=\"1-Category-数据结构：\"><a href=\"#1-Category-数据结构：\" class=\"headerlink\" title=\"(1) Category 数据结构：\"></a>(1) Category 数据结构：</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">category_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name; </span><br><span class=\"line\">    <span class=\"keyword\">classref_t</span> cls;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">method_list_t</span> *<span class=\"title\">instanceMethods</span>;</span>         <span class=\"comment\">// 实例方法列表</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">method_list_t</span> *<span class=\"title\">classMethods</span>;</span>            <span class=\"comment\">// 类方法列表，Meta Class方法列表的子集</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">protocol_list_t</span> *<span class=\"title\">protocols</span>;</span>             <span class=\"comment\">// 分类所实现的协议列表</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">property_list_t</span> *<span class=\"title\">instanceProperties</span>;</span>    </span><br><span class=\"line\">    <span class=\"comment\">// Fields below this point are not always present on disk.</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">property_list_t</span> *_<span class=\"title\">classProperties</span>;</span>      </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">method_list_t</span> *methodsForMeta(<span class=\"keyword\">bool</span> isMeta) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isMeta) <span class=\"keyword\">return</span> classMethods;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> instanceMethods;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">property_list_t</span> *propertiesForMeta(<span class=\"keyword\">bool</span> isMeta, struct header_info *hi);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-Category-的用途：\"><a href=\"#2-Category-的用途：\" class=\"headerlink\" title=\"(2) Category 的用途：\"></a>(2) Category 的用途：</h4><p> 1 ) 给现有的类添加方法</p>\n<p> 2 ) 将一个类的实现拆分成多个独立的源文件</p>\n<p> 3 ) 声明私有的方法</p>\n<p><em>注意:</em> Category 有一个非常容易误用的场景，那就是用 Category 来覆写父类或主类的方法。虽然目前 Objective-C 是允许这么做的，但是这种使用场景是非常不推荐的。使用 Category 来覆写方法有很多缺点，比如不能覆写 Category 中的方法、无法调用主类中的原始实现等，且很容易造成无法预估的行为。 </p>\n<h4 id=\"3-Category-的实现原理：\"><a href=\"#3-Category-的实现原理：\" class=\"headerlink\" title=\"(3) Category 的实现原理：\"></a>(3) Category 的实现原理：</h4><p>1 ）在编译时期，会将 Category 中实现的方法生成一个结构体 method_list_t ，将声明的属性生成一个结构体 property_list_t ，然后通过这些结构体生成一个结构体 category_t 并保存。</p>\n<p>2 ）在运行时期，Runtime 会拿到编译时期我们保存下来的结构体 category_t 然后将结构体 category_t 中的实例方法列表、协议列表、属性列表添加到主类中。</p>\n<p>3 ）将结构体 category_t 中的类方法列表、协议列表添加到主类的 metaClass 中。</p>\n<p><em>注意点 (1)：</em>category_t 中的方法列表是插入到主类的方法列表前面，所以这里 Category 中实现的方法并不会真正的覆盖掉主类中的方法，只是将 Category 的方法插到方法列表的前面去了，运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会停止查找，即会出现覆盖方法的这种假象了。</p>\n<p><em>注意点 (2)：</em>Category 添加实例变量，因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局。</p>\n<p>关键代码在 objc-runtime-new.mm 中的 _read_images 方法中实现，如下：<br><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/<span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span>*</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\"><span class=\"bullet\">* </span><span class=\"emphasis\">_read_</span>images</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\"><span class=\"bullet\">* </span>Perform initial processing of </span>the<span class=\"markdown\"> headers in </span>the<span class=\"markdown\"> linked </span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\"><span class=\"bullet\">* </span>list beginning with headerList. </span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">*</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\"><span class=\"bullet\">* </span>Called by: map<span class=\"emphasis\">_images_</span>nolock</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">*</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\"><span class=\"bullet\">* </span>Locking: runtimeLock acquired by map_images</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\"><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span><span class=\"strong\">*****</span>/</span></span></span><br><span class=\"line\"><span class=\"keyword\">void</span> _read_images(header_info **hList, uint32_t hCount, <span class=\"built_in\">int</span> totalClasses, <span class=\"built_in\">int</span> unoptimizedTotalClasses)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    header_info *hi;</span><br><span class=\"line\">    uint32_t hIndex;</span><br><span class=\"line\">    size_t count;</span><br><span class=\"line\">    size_t i;</span><br><span class=\"line\">    Class *resolvedFutureClasses = nil;</span><br><span class=\"line\">    size_t resolvedFutureClassCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> doneOnce;</span><br><span class=\"line\">    TimeLogger ts(PrintImageTimes);</span><br><span class=\"line\"></span><br><span class=\"line\">    runtimeLock.assertLocked();</span><br><span class=\"line\"></span><br><span class=\"line\">#define EACH_HEADER \\</span><br><span class=\"line\">    hIndex = <span class=\"number\">0</span>;         \\</span><br><span class=\"line\">    hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \\</span><br><span class=\"line\">    hIndex++</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!doneOnce) &#123;</span><br><span class=\"line\">        doneOnce = YES;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (DisableTaggedPointers) &#123;</span><br><span class=\"line\">            disableTaggedPointers();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        initializeTaggedPointerObfuscator();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PrintConnecting) &#123;</span><br><span class=\"line\">            _objc_inform(<span class=\"string\">\"CLASS: found %d classes during launch\"</span>, totalClasses);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// namedClasses</span></span><br><span class=\"line\">        <span class=\"comment\">// Preoptimized classes don't go in this table.</span></span><br><span class=\"line\">        <span class=\"comment\">// 4/3 is NXMapTable's load factor</span></span><br><span class=\"line\">        <span class=\"built_in\">int</span> namedClassesSize = </span><br><span class=\"line\">            (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * <span class=\"number\">4</span> / <span class=\"number\">3</span>;</span><br><span class=\"line\">        gdb_objc_realized_classes =</span><br><span class=\"line\">            NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);</span><br><span class=\"line\">        </span><br><span class=\"line\">        allocatedClasses = NXCreateHashTable(NXPtrPrototype, <span class=\"number\">0</span>, nil);</span><br><span class=\"line\">        </span><br><span class=\"line\">        ts.log(<span class=\"string\">\"IMAGE TIMES: first time tasks\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Discover categories. </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (EACH_HEADER) &#123;</span><br><span class=\"line\">        category_t **catlist = </span><br><span class=\"line\">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class=\"line\">        <span class=\"built_in\">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">            category_t *cat = catlist[i];</span><br><span class=\"line\">            Class cls = remapClass(cat-&gt;cls);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!cls) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Category's target class is missing (probably weak-linked).</span></span><br><span class=\"line\">                <span class=\"comment\">// Disavow any knowledge of this category.</span></span><br><span class=\"line\">                catlist[i] = nil;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (PrintConnecting) &#123;</span><br><span class=\"line\">                    _objc_inform(<span class=\"string\">\"CLASS: IGNORING category \\?\\?\\?(%s) %p with \"</span></span><br><span class=\"line\">                                 <span class=\"string\">\"missing weak-linked target class\"</span>, </span><br><span class=\"line\">                                 cat-&gt;name, cat);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Process this category. </span></span><br><span class=\"line\">            <span class=\"comment\">// First, register the category with its target class. </span></span><br><span class=\"line\">            <span class=\"comment\">// Then, rebuild the class's method lists (etc) if </span></span><br><span class=\"line\">            <span class=\"comment\">// the class is realized. </span></span><br><span class=\"line\">            <span class=\"built_in\">bool</span> classExists = NO;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class=\"line\">                ||  cat-&gt;instanceProperties) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class=\"line\">                    remethodizeClass(cls);</span><br><span class=\"line\">                    classExists = YES;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (PrintConnecting) &#123;</span><br><span class=\"line\">                    _objc_inform(<span class=\"string\">\"CLASS: found category -%s(%s) %s\"</span>, </span><br><span class=\"line\">                                 cls-&gt;nameForLogging(), cat-&gt;name, </span><br><span class=\"line\">                                 classExists ? <span class=\"string\">\"on existing class\"</span> : <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class=\"line\">                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class=\"line\">                    remethodizeClass(cls-&gt;ISA());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (PrintConnecting) &#123;</span><br><span class=\"line\">                    _objc_inform(<span class=\"string\">\"CLASS: found category +%s(%s)\"</span>, </span><br><span class=\"line\">                                 cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ts.log(<span class=\"string\">\"IMAGE TIMES: discover categories\"</span>);</span><br><span class=\"line\">#undef EACH_HEADER</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码主要完成了一下以下几件事：</p>\n<p>1 ）将 Category 和它的主类（或元类）注册到哈希表中</p>\n<p>2 ）如果主类（或元类）已实现，那么重建它的方法列表</p>\n<p>3 ）Category 中的实例方法和属性被整合到主类中；而类方法则被整合到元类中</p>\n<p>4 ）对协议的处理比较特殊，Category 中的协议被同时整合到了主类和元类中</p>\n<p>上述代码中通过 static void remethodizeClass(Class cls) 函数来重新整理类的数据结构，代码如下：<br><figure class=\"highlight zephir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> void remethodizeClass(<span class=\"class\"><span class=\"keyword\">Class</span> <span class=\"title\">cls</span>)</span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    category_list *cats;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isMeta;</span><br><span class=\"line\"></span><br><span class=\"line\">    runtimeLock.assertLocked();</span><br><span class=\"line\"></span><br><span class=\"line\">    isMeta = cls-&gt;isMetaClass();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Re-methodizing: check for more categories</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((cats = unattachedCategoriesForClass(cls, <span class=\"keyword\">false</span><span class=\"comment\">/*not realizing*/</span>))) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PrintConnecting) &#123;</span><br><span class=\"line\">            _objc_inform(<span class=\"string\">\"CLASS: attaching categories to class '%s' %s\"</span>, </span><br><span class=\"line\">                         cls-&gt;nameForLogging(), isMeta ? <span class=\"string\">\"(meta)\"</span> : <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        attachCategories(cls, cats, <span class=\"keyword\">true</span> <span class=\"comment\">/*flush caches*/</span>);        </span><br><span class=\"line\">        free(cats);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个函数的主要作用是将 Category 中的方法、属性和协议整合到类（主类或元类）中，更新类的数据字段 data() 中 method_lists（或 method_list）、properties 和 protocols 的值。上述代码中真正处理 Category 的方法是 attachCategories 方法，源码如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Attach method lists and properties and protocols from categories to a class.</span></span><br><span class=\"line\"><span class=\"comment\">// Assumes the categories in cats are all loaded and sorted by load order, </span></span><br><span class=\"line\"><span class=\"comment\">// oldest categories first.</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> </span><br><span class=\"line\">attachCategories(Class cls, category_list *cats, <span class=\"keyword\">bool</span> flush_caches)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cats) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// fixme rearrange to remove these intermediate allocations</span></span><br><span class=\"line\">    <span class=\"keyword\">method_list_t</span> **mlists = (<span class=\"keyword\">method_list_t</span> **)</span><br><span class=\"line\">        <span class=\"built_in\">malloc</span>(cats-&gt;count * <span class=\"keyword\">sizeof</span>(*mlists));</span><br><span class=\"line\">    <span class=\"keyword\">property_list_t</span> **proplists = (<span class=\"keyword\">property_list_t</span> **)</span><br><span class=\"line\">        <span class=\"built_in\">malloc</span>(cats-&gt;count * <span class=\"keyword\">sizeof</span>(*proplists));</span><br><span class=\"line\">    <span class=\"keyword\">protocol_list_t</span> **protolists = (<span class=\"keyword\">protocol_list_t</span> **)</span><br><span class=\"line\">        <span class=\"built_in\">malloc</span>(cats-&gt;count * <span class=\"keyword\">sizeof</span>(*protolists));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Count backwards through cats to get newest categories first</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mcount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> propcount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> protocount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = cats-&gt;count;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> fromBundle = NO;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span>&amp; entry = cats-&gt;<span class=\"built_in\">list</span>[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">method_list_t</span> *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mlist) &#123;</span><br><span class=\"line\">            mlists[mcount++] = mlist;</span><br><span class=\"line\">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">property_list_t</span> *proplist = </span><br><span class=\"line\">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (proplist) &#123;</span><br><span class=\"line\">            proplists[propcount++] = proplist;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">protocol_list_t</span> *protolist = entry.cat-&gt;protocols;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (protolist) &#123;</span><br><span class=\"line\">            protolists[protocount++] = protolist;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> rw = cls-&gt;data();</span><br><span class=\"line\"></span><br><span class=\"line\">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class=\"line\">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(mlists);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class=\"number\">0</span>) flushCaches(cls);</span><br><span class=\"line\"></span><br><span class=\"line\">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(proplists);</span><br><span class=\"line\"></span><br><span class=\"line\">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(protolists);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-Protocol\"><a href=\"#4-Protocol\" class=\"headerlink\" title=\"(4) Protocol\"></a>(4) Protocol</h4><p>Protocol 结构如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">uintptr_t</span> <span class=\"keyword\">protocol_ref_t</span>;  <span class=\"comment\">// protocol_t *, but unremapped</span></span><br></pre></td></tr></table></figure></p>\n<p>protocol_ref_t 指向 protocol_t，而 protocol_t 继承自 objc_object，所以 Protocol 是对象结构体，protocol_t 关键结构如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">protocol_t</span> :</span> objc_object &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *mangledName;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">protocol_list_t</span> *<span class=\"title\">protocols</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">method_list_t</span> *instanceMethods;</span><br><span class=\"line\">    <span class=\"keyword\">method_list_t</span> *classMethods;</span><br><span class=\"line\">    <span class=\"keyword\">method_list_t</span> *optionalInstanceMethods;</span><br><span class=\"line\">    <span class=\"keyword\">method_list_t</span> *optionalClassMethods;</span><br><span class=\"line\">    <span class=\"keyword\">property_list_t</span> *instanceProperties;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> size;   <span class=\"comment\">// sizeof(protocol_t)</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> flags;</span><br><span class=\"line\">    <span class=\"comment\">// Fields below this point are not always present on disk.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **_extendedMethodTypes;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *_demangledName;</span><br><span class=\"line\">    <span class=\"keyword\">property_list_t</span> *_classProperties;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-Category-和-Protocol-的操作方法\"><a href=\"#5-Category-和-Protocol-的操作方法\" class=\"headerlink\" title=\"(5) Category 和 Protocol 的操作方法\"></a>(5) Category 和 Protocol 的操作方法</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回指定的协议</span></span><br><span class=\"line\"><span class=\"function\">Protocol * <span class=\"title\">objc_getProtocol</span> <span class=\"params\">( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取运行时所知道的所有协议的数组</span></span><br><span class=\"line\"><span class=\"function\">Protocol ** <span class=\"title\">objc_copyProtocolList</span> <span class=\"params\">( <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *outCount )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建新的协议实例</span></span><br><span class=\"line\"><span class=\"function\">Protocol * <span class=\"title\">objc_allocateProtocol</span> <span class=\"params\">( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在运行时中注册新创建的协议，创建一个新协议后必须使用这个进行注册这个新协议，但是注册后不能够再修改和添加新方法。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">objc_registerProtocol</span> <span class=\"params\">( Protocol *proto )</span></span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为协议添加方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">protocol_addMethodDescription</span> <span class=\"params\">( Protocol *proto, SEL name, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types, BOOL isRequiredMethod, BOOL isInstanceMethod )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加一个已注册的协议到协议中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">protocol_addProtocol</span> <span class=\"params\">( Protocol *proto, Protocol *addition )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为协议添加属性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">protocol_addProperty</span> <span class=\"params\">( Protocol *proto, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, <span class=\"keyword\">const</span> <span class=\"keyword\">objc_property_attribute_t</span> *attributes, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回协议名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * <span class=\"title\">protocol_getName</span> <span class=\"params\">( Protocol *p )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试两个协议是否相等</span></span><br><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">protocol_isEqual</span> <span class=\"params\">( Protocol *proto, Protocol *other )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取协议中指定条件的方法的方法描述数组</span></span><br><span class=\"line\"><span class=\"function\">struct objc_method_description * <span class=\"title\">protocol_copyMethodDescriptionList</span> <span class=\"params\">( Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *outCount )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取协议中指定方法的方法描述</span></span><br><span class=\"line\"><span class=\"function\">struct objc_method_description <span class=\"title\">protocol_getMethodDescription</span> <span class=\"params\">( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取协议中的属性列表</span></span><br><span class=\"line\"><span class=\"keyword\">objc_property_t</span> * protocol_copyPropertyList ( Protocol *proto, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *outCount );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取协议的指定属性</span></span><br><span class=\"line\"><span class=\"keyword\">objc_property_t</span> protocol_getProperty ( Protocol *proto, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, BOOL isRequiredProperty, BOOL isInstanceProperty );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取协议采用的协议</span></span><br><span class=\"line\"><span class=\"function\">Protocol ** <span class=\"title\">protocol_copyProtocolList</span> <span class=\"params\">( Protocol *proto, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *outCount )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查看协议是否采用了另一个协议</span></span><br><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">protocol_conformsToProtocol</span> <span class=\"params\">( Protocol *proto, Protocol *other )</span></span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"7-Extention\"><a href=\"#7-Extention\" class=\"headerlink\" title=\"(7) Extention\"></a>(7) Extention</h4><p><strong>Extention 格式如下：</strong><br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@interface</span> ClassName()</span><br><span class=\"line\"><span class=\"comment\">//私有属性</span></span><br><span class=\"line\"><span class=\"comment\">//私有方法，如果不实现，编译时会报警</span></span><br><span class=\"line\"><span class=\"variable\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>(2) Extension 的作用</strong></p>\n<p>1 )  为一个类添加原来没有的变量、方法、属性<br>2 )  一般的类扩展写到 .m 文件中<br>3 )  一般的私有属性写到 .m 文件中的类扩展中</p>\n<p><strong>(3) Category 和 Extension 的区别</strong></p>\n<p>1 )  Category 中原则上只能增加方法（能添加属性的的原因只是通过 runtime 解决无 setter / getter 的问题而已）。Extension 不仅可以增加方法，还可以增加实例变量（或者属性），只是该实例变量默认是 Private 类型的。</p>\n<p>2 )  Extension 中声明的方法没被实现，编译器会报警，但是 Category 中的方法没被实现编译器是不会有任何警告的。Extention 添加的方法是在编译阶段被添加到类中，而 Category 添加的方法是在运行时添加到类中。所以相对于两者各有不同特性。</p>\n<p>3 )  Extention 不能像 Category 那样拥有独立的实现部分。也就是说，Extention 所声明的方法必须依托对应类的实现部分来实现。</p>\n<p>4 )  定义在 .m 文件中的 Extention 方法为私有的，Extention 是在 .m 文件中声明私有方法的非常好的方式。</p>\n<h3 id=\"7-Runtime-的应用\"><a href=\"#7-Runtime-的应用\" class=\"headerlink\" title=\"7. Runtime 的应用\"></a>7. Runtime 的应用</h3><p><strong>(1) 利用 Method Swizzling 特性实现用户行为收集，预防数组字典越界奔溃， 代码解耦等</strong></p>\n<p><strong>(2) 获取系统提供的库相关信息</strong></p>\n<p><strong>(3) 为类动态添加方法</strong></p>\n<h2 id=\"Swift-Runtime\"><a href=\"#Swift-Runtime\" class=\"headerlink\" title=\"Swift Runtime\"></a>Swift Runtime</h2><p>已查阅到的资料，待消化总结：</p>\n<p><a href=\"https://github.com/apple/swift/blob/master/docs/Runtime.md\" target=\"_blank\" rel=\"noopener\">https://github.com/apple/swift/blob/master/docs/Runtime.md</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&amp;mid=403068491&amp;idx=1&amp;sn=c95f07e3d38c92ba56933502cc3e1800#rd\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&amp;mid=403068491&amp;idx=1&amp;sn=c95f07e3d38c92ba56933502cc3e1800#rd</a></p>\n<p><a href=\"https://nshipster.com/swift-objc-runtime/\" target=\"_blank\" rel=\"noopener\">https://nshipster.com/swift-objc-runtime/</a></p>\n<p><a href=\"https://academy.realm.io/posts/mobilization-roy-marmelstein-objective-c-runtime-swift-dynamic/\" target=\"_blank\" rel=\"noopener\">https://academy.realm.io/posts/mobilization-roy-marmelstein-objective-c-runtime-swift-dynamic/</a></p>\n"}],"PostAsset":[{"_id":"source/_posts/Git-常用命令/git_sections.png","slug":"git_sections.png","post":"cjx2nwtyn0006u78elxyzf1wq","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint1.png","slug":"breakpoint1.png","post":"cjx2nwtyp0007u78ez2spta9o","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint11.png","slug":"breakpoint11.png","post":"cjx2nwtyp0007u78ez2spta9o","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint12.png","slug":"breakpoint12.png","post":"cjx2nwtyp0007u78ez2spta9o","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint13.png","slug":"breakpoint13.png","post":"cjx2nwtyp0007u78ez2spta9o","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint14.png","slug":"breakpoint14.png","post":"cjx2nwtyp0007u78ez2spta9o","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint15.png","slug":"breakpoint15.png","post":"cjx2nwtyp0007u78ez2spta9o","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint16.png","slug":"breakpoint16.png","post":"cjx2nwtyp0007u78ez2spta9o","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint4.png","slug":"breakpoint4.png","post":"cjx2nwtyp0007u78ez2spta9o","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint5.png","slug":"breakpoint5.png","post":"cjx2nwtyp0007u78ez2spta9o","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint6.png","slug":"breakpoint6.png","post":"cjx2nwtyp0007u78ez2spta9o","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint7.png","slug":"breakpoint7.png","post":"cjx2nwtyp0007u78ez2spta9o","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint8.png","slug":"breakpoint8.png","post":"cjx2nwtyp0007u78ez2spta9o","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint9.png","slug":"breakpoint9.png","post":"cjx2nwtyp0007u78ez2spta9o","modified":0,"renderable":0},{"_id":"source/_posts/iOS-Runtime/object_model.png","slug":"object_model.png","post":"cjx2nwu2k000hu78ed7k1jl23","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cjx2nwtyc0000u78ek4as0dnr","tag_id":"cjx2nwtyl0004u78eaf8ijbrl","_id":"cjx2nwtyr0009u78en5b1hvmh"},{"post_id":"cjx2nwtyi0002u78et5ozjn2w","tag_id":"cjx2nwtyp0008u78e8couppv4","_id":"cjx2nwtys000bu78ejdjrq5gu"},{"post_id":"cjx2nwtym0005u78ekkf8cw5i","tag_id":"cjx2nwtyr000au78evgr3vrjk","_id":"cjx2nwtys000du78e3iz5cekh"},{"post_id":"cjx2nwtyn0006u78elxyzf1wq","tag_id":"cjx2nwtys000cu78e0nrstsmj","_id":"cjx2nwtyt000fu78ebf7hvre0"},{"post_id":"cjx2nwtyp0007u78ez2spta9o","tag_id":"cjx2nwtys000eu78ena1837o0","_id":"cjx2nwtyt000gu78ed7mcl7qz"},{"post_id":"cjx2nwu2k000hu78ed7k1jl23","tag_id":"cjx2nwtyr000au78evgr3vrjk","_id":"cjx2nwu2l000iu78ef9oholiy"}],"Tag":[{"name":"Python","_id":"cjx2nwtyl0004u78eaf8ijbrl"},{"name":"SVN","_id":"cjx2nwtyp0008u78e8couppv4"},{"name":"iOS","_id":"cjx2nwtyr000au78evgr3vrjk"},{"name":"Git","_id":"cjx2nwtys000cu78e0nrstsmj"},{"name":"Xcode","_id":"cjx2nwtys000eu78ena1837o0"}]}}