{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/maupassant/source/css/default.css","path":"css/default.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/maupassant/source/donate/index.html","path":"donate/index.html","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/BTCQR.png","path":"img/BTCQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/AliPayQR.png","path":"img/AliPayQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/WeChatQR.png","path":"img/WeChatQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"3fc617f312684ad4253459ae5cf4b718a8fc7857","modified":1559111577649},{"_id":"themes/maupassant/.gitignore","hash":"16945417d10c15c950306794dbb0d970b5a199fe","modified":1559114337678},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1559114337678},{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1559114337678},{"_id":"themes/maupassant/README.md","hash":"90032cb3a46f741a3d6198de9f83ce384505519e","modified":1559114337679},{"_id":"themes/maupassant/_config.yml","hash":"fee8f5bafc7a796561c90b55c007ee02d43abcf1","modified":1559115367093},{"_id":"themes/maupassant/package.json","hash":"f092433469eb87362e831326425a6a5c3c9fea0d","modified":1559114337687},{"_id":"source/_posts/.DS_Store","hash":"9508d2ef0acf36a537be5e812078bffe638c2f0f","modified":1559299025598},{"_id":"source/_posts/Git-常用命令.md","hash":"e427ea12fe0d2438be9f19966d09f1385c608250","modified":1559371935085},{"_id":"source/_posts/SVN常用命令.md","hash":"37255e28aab7361d39d389d24be6a3510a5b5ff3","modified":1559295459336},{"_id":"source/_posts/iOS 中使用 Python.md","hash":"b03f38f35cad410223018eb5e056e4ae9a4eedf3","modified":1559299093648},{"_id":"source/_posts/iOS-RunLoop.md","hash":"36f1ddc4f84ce27406286229a17f9295fd222380","modified":1559368026401},{"_id":"source/_posts/iOS-Runtime.md","hash":"88982eb392fbd3863ceed6babbdfe2e80291fc2c","modified":1559461193625},{"_id":"source/_posts/iOS-调试技巧.md","hash":"b783347189f2155f0dcf356c01b22f5056132caa","modified":1559295087180},{"_id":"source/about/index.md","hash":"24acacd5dfa4ceb8534f88c3ac6b79959b7391a8","modified":1559111577656},{"_id":"source/category/.DS_Store","hash":"f2aee57486db29d3a9028ecfe1f84362e50b5aa4","modified":1559201268502},{"_id":"source/category/index.md","hash":"73650e3874483fefe8b2e4a63dfedbcc24c7bdc1","modified":1559111577657},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1559114337671},{"_id":"themes/maupassant/.git/config","hash":"037345b11c41abb3dbbbd6e0242ced24979a7097","modified":1559114337673},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1559114328511},{"_id":"themes/maupassant/.git/index","hash":"48e77753d45e80f77f8e6c4b226e9183d69fe05d","modified":1559136564763},{"_id":"themes/maupassant/.git/packed-refs","hash":"6aa82cbab8eae86de4682fb0c8931456c470dca5","modified":1559114337669},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1559114337679},{"_id":"themes/maupassant/languages/en.yml","hash":"c3fb5c155560a00889a75882c680afe1197ebf1a","modified":1559114337679},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1559114337680},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1559114337680},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1559114337680},{"_id":"themes/maupassant/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1559114337680},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"710b204e637c18b86ac7c681f7d1cf8dfeddf4bb","modified":1559114337682},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"bf3ab970f2ab3f29ddeb9f59bf98163be635e284","modified":1559114337682},{"_id":"themes/maupassant/layout/archive.pug","hash":"2fe2cff144c9b7b509b7b6cb1b3acba27aa1d132","modified":1559114337686},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"16c4d1079450f801b5ac079d3cc101856d8f387c","modified":1559114337686},{"_id":"themes/maupassant/layout/base.pug","hash":"a4e32bcb580b76af9ad0582d9d3f0107e34509ed","modified":1559114337686},{"_id":"themes/maupassant/layout/index.pug","hash":"0435a4e5f5c6976e05b3079d335453c246f5ba6e","modified":1559114337686},{"_id":"themes/maupassant/layout/page.pug","hash":"8cfd307b13cad8be34a1e75c4566f96c1722e08e","modified":1559114337686},{"_id":"themes/maupassant/layout/post.pug","hash":"f4d17b1b2a590cc076e80d912591648f9e99aeaf","modified":1559114337686},{"_id":"themes/maupassant/layout/single-column.pug","hash":"0593f261dc208bb0b5c4232eb41eff597a291bd9","modified":1559114337687},{"_id":"themes/maupassant/layout/timeline.pug","hash":"84fbfc92ccdf291b491140d89557553141a5d3f9","modified":1559114337687},{"_id":"source/_posts/Git-常用命令/.DS_Store","hash":"1c412b535acced9b86e95d0cbcd9dde94eb4b95f","modified":1559367845431},{"_id":"source/_posts/Git-常用命令/git_sections.png","hash":"7144c5e9e911d79586f90926a500a5ecb976b4d0","modified":1559366473978},{"_id":"source/_posts/iOS-Runtime/object_model.png","hash":"d2ef6d4a90d58a581f72fc63d4c462adfee71872","modified":1559460168075},{"_id":"source/_posts/iOS-调试技巧/breakpoint12.png","hash":"f85c679e23402f6e0b574a6efbfd6b6e235899de","modified":1559111577651},{"_id":"source/_posts/iOS-调试技巧/breakpoint13.png","hash":"e8a6a00b8789d9fe1f64f8493dc8b02bfdf0c364","modified":1559111577652},{"_id":"source/_posts/iOS-调试技巧/breakpoint15.png","hash":"38648981010ff460e3d161ea49ec391889da29e1","modified":1559111577653},{"_id":"source/_posts/iOS-调试技巧/breakpoint16.png","hash":"62914b63188fb033af2e27a8bd7f3e287cef5bd1","modified":1559111577653},{"_id":"source/_posts/iOS-调试技巧/breakpoint4.png","hash":"cc514934e78224ac5e290fc38504c886a62b99d7","modified":1559111577654},{"_id":"source/_posts/iOS-调试技巧/breakpoint5.png","hash":"2e6e00af53d5ea766a0b161e3ee826e20ffcc56a","modified":1559111577654},{"_id":"source/_posts/iOS-调试技巧/breakpoint7.png","hash":"ad9cc81432c0a6c706989cfe1d722c7ea92d5e09","modified":1559111577655},{"_id":"source/_posts/iOS-调试技巧/breakpoint8.png","hash":"3c226c35db2ffa9e22361fea4507cf68a4501d5b","modified":1559111577655},{"_id":"source/_posts/iOS-调试技巧/breakpoint9.png","hash":"a92019c371a73409511be25879f2fc4966f67223","modified":1559111577656},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1559114328514},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1559114328511},{"_id":"themes/maupassant/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1559114328515},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1559114328517},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1559114328518},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1559114328512},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1559114328518},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1559114328512},{"_id":"themes/maupassant/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1559114328517},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1559114328517},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1559114328519},{"_id":"themes/maupassant/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1559114328510},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"6d8c3306736074b5464ad4972d5c4bbcb4ed5079","modified":1559114337672},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"31bf35a57634ff8a796c71dd5246eba3a3db10ee","modified":1559114337683},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"ff14baa25f6db34dedfb5e029c25687a335ad430","modified":1559114337683},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"650781b5bc8c632658ad6880ba663b1e3bfb5798","modified":1559114337683},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"8af6e452ea2a56b110b5079f79bf743b643f7d6c","modified":1559114337683},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1559114337683},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1559114337683},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1559114337684},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1559114337684},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1559114337684},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1559114337684},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1559114337684},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"004c8a3edc19d428179b83a0f97eae3c1a6d3cfa","modified":1559114337684},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1559114337685},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"c45aa7ec00158579e58f1f8dfd890447bb5e5e54","modified":1559114337685},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"4102d446f13b02ff617f055c2a8f726bca12744a","modified":1559114337685},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"19431336d724d2118e46da43683bce9063176541","modified":1559114337685},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6e8e4123cca38840c4607c1a056205972b82bb7b","modified":1559114337685},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1559114337685},{"_id":"themes/maupassant/source/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1559114337687},{"_id":"themes/maupassant/source/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1559114337688},{"_id":"themes/maupassant/source/css/style.scss","hash":"fa5dfd0867f95fe1708e6fda90e41db6364c01d9","modified":1559114337689},{"_id":"themes/maupassant/source/donate/index.html","hash":"c42428765d48c8674ce28100ad95fdf4c7806a85","modified":1559114337689},{"_id":"themes/maupassant/source/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1559114337690},{"_id":"themes/maupassant/source/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1559114337689},{"_id":"themes/maupassant/source/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1559114337690},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1559114337690},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1559114337690},{"_id":"themes/maupassant/source/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1559114337691},{"_id":"themes/maupassant/source/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1559114337691},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1559114337691},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1559114337691},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1559114337692},{"_id":"themes/maupassant/source/js/donate.js","hash":"780beaaf44b1e6c057752bdbc085b1048937e5e7","modified":1559114337692},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1559114337692},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1559114337693},{"_id":"themes/maupassant/source/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1559114337693},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1559114337694},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1559114337694},{"_id":"source/_posts/iOS-调试技巧/breakpoint1.png","hash":"a0506650a7562e9ff514b2549c416fee62486bb4","modified":1559111577650},{"_id":"source/_posts/iOS-调试技巧/breakpoint11.png","hash":"4b067ab8a8015ebd92b29b384a0349f8468d7cf3","modified":1559111577651},{"_id":"source/_posts/iOS-调试技巧/breakpoint14.png","hash":"548cdcc7649683caf3800099903ce4525aa5169f","modified":1559111577652},{"_id":"source/_posts/iOS-调试技巧/breakpoint6.png","hash":"4263f434e8feb051932cf4e4afc1fef873309960","modified":1559111577655},{"_id":"themes/maupassant/.git/objects/pack/pack-f799ed1b2f961451d291bec64cd0d8578ab30651.idx","hash":"074f00dbf5ba9e371cd13794f80e6067247054a2","modified":1559114337658},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"166458305b16424499927a509c874860afee76b4","modified":1559114337672},{"_id":"themes/maupassant/source/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1559114337693},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"6d8c3306736074b5464ad4972d5c4bbcb4ed5079","modified":1559114337673},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1559114337671},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"6d8c3306736074b5464ad4972d5c4bbcb4ed5079","modified":1559114337671},{"_id":"themes/maupassant/.git/objects/pack/pack-f799ed1b2f961451d291bec64cd0d8578ab30651.pack","hash":"d2768c214009eade300ea6d49142905f3f7f87d1","modified":1559114337657},{"_id":"public/about/index.html","hash":"13695f0a00b8d204724b05d5307e39d3113aee61","modified":1559461202082},{"_id":"public/category/index.html","hash":"4fe272251b691463c3b73530b17a31534680533a","modified":1559461202082},{"_id":"public/2019/06/10/iOS 中使用 Python/index.html","hash":"467667d9346d3c5e9ae8290097f0a1635cfbe77a","modified":1559461202082},{"_id":"public/2019/06/05/iOS-RunLoop/index.html","hash":"f9554dc73d4cd4271e04d91493c5013979073369","modified":1559461202083},{"_id":"public/2018/02/01/iOS-调试技巧/index.html","hash":"0e952f9f68681409358162dd6a0900c42b419620","modified":1559461202083},{"_id":"public/archives/index.html","hash":"e50cf723f7d038dfd18266f9666246717825284c","modified":1559461202083},{"_id":"public/archives/2018/index.html","hash":"d86b87717ad76f0ec6b332f88eb36d2a4d350e40","modified":1559461202083},{"_id":"public/archives/2018/02/index.html","hash":"d86b87717ad76f0ec6b332f88eb36d2a4d350e40","modified":1559461202083},{"_id":"public/archives/2019/index.html","hash":"b20f3495b6d37942f8f364b31d3a9f7b66502165","modified":1559461202083},{"_id":"public/archives/2019/05/index.html","hash":"3111f7e4a7967fad1e877800ee11ed5b66e22ab3","modified":1559461202083},{"_id":"public/archives/2019/06/index.html","hash":"7d54c00c93d565eccc7b5766eb00eaf967f2754e","modified":1559461202083},{"_id":"public/index.html","hash":"ae70e990dbccd791d1f114b9989741728c856a07","modified":1559461202083},{"_id":"public/tags/Git/index.html","hash":"2d71e345c5cef443e19b117ddb74ecade357e815","modified":1559461202083},{"_id":"public/tags/SVN/index.html","hash":"7e28c888b5c3012c99dced8f9aba592c218855a1","modified":1559461202083},{"_id":"public/tags/Python/index.html","hash":"44ced6a756f0b8ae125dce85b86b645bf942286c","modified":1559461202083},{"_id":"public/tags/iOS/index.html","hash":"4f37ff2aea30dccb1088b5b264c0a733256f5d08","modified":1559461202083},{"_id":"public/tags/Xcode/index.html","hash":"c1039b11296f8fb973a05215625370d6968db9de","modified":1559461202083},{"_id":"public/2019/05/30/iOS-Runtime/index.html","hash":"889082db9a23ed221a7d03a9cc0ca8043396e4b0","modified":1559461202083},{"_id":"public/2018/02/02/Git-常用命令/index.html","hash":"f39c9fe5e396b3ed99c40dc150f79e84da4d2813","modified":1559461202083},{"_id":"public/2018/02/01/SVN常用命令/index.html","hash":"e0c9322842342d4a669821a91b3120b9267e78a2","modified":1559461202084},{"_id":"public/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1559461202088},{"_id":"public/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1559461202089},{"_id":"public/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1559461202089},{"_id":"public/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1559461202089},{"_id":"public/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1559461202089},{"_id":"public/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1559461202089},{"_id":"public/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1559461202089},{"_id":"public/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1559461202089},{"_id":"public/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1559461202089},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint1.png","hash":"a0506650a7562e9ff514b2549c416fee62486bb4","modified":1559461202089},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint12.png","hash":"f85c679e23402f6e0b574a6efbfd6b6e235899de","modified":1559461202089},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint13.png","hash":"e8a6a00b8789d9fe1f64f8493dc8b02bfdf0c364","modified":1559461202089},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint15.png","hash":"38648981010ff460e3d161ea49ec391889da29e1","modified":1559461202089},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint16.png","hash":"62914b63188fb033af2e27a8bd7f3e287cef5bd1","modified":1559461202089},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint4.png","hash":"cc514934e78224ac5e290fc38504c886a62b99d7","modified":1559461202089},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint5.png","hash":"2e6e00af53d5ea766a0b161e3ee826e20ffcc56a","modified":1559461202090},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint7.png","hash":"ad9cc81432c0a6c706989cfe1d722c7ea92d5e09","modified":1559461202090},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint8.png","hash":"3c226c35db2ffa9e22361fea4507cf68a4501d5b","modified":1559461202090},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint9.png","hash":"a92019c371a73409511be25879f2fc4966f67223","modified":1559461202090},{"_id":"public/2018/02/02/Git-常用命令/git_sections.png","hash":"7144c5e9e911d79586f90926a500a5ecb976b4d0","modified":1559461202092},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint11.png","hash":"4b067ab8a8015ebd92b29b384a0349f8468d7cf3","modified":1559461202093},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint14.png","hash":"548cdcc7649683caf3800099903ce4525aa5169f","modified":1559461202094},{"_id":"public/2018/02/01/iOS-调试技巧/breakpoint6.png","hash":"4263f434e8feb051932cf4e4afc1fef873309960","modified":1559461202094},{"_id":"public/2019/05/30/iOS-Runtime/object_model.png","hash":"d2ef6d4a90d58a581f72fc63d4c462adfee71872","modified":1559461202094},{"_id":"public/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1559461202098},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1559461202099},{"_id":"public/js/donate.js","hash":"89f0b9d9d0c4fce183161d29c2a44aef750efb27","modified":1559461202099},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1559461202099},{"_id":"public/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1559461202099},{"_id":"public/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1559461202099},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1559461202099},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1559461202099},{"_id":"public/donate/index.html","hash":"e94c928417ceaf6e2dae7eac2ccb5b106fd9c2a4","modified":1559461202100},{"_id":"public/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1559461202110},{"_id":"public/css/style.css","hash":"50dac51e44b24279f14cd3756bf1b388e5977f74","modified":1559461202175},{"_id":"public/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1559461202190}],"Category":[],"Data":[],"Page":[{"title":"","date":"2018-01-30T09:10:00.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: \ndate: 2018-01-30 17:10:00\n---\n","updated":"2019-05-29T06:32:57.656Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjwemxmyv0001ods6omz5t47q","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"category","date":"2018-02-06T06:48:11.000Z","_content":"iOS\nPython","source":"category/index.md","raw":"---\ntitle: category\ndate: 2018-02-06 14:48:11\n---\niOS\nPython","updated":"2019-05-29T06:32:57.657Z","path":"category/index.html","comments":1,"layout":"page","_id":"cjwemxnpc000hods6w8u6lar6","content":"<p>iOS<br>Python</p>\n","site":{"data":{}},"excerpt":"","more":"<p>iOS<br>Python</p>\n"}],"Post":[{"title":"Git-常用命令","date":"2018-02-02T02:25:47.000Z","_content":"\n### 1. Git分区：\n\n 工作区 (Working directory)：本地数据或者代码编辑区，数据或者代码操作区。\n\t暂存区 (Index cache)：数据或者代码暂时存放区。\n\t版本库 (Local repository)：存放已经提交的数据或者代码，此区数据或者代码直接push到远程仓库。\n\t分区之间数据传递流程图如下：\n###### ![](Git-常用命令/git_sections.png)\n### 2.  Git命令：\n\n#### (1) 基本操作\n```\n\tgit init                      //创建空仓库，当前目录下多出 .git 目录 \n\n\tgit add <file>                //将文件添加到缓存 \n\n\tgit status                    //查看在你上次提交之后是否有修改 \n\n\tgit diff                      //查看尚未缓存的修改\n\n\tgit diff --cached             //查看已经缓存的修改\n\n\tgit diff HEAD                 //查看已缓存和未缓存的所有修改\n\n\tgit diff --stat               //统计哪些文件发生了改变，有多少行产生了改动，并不会给出改动的具体内容\n\n\tgit commit -m\"message\"        //缓存区内容添加到仓库中\n\n\tgit commit -a                 //跳过 git add 提交缓存，直接commit\n\n\tgit reset HEAD  <file>        //取消之前 git add 添加，但不希望包含在下一提交快照中的缓存\n\n\tgit rm <file>                 //从工作目录中手工删除文件\n\n\tgit rm -f <file>              //强制删除之前修改过并且已经放到暂存区域的文件\n\n\tgit rm --cached <file>        //把文件从暂存区域移除，但仍然保留在当前工作目录中\n\n\tgit rm –r *                   //删除整个目录中的所有子目录和文件\n\n\tgit mv                        //移动或重命名一个文件、目录、软连接\n\n```\n\n#### (2) 分支管理\n```\n\tgit branch (branchname)        //创建分支\n\n\tgit checkout (branchname)      //切换分支\n\n\tgit checkout -b (branchname)   //加上-b参数表示创建并切换分支\n\n\tgit branch                     //列出所有分支，当前分支前面会标一个*号\n\n\tgit merge  (branchname)        //合并指定分支(branchname)到当前分支\n\n\tgit branch -d (branchname)     //删除分支\n\n```\n\n#### (3) 查看历史提交\n```\n\tgit log                         //查看提交历史\n\n\tgit log --oneline               //查看简洁的历史提交信息\n\n\tgit log --graph                 //查看分支合并图\n\n\tgit log --reverse --oneline     //逆向显示所有日志\n\n\tgit log --author                //查看指定用户的提交日志\n\n\tgit log --oneline --before={starttime}  --after={endtime}\n\n\tgit log --oneline --until={starttime}  --after={endtime}      //查看时间段的历史提交，后面加 --no-merges 选项以隐藏合并提交\n\n```\n\n#### (4) 添加标签\n```\n\tgit tag -a <tagname>                   //-a 选项意为创建一个带注解的标签，不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解\n\n\tgit tag                                //查看所有标签\n\n\tgit tag -a <tagname> -m\"标签信息\"       //指定标签信息\n\n```\n\n#### (5) Git 远程仓库\n```\n\tgit remote add [alias] [url]      //添加一个新的远程仓库， alias为远程仓库别名\n\n\tgit remote                        //查看当前配置的远程仓库\n\n\tgit fetch                         //从远程仓库下载新分支与数据，执行完后需要执行git merge 远程分支到你所在的分支\n\n\tgit push [alias] [branchname]     //推送新分支与数据到某个远端仓库\n\n\tgit remote rm [alias]             //删除远程仓库 \n\n```\n\n#### (6) Git rebase\n\n假设现在基于远程分支 *origin* ，创建一个叫 *mybranch* 的分支，然后在这个分支做一些修改。然后生成若干个提交 **(commit)**，但是与此同时，有些人也在 *origin* 分支上做了一些修改并且做了提交了。\n这就意味着 *origin* 和 *mybranch* 这两个分支各自<前进> 了，它们之间<分叉> 了。你可以用 *pull* 命令把 *origin* 分支上的修改拉下来并且和你的修改合并。\n结果看起来就像一个新的 *合并的提交* **(merge commit)**。如果你想让 *mybranch* 分支历史看起来像没有经过任何合并一样，可以用 git rebase ：\n```\n\tgit rebase origin\n\n```\n该命令会把你的 *mybranch* 分支里的每个提交 **(commit)** 取消掉，并且把它们临时保存为补丁 **(patch)** ( 这些补丁放到\" .git/rebase \"目录中 )。\n然后把 *mybranch* 分支更新到最新的 *origin* 分支，最后把保存的这些补丁应用到 *mybranch* 分支上。\n当 *mybranch* 分支更新之后，它会指向这些新创建的提交 **(commit)**, 而那些老的提交会被丢弃。 如果运行垃圾收集命令 **(pruning garbage collection)**, 这些被丢弃的提交就会删除。\n在 **rebase** 的过程中，也许会出现冲突 **(conflict)**. 在这种情况，Git 会停止 rebase 并会让你去解决冲突；在解决完冲突后，用 **git-add** 命令去更新这些内容的索引 (index), 然后，你无需执行**git-commit** ,只要执行 **continue** 命令，这样 git 会继续应用 **(apply)** 余下的补丁：\n\n```\n\tgit rebase --continue\n\n```\n任何时候，可以用** --abort **参数来终止 rebase 的行动，并且 *mybranch* 分支会回到 rebase 开始前的状态。\n```\n\tgit rebase --abort\n\n```","source":"_posts/Git-常用命令.md","raw":"---\ntitle: Git-常用命令\ndate: 2018-02-02 10:25:47\ntags: Git\n---\n\n### 1. Git分区：\n\n 工作区 (Working directory)：本地数据或者代码编辑区，数据或者代码操作区。\n\t暂存区 (Index cache)：数据或者代码暂时存放区。\n\t版本库 (Local repository)：存放已经提交的数据或者代码，此区数据或者代码直接push到远程仓库。\n\t分区之间数据传递流程图如下：\n###### ![](Git-常用命令/git_sections.png)\n### 2.  Git命令：\n\n#### (1) 基本操作\n```\n\tgit init                      //创建空仓库，当前目录下多出 .git 目录 \n\n\tgit add <file>                //将文件添加到缓存 \n\n\tgit status                    //查看在你上次提交之后是否有修改 \n\n\tgit diff                      //查看尚未缓存的修改\n\n\tgit diff --cached             //查看已经缓存的修改\n\n\tgit diff HEAD                 //查看已缓存和未缓存的所有修改\n\n\tgit diff --stat               //统计哪些文件发生了改变，有多少行产生了改动，并不会给出改动的具体内容\n\n\tgit commit -m\"message\"        //缓存区内容添加到仓库中\n\n\tgit commit -a                 //跳过 git add 提交缓存，直接commit\n\n\tgit reset HEAD  <file>        //取消之前 git add 添加，但不希望包含在下一提交快照中的缓存\n\n\tgit rm <file>                 //从工作目录中手工删除文件\n\n\tgit rm -f <file>              //强制删除之前修改过并且已经放到暂存区域的文件\n\n\tgit rm --cached <file>        //把文件从暂存区域移除，但仍然保留在当前工作目录中\n\n\tgit rm –r *                   //删除整个目录中的所有子目录和文件\n\n\tgit mv                        //移动或重命名一个文件、目录、软连接\n\n```\n\n#### (2) 分支管理\n```\n\tgit branch (branchname)        //创建分支\n\n\tgit checkout (branchname)      //切换分支\n\n\tgit checkout -b (branchname)   //加上-b参数表示创建并切换分支\n\n\tgit branch                     //列出所有分支，当前分支前面会标一个*号\n\n\tgit merge  (branchname)        //合并指定分支(branchname)到当前分支\n\n\tgit branch -d (branchname)     //删除分支\n\n```\n\n#### (3) 查看历史提交\n```\n\tgit log                         //查看提交历史\n\n\tgit log --oneline               //查看简洁的历史提交信息\n\n\tgit log --graph                 //查看分支合并图\n\n\tgit log --reverse --oneline     //逆向显示所有日志\n\n\tgit log --author                //查看指定用户的提交日志\n\n\tgit log --oneline --before={starttime}  --after={endtime}\n\n\tgit log --oneline --until={starttime}  --after={endtime}      //查看时间段的历史提交，后面加 --no-merges 选项以隐藏合并提交\n\n```\n\n#### (4) 添加标签\n```\n\tgit tag -a <tagname>                   //-a 选项意为创建一个带注解的标签，不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解\n\n\tgit tag                                //查看所有标签\n\n\tgit tag -a <tagname> -m\"标签信息\"       //指定标签信息\n\n```\n\n#### (5) Git 远程仓库\n```\n\tgit remote add [alias] [url]      //添加一个新的远程仓库， alias为远程仓库别名\n\n\tgit remote                        //查看当前配置的远程仓库\n\n\tgit fetch                         //从远程仓库下载新分支与数据，执行完后需要执行git merge 远程分支到你所在的分支\n\n\tgit push [alias] [branchname]     //推送新分支与数据到某个远端仓库\n\n\tgit remote rm [alias]             //删除远程仓库 \n\n```\n\n#### (6) Git rebase\n\n假设现在基于远程分支 *origin* ，创建一个叫 *mybranch* 的分支，然后在这个分支做一些修改。然后生成若干个提交 **(commit)**，但是与此同时，有些人也在 *origin* 分支上做了一些修改并且做了提交了。\n这就意味着 *origin* 和 *mybranch* 这两个分支各自<前进> 了，它们之间<分叉> 了。你可以用 *pull* 命令把 *origin* 分支上的修改拉下来并且和你的修改合并。\n结果看起来就像一个新的 *合并的提交* **(merge commit)**。如果你想让 *mybranch* 分支历史看起来像没有经过任何合并一样，可以用 git rebase ：\n```\n\tgit rebase origin\n\n```\n该命令会把你的 *mybranch* 分支里的每个提交 **(commit)** 取消掉，并且把它们临时保存为补丁 **(patch)** ( 这些补丁放到\" .git/rebase \"目录中 )。\n然后把 *mybranch* 分支更新到最新的 *origin* 分支，最后把保存的这些补丁应用到 *mybranch* 分支上。\n当 *mybranch* 分支更新之后，它会指向这些新创建的提交 **(commit)**, 而那些老的提交会被丢弃。 如果运行垃圾收集命令 **(pruning garbage collection)**, 这些被丢弃的提交就会删除。\n在 **rebase** 的过程中，也许会出现冲突 **(conflict)**. 在这种情况，Git 会停止 rebase 并会让你去解决冲突；在解决完冲突后，用 **git-add** 命令去更新这些内容的索引 (index), 然后，你无需执行**git-commit** ,只要执行 **continue** 命令，这样 git 会继续应用 **(apply)** 余下的补丁：\n\n```\n\tgit rebase --continue\n\n```\n任何时候，可以用** --abort **参数来终止 rebase 的行动，并且 *mybranch* 分支会回到 rebase 开始前的状态。\n```\n\tgit rebase --abort\n\n```","slug":"Git-常用命令","published":1,"updated":"2019-06-01T06:52:15.085Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwemxmyo0000ods6e8gnf7tm","content":"<h3 id=\"1-Git分区：\"><a href=\"#1-Git分区：\" class=\"headerlink\" title=\"1. Git分区：\"></a>1. Git分区：</h3><p> 工作区 (Working directory)：本地数据或者代码编辑区，数据或者代码操作区。<br>    暂存区 (Index cache)：数据或者代码暂时存放区。<br>    版本库 (Local repository)：存放已经提交的数据或者代码，此区数据或者代码直接push到远程仓库。<br>    分区之间数据传递流程图如下：</p>\n<h6 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"/2018/02/02/Git-常用命令/git_sections.png\" alt=\"\"></h6><h3 id=\"2-Git命令：\"><a href=\"#2-Git命令：\" class=\"headerlink\" title=\"2.  Git命令：\"></a>2.  Git命令：</h3><h4 id=\"1-基本操作\"><a href=\"#1-基本操作\" class=\"headerlink\" title=\"(1) 基本操作\"></a>(1) 基本操作</h4><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init                      <span class=\"comment\">//创建空仓库，当前目录下多出 .git 目录 </span></span><br><span class=\"line\"></span><br><span class=\"line\">git add &lt;<span class=\"keyword\">file</span>&gt;                <span class=\"comment\">//将文件添加到缓存 </span></span><br><span class=\"line\"></span><br><span class=\"line\">git status                    <span class=\"comment\">//查看在你上次提交之后是否有修改 </span></span><br><span class=\"line\"></span><br><span class=\"line\">git diff                      <span class=\"comment\">//查看尚未缓存的修改</span></span><br><span class=\"line\"></span><br><span class=\"line\">git diff --cached             <span class=\"comment\">//查看已经缓存的修改</span></span><br><span class=\"line\"></span><br><span class=\"line\">git diff HEAD                 <span class=\"comment\">//查看已缓存和未缓存的所有修改</span></span><br><span class=\"line\"></span><br><span class=\"line\">git diff --stat               <span class=\"comment\">//统计哪些文件发生了改变，有多少行产生了改动，并不会给出改动的具体内容</span></span><br><span class=\"line\"></span><br><span class=\"line\">git commit -<span class=\"keyword\">m</span><span class=\"string\">\"message\"</span>        <span class=\"comment\">//缓存区内容添加到仓库中</span></span><br><span class=\"line\"></span><br><span class=\"line\">git commit -a                 <span class=\"comment\">//跳过 git add 提交缓存，直接commit</span></span><br><span class=\"line\"></span><br><span class=\"line\">git reset HEAD  &lt;<span class=\"keyword\">file</span>&gt;        <span class=\"comment\">//取消之前 git add 添加，但不希望包含在下一提交快照中的缓存</span></span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">rm</span> &lt;<span class=\"keyword\">file</span>&gt;                 <span class=\"comment\">//从工作目录中手工删除文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">rm</span> -f &lt;<span class=\"keyword\">file</span>&gt;              <span class=\"comment\">//强制删除之前修改过并且已经放到暂存区域的文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">rm</span> --cached &lt;<span class=\"keyword\">file</span>&gt;        <span class=\"comment\">//把文件从暂存区域移除，但仍然保留在当前工作目录中</span></span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">rm</span> –r *                   <span class=\"comment\">//删除整个目录中的所有子目录和文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">git mv                        <span class=\"comment\">//移动或重命名一个文件、目录、软连接</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-分支管理\"><a href=\"#2-分支管理\" class=\"headerlink\" title=\"(2) 分支管理\"></a>(2) 分支管理</h4><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">git</span> <span class=\"keyword\">branch </span>(<span class=\"keyword\">branchname) </span>       //创建分支</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">git</span> checkout (<span class=\"keyword\">branchname) </span>     //切换分支</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">git</span> checkout -<span class=\"keyword\">b </span>(<span class=\"keyword\">branchname) </span>  //加上-<span class=\"keyword\">b参数表示创建并切换分支</span></span><br><span class=\"line\"><span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">git </span><span class=\"keyword\">branch </span>                    //列出所有分支，当前分支前面会标一个*号</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">git</span> merge  (<span class=\"keyword\">branchname) </span>       //合并指定分支(<span class=\"keyword\">branchname)到当前分支</span></span><br><span class=\"line\"><span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">git </span><span class=\"keyword\">branch </span>-d (<span class=\"keyword\">branchname) </span>    //删除分支</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-查看历史提交\"><a href=\"#3-查看历史提交\" class=\"headerlink\" title=\"(3) 查看历史提交\"></a>(3) 查看历史提交</h4><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log                         <span class=\"string\">//</span>查看提交历史</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--oneline</span>               <span class=\"string\">//</span>查看简洁的历史提交信息</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--graph</span>                 <span class=\"string\">//</span>查看分支合并图</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--reverse</span> <span class=\"params\">--oneline</span>     <span class=\"string\">//</span>逆向显示所有日志</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--author</span>                <span class=\"string\">//</span>查看指定用户的提交日志</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--oneline</span> <span class=\"params\">--before=</span>&#123;starttime&#125;  <span class=\"params\">--after=</span>&#123;endtime&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--oneline</span> <span class=\"params\">--until=</span>&#123;starttime&#125;  <span class=\"params\">--after=</span>&#123;endtime&#125;      <span class=\"string\">//</span>查看时间段的历史提交，后面加 <span class=\"params\">--no-merges</span> 选项以隐藏合并提交</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-添加标签\"><a href=\"#4-添加标签\" class=\"headerlink\" title=\"(4) 添加标签\"></a>(4) 添加标签</h4><figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"keyword\">tag</span> <span class=\"title\">-a</span> <span class=\"tag\">&lt;tagname&gt;</span>                   //-a 选项意为创建一个带注解的标签，不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解</span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">tag</span>                                <span class=\"title\">//查看所有标签</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br><span class=\"line\"><span class=\"title\">git</span> <span class=\"keyword\">tag</span> <span class=\"title\">-a</span> <span class=\"tag\">&lt;tagname&gt;</span> -m<span class=\"string\">\"标签信息\"</span>       //指定标签信息</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-Git-远程仓库\"><a href=\"#5-Git-远程仓库\" class=\"headerlink\" title=\"(5) Git 远程仓库\"></a>(5) Git 远程仓库</h4><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">git</span> <span class=\"selector-tag\">remote</span> <span class=\"selector-tag\">add</span> <span class=\"selector-attr\">[alias]</span> <span class=\"selector-attr\">[url]</span>      <span class=\"comment\">//添加一个新的远程仓库， alias为远程仓库别名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">git</span> <span class=\"selector-tag\">remote</span>                        <span class=\"comment\">//查看当前配置的远程仓库</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">git</span> <span class=\"selector-tag\">fetch</span>                         <span class=\"comment\">//从远程仓库下载新分支与数据，执行完后需要执行git merge 远程分支到你所在的分支</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">git</span> <span class=\"selector-tag\">push</span> <span class=\"selector-attr\">[alias]</span> <span class=\"selector-attr\">[branchname]</span>     <span class=\"comment\">//推送新分支与数据到某个远端仓库</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">git</span> <span class=\"selector-tag\">remote</span> <span class=\"selector-tag\">rm</span> <span class=\"selector-attr\">[alias]</span>             <span class=\"comment\">//删除远程仓库</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"6-Git-rebase\"><a href=\"#6-Git-rebase\" class=\"headerlink\" title=\"(6) Git rebase\"></a>(6) Git rebase</h4><p>假设现在基于远程分支 <em>origin</em> ，创建一个叫 <em>mybranch</em> 的分支，然后在这个分支做一些修改。然后生成若干个提交 <strong>(commit)</strong>，但是与此同时，有些人也在 <em>origin</em> 分支上做了一些修改并且做了提交了。<br>这就意味着 <em>origin</em> 和 <em>mybranch</em> 这两个分支各自&lt;前进&gt; 了，它们之间&lt;分叉&gt; 了。你可以用 <em>pull</em> 命令把 <em>origin</em> 分支上的修改拉下来并且和你的修改合并。<br>结果看起来就像一个新的 <em>合并的提交</em> <strong>(merge commit)</strong>。如果你想让 <em>mybranch</em> 分支历史看起来像没有经过任何合并一样，可以用 git rebase ：<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">git rebase origin</span></span><br></pre></td></tr></table></figure></p>\n<p>该命令会把你的 <em>mybranch</em> 分支里的每个提交 <strong>(commit)</strong> 取消掉，并且把它们临时保存为补丁 <strong>(patch)</strong> ( 这些补丁放到” .git/rebase “目录中 )。<br>然后把 <em>mybranch</em> 分支更新到最新的 <em>origin</em> 分支，最后把保存的这些补丁应用到 <em>mybranch</em> 分支上。<br>当 <em>mybranch</em> 分支更新之后，它会指向这些新创建的提交 <strong>(commit)</strong>, 而那些老的提交会被丢弃。 如果运行垃圾收集命令 <strong>(pruning garbage collection)</strong>, 这些被丢弃的提交就会删除。<br>在 <strong>rebase</strong> 的过程中，也许会出现冲突 <strong>(conflict)</strong>. 在这种情况，Git 会停止 rebase 并会让你去解决冲突；在解决完冲突后，用 <strong>git-add</strong> 命令去更新这些内容的索引 (index), 然后，你无需执行<strong>git-commit</strong> ,只要执行 <strong>continue</strong> 命令，这样 git 会继续应用 <strong>(apply)</strong> 余下的补丁：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase --<span class=\"keyword\">continue</span></span><br></pre></td></tr></table></figure>\n<p>任何时候，可以用<strong> –abort </strong>参数来终止 rebase 的行动，并且 <em>mybranch</em> 分支会回到 rebase 开始前的状态。<br><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase <span class=\"comment\">--abort</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-Git分区：\"><a href=\"#1-Git分区：\" class=\"headerlink\" title=\"1. Git分区：\"></a>1. Git分区：</h3><p> 工作区 (Working directory)：本地数据或者代码编辑区，数据或者代码操作区。<br>    暂存区 (Index cache)：数据或者代码暂时存放区。<br>    版本库 (Local repository)：存放已经提交的数据或者代码，此区数据或者代码直接push到远程仓库。<br>    分区之间数据传递流程图如下：</p>\n<h6 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"/2018/02/02/Git-常用命令/git_sections.png\" alt=\"\"></h6><h3 id=\"2-Git命令：\"><a href=\"#2-Git命令：\" class=\"headerlink\" title=\"2.  Git命令：\"></a>2.  Git命令：</h3><h4 id=\"1-基本操作\"><a href=\"#1-基本操作\" class=\"headerlink\" title=\"(1) 基本操作\"></a>(1) 基本操作</h4><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init                      <span class=\"comment\">//创建空仓库，当前目录下多出 .git 目录 </span></span><br><span class=\"line\"></span><br><span class=\"line\">git add &lt;<span class=\"keyword\">file</span>&gt;                <span class=\"comment\">//将文件添加到缓存 </span></span><br><span class=\"line\"></span><br><span class=\"line\">git status                    <span class=\"comment\">//查看在你上次提交之后是否有修改 </span></span><br><span class=\"line\"></span><br><span class=\"line\">git diff                      <span class=\"comment\">//查看尚未缓存的修改</span></span><br><span class=\"line\"></span><br><span class=\"line\">git diff --cached             <span class=\"comment\">//查看已经缓存的修改</span></span><br><span class=\"line\"></span><br><span class=\"line\">git diff HEAD                 <span class=\"comment\">//查看已缓存和未缓存的所有修改</span></span><br><span class=\"line\"></span><br><span class=\"line\">git diff --stat               <span class=\"comment\">//统计哪些文件发生了改变，有多少行产生了改动，并不会给出改动的具体内容</span></span><br><span class=\"line\"></span><br><span class=\"line\">git commit -<span class=\"keyword\">m</span><span class=\"string\">\"message\"</span>        <span class=\"comment\">//缓存区内容添加到仓库中</span></span><br><span class=\"line\"></span><br><span class=\"line\">git commit -a                 <span class=\"comment\">//跳过 git add 提交缓存，直接commit</span></span><br><span class=\"line\"></span><br><span class=\"line\">git reset HEAD  &lt;<span class=\"keyword\">file</span>&gt;        <span class=\"comment\">//取消之前 git add 添加，但不希望包含在下一提交快照中的缓存</span></span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">rm</span> &lt;<span class=\"keyword\">file</span>&gt;                 <span class=\"comment\">//从工作目录中手工删除文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">rm</span> -f &lt;<span class=\"keyword\">file</span>&gt;              <span class=\"comment\">//强制删除之前修改过并且已经放到暂存区域的文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">rm</span> --cached &lt;<span class=\"keyword\">file</span>&gt;        <span class=\"comment\">//把文件从暂存区域移除，但仍然保留在当前工作目录中</span></span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">rm</span> –r *                   <span class=\"comment\">//删除整个目录中的所有子目录和文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">git mv                        <span class=\"comment\">//移动或重命名一个文件、目录、软连接</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-分支管理\"><a href=\"#2-分支管理\" class=\"headerlink\" title=\"(2) 分支管理\"></a>(2) 分支管理</h4><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">git</span> <span class=\"keyword\">branch </span>(<span class=\"keyword\">branchname) </span>       //创建分支</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">git</span> checkout (<span class=\"keyword\">branchname) </span>     //切换分支</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">git</span> checkout -<span class=\"keyword\">b </span>(<span class=\"keyword\">branchname) </span>  //加上-<span class=\"keyword\">b参数表示创建并切换分支</span></span><br><span class=\"line\"><span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">git </span><span class=\"keyword\">branch </span>                    //列出所有分支，当前分支前面会标一个*号</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">git</span> merge  (<span class=\"keyword\">branchname) </span>       //合并指定分支(<span class=\"keyword\">branchname)到当前分支</span></span><br><span class=\"line\"><span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">git </span><span class=\"keyword\">branch </span>-d (<span class=\"keyword\">branchname) </span>    //删除分支</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-查看历史提交\"><a href=\"#3-查看历史提交\" class=\"headerlink\" title=\"(3) 查看历史提交\"></a>(3) 查看历史提交</h4><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log                         <span class=\"string\">//</span>查看提交历史</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--oneline</span>               <span class=\"string\">//</span>查看简洁的历史提交信息</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--graph</span>                 <span class=\"string\">//</span>查看分支合并图</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--reverse</span> <span class=\"params\">--oneline</span>     <span class=\"string\">//</span>逆向显示所有日志</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--author</span>                <span class=\"string\">//</span>查看指定用户的提交日志</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--oneline</span> <span class=\"params\">--before=</span>&#123;starttime&#125;  <span class=\"params\">--after=</span>&#123;endtime&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">git log <span class=\"params\">--oneline</span> <span class=\"params\">--until=</span>&#123;starttime&#125;  <span class=\"params\">--after=</span>&#123;endtime&#125;      <span class=\"string\">//</span>查看时间段的历史提交，后面加 <span class=\"params\">--no-merges</span> 选项以隐藏合并提交</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-添加标签\"><a href=\"#4-添加标签\" class=\"headerlink\" title=\"(4) 添加标签\"></a>(4) 添加标签</h4><figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"keyword\">tag</span> <span class=\"title\">-a</span> <span class=\"tag\">&lt;tagname&gt;</span>                   //-a 选项意为创建一个带注解的标签，不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解</span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"keyword\">tag</span>                                <span class=\"title\">//查看所有标签</span></span><br><span class=\"line\"><span class=\"title\"></span></span><br><span class=\"line\"><span class=\"title\">git</span> <span class=\"keyword\">tag</span> <span class=\"title\">-a</span> <span class=\"tag\">&lt;tagname&gt;</span> -m<span class=\"string\">\"标签信息\"</span>       //指定标签信息</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-Git-远程仓库\"><a href=\"#5-Git-远程仓库\" class=\"headerlink\" title=\"(5) Git 远程仓库\"></a>(5) Git 远程仓库</h4><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">git</span> <span class=\"selector-tag\">remote</span> <span class=\"selector-tag\">add</span> <span class=\"selector-attr\">[alias]</span> <span class=\"selector-attr\">[url]</span>      <span class=\"comment\">//添加一个新的远程仓库， alias为远程仓库别名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">git</span> <span class=\"selector-tag\">remote</span>                        <span class=\"comment\">//查看当前配置的远程仓库</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">git</span> <span class=\"selector-tag\">fetch</span>                         <span class=\"comment\">//从远程仓库下载新分支与数据，执行完后需要执行git merge 远程分支到你所在的分支</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">git</span> <span class=\"selector-tag\">push</span> <span class=\"selector-attr\">[alias]</span> <span class=\"selector-attr\">[branchname]</span>     <span class=\"comment\">//推送新分支与数据到某个远端仓库</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">git</span> <span class=\"selector-tag\">remote</span> <span class=\"selector-tag\">rm</span> <span class=\"selector-attr\">[alias]</span>             <span class=\"comment\">//删除远程仓库</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"6-Git-rebase\"><a href=\"#6-Git-rebase\" class=\"headerlink\" title=\"(6) Git rebase\"></a>(6) Git rebase</h4><p>假设现在基于远程分支 <em>origin</em> ，创建一个叫 <em>mybranch</em> 的分支，然后在这个分支做一些修改。然后生成若干个提交 <strong>(commit)</strong>，但是与此同时，有些人也在 <em>origin</em> 分支上做了一些修改并且做了提交了。<br>这就意味着 <em>origin</em> 和 <em>mybranch</em> 这两个分支各自&lt;前进&gt; 了，它们之间&lt;分叉&gt; 了。你可以用 <em>pull</em> 命令把 <em>origin</em> 分支上的修改拉下来并且和你的修改合并。<br>结果看起来就像一个新的 <em>合并的提交</em> <strong>(merge commit)</strong>。如果你想让 <em>mybranch</em> 分支历史看起来像没有经过任何合并一样，可以用 git rebase ：<br><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">git rebase origin</span></span><br></pre></td></tr></table></figure></p>\n<p>该命令会把你的 <em>mybranch</em> 分支里的每个提交 <strong>(commit)</strong> 取消掉，并且把它们临时保存为补丁 <strong>(patch)</strong> ( 这些补丁放到” .git/rebase “目录中 )。<br>然后把 <em>mybranch</em> 分支更新到最新的 <em>origin</em> 分支，最后把保存的这些补丁应用到 <em>mybranch</em> 分支上。<br>当 <em>mybranch</em> 分支更新之后，它会指向这些新创建的提交 <strong>(commit)</strong>, 而那些老的提交会被丢弃。 如果运行垃圾收集命令 <strong>(pruning garbage collection)</strong>, 这些被丢弃的提交就会删除。<br>在 <strong>rebase</strong> 的过程中，也许会出现冲突 <strong>(conflict)</strong>. 在这种情况，Git 会停止 rebase 并会让你去解决冲突；在解决完冲突后，用 <strong>git-add</strong> 命令去更新这些内容的索引 (index), 然后，你无需执行<strong>git-commit</strong> ,只要执行 <strong>continue</strong> 命令，这样 git 会继续应用 <strong>(apply)</strong> 余下的补丁：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase --<span class=\"keyword\">continue</span></span><br></pre></td></tr></table></figure>\n<p>任何时候，可以用<strong> –abort </strong>参数来终止 rebase 的行动，并且 <em>mybranch</em> 分支会回到 rebase 开始前的状态。<br><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase <span class=\"comment\">--abort</span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"SVN-常用命令","date":"2018-02-01T10:13:48.000Z","_content":"\n### 1. 检出: checkout 缩写 co\n如果不带 --password  参数传输密码的话，会提示输入密码，建议不要用明文的 --password 选项。其中 username 与 password前是两个短线，不是一个。默认check到当前目录。\n```\n    svn  checkout  http://路径(目录或文件的全路径)　[本地目录全路径] --username　用户名\n    svn  checkout  svn://路径(目录或文件的全路径)　 [本地目录全路径] --username　用户名\n\n    //例子：\n    svn co svn://localhost/files          --username taotao\n    svn checkout http://localhost/files   --username taotao\n```\n### 2. 导出(导出一个干净的不带.svn文件夹的目录树)\n```\n    svn  export  [-r 版本号]  http: //路径(目录或文件的全路径) --username　用户名\n    svn  export  [-r 版本号]  svn:  //路径(目录或文件的全路径) --username　用户名\n    svn  export  本地检出的(即带有.svn文件夹的)目录全路径  要导出的本地目录全路径\n\n    //例子：\n    svn export svn://localhost/files --username wzhnsc\n    svn export svn://localhost/files --username wzhnsc\n    svn export /home/files /home/tofiles\n    ```\n### 3. 添加新文件: add\n```\n    svn　add　文件名\n\n    //例子：\n    svn add picture.png\n```\n### 4. 提交: commit 缩写 ci\n```\n    svn　commit　-m　“提交备注信息文本“　[-N]　[--no-unlock]　文件名\n    svn　ci　-m　“提交备注信息文本“　    [-N]　[--no-unlock]　文件名\n\n    //例子：\n    svn commit -m “提交我的测试用test.swift“ test.swift\n    svn ci -m “提交我的测试用test.swift“ test.swift\n```\n### 5. 更新文件: update\n```\n    svn　update\n    svn　update　-r　修正版本　文件名\n    svn　update　文件名\n\n    //例子：\n    svn update      \n\n    //后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本\n\n    svn update -r 200 test.swift    \n\n    //将版本库中的文件 test.swift还原到修正版本（revision）200\n\n    //svn update test.swift\n\n    //更新与版本库同步。提交的时候提示过期冲突，需要先update修改文件，然后清除\n    svn resolved，最后再提交commit。\n```\n### 6. 删除文件: delete\n```\n    svn　delete　svn://路径(目录或文件的全路径) -m “删除备注信息文本”\n    svn　delete　文件名 \n\n    //例子：\n    svn delete svn://localhost/testapp/test.swift -m “删除测试文件test.swift”\n\n    //如下：\n    svn delete test.swift \n```\n### 7. 加锁: lock\n```\n    svn　lock　-m　“加锁备注信息文本“　[--force]　文件名 \n    svn　unlock　文件名\n\n    //例子：\n    svn lock -m “锁信测试用test.swift文件“ test.swift \n    svn unlock test.swift\n```\n### 8. 比较差异: diff\n```\n    svn　diff　     文件名 \n    svn　diff　-r　 修正版本号m:修正版本号n　文件名\n\n    //例子：\n    svn diff test.swift               \n\n    //将修改的文件与基础版本比较\n\n    svn diff -r 200:201 test.swift   \n\n    //对修正版本号200和修正版本号201比较差异\n```\n### 9. 查看文件或者目录状态: status  缩写 st\n```\n    svn st 目录路径/名\n\n    //目录下的文件和子目录的状态，正常状态不显示 //?：不在svn的控制中M：内容被修改；C：发生冲突A：预定加入到版本库 K：被锁定 \n\n    svn  -v 目录路径/名\n\n    svn status -v 目录路径/名\n\n    //显示文件和子目录状态,第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次\n    //修改的版本号和修改人\n```\n### 10. 查看日志: log\n```\n    svn　log　文件名\n\n    //例子：\n    svn log test.swift    \n\n    //显示这个文件的所有修改记录，及其版本号的变化\n```\n### 11. 查看文件详细信息: info\n```\n    svn　info　文件名\n\n    //例子：\n    svn info test.swift\n```\n### 12. 查看版本库下的文件和目录列表: list 缩写 ls\n```\n    svn　list　svn://路径(目录或文件的全路径)\n    svn　ls　svn://路径(目录或文件的全路径)\n\n    //例子：\n    svn list svn://localhost/test\n    svn ls svn://localhost/test   \n\n    //显示svn://localhost/test目录下的所有属于版本库的文件和目录 \n```\n### 13. 恢复本地修改: revert\n```\n    svn　revert　[--recursive]　文件名\n\n    //注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录。\n\n    //例子：\n    svn revert taotao.swift      \n\n    //丢弃对一个文件的修改\n\n    svn revert --recursive .     \n\n    //恢复一整个目录的文件，. 为当前目录 \n```\n### 14. 把工作拷贝更新到别的URL: switch\n```\n    svn　switch　http://目录全路径　  \n\n    //本地目录全路径\n\n    //例子：\n    svn switch http://localhost/test/456 .  \n\n    //(原为123的分支)当前所在目录分支到\n```\n### 15. 新建分支: copy\n```\n    svn copy\n\n    //例子：\n    svn copy branchA branchB  -m \"make B branch\"\n    //从branchA拷贝出一个新分支branchB\n```\n### 16. 合并分支: merge\n```\n    //例子：\n    svn merge branchA branchB  \n\n    //把对branchA的修改合并到分支branchB\n```\n### 17. 解决冲突：resolved\n```\n    svn　resolved　[本地目录全路径]\n\n    //例子：\n    $ svn update\n    C foo.c\n    Updated to revision 31.\n    //如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：\n\n    $ ls\n    foo.c\n    foo.c.mine\n    foo.c.r30\n    foo.c.r31\n    //当你解决了foo.c的冲突，并且准备提交，\n    //运行svn resolved让你的工作拷贝知道你已经完成了所有事情。\n    //你可以仅仅删除冲突的文件并且提交，\n    //但是svn resolved除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据。\n```\n","source":"_posts/SVN常用命令.md","raw":"---\ntitle: SVN-常用命令\ndate: 2018-02-01 18:13:48\ntags: SVN\n---\n\n### 1. 检出: checkout 缩写 co\n如果不带 --password  参数传输密码的话，会提示输入密码，建议不要用明文的 --password 选项。其中 username 与 password前是两个短线，不是一个。默认check到当前目录。\n```\n    svn  checkout  http://路径(目录或文件的全路径)　[本地目录全路径] --username　用户名\n    svn  checkout  svn://路径(目录或文件的全路径)　 [本地目录全路径] --username　用户名\n\n    //例子：\n    svn co svn://localhost/files          --username taotao\n    svn checkout http://localhost/files   --username taotao\n```\n### 2. 导出(导出一个干净的不带.svn文件夹的目录树)\n```\n    svn  export  [-r 版本号]  http: //路径(目录或文件的全路径) --username　用户名\n    svn  export  [-r 版本号]  svn:  //路径(目录或文件的全路径) --username　用户名\n    svn  export  本地检出的(即带有.svn文件夹的)目录全路径  要导出的本地目录全路径\n\n    //例子：\n    svn export svn://localhost/files --username wzhnsc\n    svn export svn://localhost/files --username wzhnsc\n    svn export /home/files /home/tofiles\n    ```\n### 3. 添加新文件: add\n```\n    svn　add　文件名\n\n    //例子：\n    svn add picture.png\n```\n### 4. 提交: commit 缩写 ci\n```\n    svn　commit　-m　“提交备注信息文本“　[-N]　[--no-unlock]　文件名\n    svn　ci　-m　“提交备注信息文本“　    [-N]　[--no-unlock]　文件名\n\n    //例子：\n    svn commit -m “提交我的测试用test.swift“ test.swift\n    svn ci -m “提交我的测试用test.swift“ test.swift\n```\n### 5. 更新文件: update\n```\n    svn　update\n    svn　update　-r　修正版本　文件名\n    svn　update　文件名\n\n    //例子：\n    svn update      \n\n    //后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本\n\n    svn update -r 200 test.swift    \n\n    //将版本库中的文件 test.swift还原到修正版本（revision）200\n\n    //svn update test.swift\n\n    //更新与版本库同步。提交的时候提示过期冲突，需要先update修改文件，然后清除\n    svn resolved，最后再提交commit。\n```\n### 6. 删除文件: delete\n```\n    svn　delete　svn://路径(目录或文件的全路径) -m “删除备注信息文本”\n    svn　delete　文件名 \n\n    //例子：\n    svn delete svn://localhost/testapp/test.swift -m “删除测试文件test.swift”\n\n    //如下：\n    svn delete test.swift \n```\n### 7. 加锁: lock\n```\n    svn　lock　-m　“加锁备注信息文本“　[--force]　文件名 \n    svn　unlock　文件名\n\n    //例子：\n    svn lock -m “锁信测试用test.swift文件“ test.swift \n    svn unlock test.swift\n```\n### 8. 比较差异: diff\n```\n    svn　diff　     文件名 \n    svn　diff　-r　 修正版本号m:修正版本号n　文件名\n\n    //例子：\n    svn diff test.swift               \n\n    //将修改的文件与基础版本比较\n\n    svn diff -r 200:201 test.swift   \n\n    //对修正版本号200和修正版本号201比较差异\n```\n### 9. 查看文件或者目录状态: status  缩写 st\n```\n    svn st 目录路径/名\n\n    //目录下的文件和子目录的状态，正常状态不显示 //?：不在svn的控制中M：内容被修改；C：发生冲突A：预定加入到版本库 K：被锁定 \n\n    svn  -v 目录路径/名\n\n    svn status -v 目录路径/名\n\n    //显示文件和子目录状态,第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次\n    //修改的版本号和修改人\n```\n### 10. 查看日志: log\n```\n    svn　log　文件名\n\n    //例子：\n    svn log test.swift    \n\n    //显示这个文件的所有修改记录，及其版本号的变化\n```\n### 11. 查看文件详细信息: info\n```\n    svn　info　文件名\n\n    //例子：\n    svn info test.swift\n```\n### 12. 查看版本库下的文件和目录列表: list 缩写 ls\n```\n    svn　list　svn://路径(目录或文件的全路径)\n    svn　ls　svn://路径(目录或文件的全路径)\n\n    //例子：\n    svn list svn://localhost/test\n    svn ls svn://localhost/test   \n\n    //显示svn://localhost/test目录下的所有属于版本库的文件和目录 \n```\n### 13. 恢复本地修改: revert\n```\n    svn　revert　[--recursive]　文件名\n\n    //注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录。\n\n    //例子：\n    svn revert taotao.swift      \n\n    //丢弃对一个文件的修改\n\n    svn revert --recursive .     \n\n    //恢复一整个目录的文件，. 为当前目录 \n```\n### 14. 把工作拷贝更新到别的URL: switch\n```\n    svn　switch　http://目录全路径　  \n\n    //本地目录全路径\n\n    //例子：\n    svn switch http://localhost/test/456 .  \n\n    //(原为123的分支)当前所在目录分支到\n```\n### 15. 新建分支: copy\n```\n    svn copy\n\n    //例子：\n    svn copy branchA branchB  -m \"make B branch\"\n    //从branchA拷贝出一个新分支branchB\n```\n### 16. 合并分支: merge\n```\n    //例子：\n    svn merge branchA branchB  \n\n    //把对branchA的修改合并到分支branchB\n```\n### 17. 解决冲突：resolved\n```\n    svn　resolved　[本地目录全路径]\n\n    //例子：\n    $ svn update\n    C foo.c\n    Updated to revision 31.\n    //如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：\n\n    $ ls\n    foo.c\n    foo.c.mine\n    foo.c.r30\n    foo.c.r31\n    //当你解决了foo.c的冲突，并且准备提交，\n    //运行svn resolved让你的工作拷贝知道你已经完成了所有事情。\n    //你可以仅仅删除冲突的文件并且提交，\n    //但是svn resolved除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据。\n```\n","slug":"SVN常用命令","published":1,"updated":"2019-05-31T09:37:39.336Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwemxmyw0002ods65echecsh","content":"<h3 id=\"1-检出-checkout-缩写-co\"><a href=\"#1-检出-checkout-缩写-co\" class=\"headerlink\" title=\"1. 检出: checkout 缩写 co\"></a>1. 检出: checkout 缩写 co</h3><p>如果不带 –password  参数传输密码的话，会提示输入密码，建议不要用明文的 –password 选项。其中 username 与 password前是两个短线，不是一个。默认check到当前目录。<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn  checkout  <span class=\"string\">http:</span><span class=\"comment\">//路径(目录或文件的全路径)　[本地目录全路径] --username　用户名</span></span><br><span class=\"line\">svn  checkout  <span class=\"string\">svn:</span><span class=\"comment\">//路径(目录或文件的全路径)　 [本地目录全路径] --username　用户名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn co <span class=\"string\">svn:</span><span class=\"comment\">//localhost/files          --username taotao</span></span><br><span class=\"line\">svn checkout <span class=\"string\">http:</span><span class=\"comment\">//localhost/files   --username taotao</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-导出-导出一个干净的不带-svn文件夹的目录树\"><a href=\"#2-导出-导出一个干净的不带-svn文件夹的目录树\" class=\"headerlink\" title=\"2. 导出(导出一个干净的不带.svn文件夹的目录树)\"></a>2. 导出(导出一个干净的不带.svn文件夹的目录树)</h3><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn  <span class=\"keyword\">export</span>  [-r 版本号]  http: <span class=\"comment\">//路径(目录或文件的全路径) --username　用户名</span></span><br><span class=\"line\">svn  <span class=\"keyword\">export</span>  [-r 版本号]  svn:  <span class=\"comment\">//路径(目录或文件的全路径) --username　用户名</span></span><br><span class=\"line\">svn  <span class=\"keyword\">export</span>  本地检出的(即带有.svn文件夹的)目录全路径  要导出的本地目录全路径</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn <span class=\"keyword\">export</span> svn:<span class=\"comment\">//localhost/files --username wzhnsc</span></span><br><span class=\"line\">svn <span class=\"keyword\">export</span> svn:<span class=\"comment\">//localhost/files --username wzhnsc</span></span><br><span class=\"line\">svn <span class=\"keyword\">export</span> /<span class=\"built_in\">home</span>/files /<span class=\"built_in\">home</span>/tofiles</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-添加新文件-add\"><a href=\"#3-添加新文件-add\" class=\"headerlink\" title=\"3. 添加新文件: add\"></a>3. 添加新文件: add</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">add</span><span class=\"bash\">　文件名</span></span><br><span class=\"line\"><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"bash\">//例子：</span></span><br><span class=\"line\"><span class=\"bash\">svn add picture.png</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-提交-commit-缩写-ci\"><a href=\"#4-提交-commit-缩写-ci\" class=\"headerlink\" title=\"4. 提交: commit 缩写 ci\"></a>4. 提交: commit 缩写 ci</h3><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　commit　-<span class=\"keyword\">m</span>　“提交备注信息文本“　[-<span class=\"keyword\">N</span>]　[--<span class=\"keyword\">no</span>-unlock]　文件名</span><br><span class=\"line\">svn　<span class=\"keyword\">ci</span>　-<span class=\"keyword\">m</span>　“提交备注信息文本“　    [-<span class=\"keyword\">N</span>]　[--<span class=\"keyword\">no</span>-unlock]　文件名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn commit -<span class=\"keyword\">m</span> “提交我的测试用<span class=\"keyword\">test</span>.swift“ <span class=\"keyword\">test</span>.swift</span><br><span class=\"line\">svn <span class=\"keyword\">ci</span> -<span class=\"keyword\">m</span> “提交我的测试用<span class=\"keyword\">test</span>.swift“ <span class=\"keyword\">test</span>.swift</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-更新文件-update\"><a href=\"#5-更新文件-update\" class=\"headerlink\" title=\"5. 更新文件: update\"></a>5. 更新文件: update</h3><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">update</span></span><br><span class=\"line\">svn　<span class=\"keyword\">update</span>　-r　修正版本　文件名</span><br><span class=\"line\">svn　<span class=\"keyword\">update</span>　文件名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn <span class=\"keyword\">update</span>      </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本</span></span><br><span class=\"line\"></span><br><span class=\"line\">svn <span class=\"keyword\">update</span> -r 200 <span class=\"keyword\">test</span>.swift    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将版本库中的文件 test.swift还原到修正版本（revision）200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//svn update test.swift</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//更新与版本库同步。提交的时候提示过期冲突，需要先update修改文件，然后清除</span></span><br><span class=\"line\">svn resolved，最后再提交commit。</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-删除文件-delete\"><a href=\"#6-删除文件-delete\" class=\"headerlink\" title=\"6. 删除文件: delete\"></a>6. 删除文件: delete</h3><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">delete</span>　svn:<span class=\"regexp\">//</span>路径(目录或文件的全路径) -m “删除备注信息文本”</span><br><span class=\"line\">svn　<span class=\"keyword\">delete</span>　文件名 </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>例子：</span><br><span class=\"line\">svn <span class=\"keyword\">delete</span> svn:<span class=\"regexp\">//</span>localhost<span class=\"regexp\">/testapp/</span>test.swift -m “删除测试文件test.swift”</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>如下：</span><br><span class=\"line\">svn <span class=\"keyword\">delete</span> test.swift</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-加锁-lock\"><a href=\"#7-加锁-lock\" class=\"headerlink\" title=\"7. 加锁: lock\"></a>7. 加锁: lock</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">lock</span>　-m　“加锁备注信息文本“　[<span class=\"comment\">--force]　文件名 </span></span><br><span class=\"line\">svn　<span class=\"keyword\">unlock</span>　文件名</span><br><span class=\"line\"></span><br><span class=\"line\">//例子：</span><br><span class=\"line\">svn <span class=\"keyword\">lock</span> -m “锁信测试用test.swift文件“ test.swift </span><br><span class=\"line\">svn <span class=\"keyword\">unlock</span> test.swift</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-比较差异-diff\"><a href=\"#8-比较差异-diff\" class=\"headerlink\" title=\"8. 比较差异: diff\"></a>8. 比较差异: diff</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　diff　     文件名 </span><br><span class=\"line\">svn　diff　-r　 修正版本号m:修正版本号n　文件名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn diff test<span class=\"selector-class\">.swift</span>               </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将修改的文件与基础版本比较</span></span><br><span class=\"line\"></span><br><span class=\"line\">svn diff -r <span class=\"number\">200</span>:<span class=\"number\">201</span> test<span class=\"selector-class\">.swift</span>   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对修正版本号200和修正版本号201比较差异</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"9-查看文件或者目录状态-status-缩写-st\"><a href=\"#9-查看文件或者目录状态-status-缩写-st\" class=\"headerlink\" title=\"9. 查看文件或者目录状态: status  缩写 st\"></a>9. 查看文件或者目录状态: status  缩写 st</h3><figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn st 目录路径/名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//目录下的文件和子目录的状态，正常状态不显示 //?：不在svn的控制中M：内容被修改；C：发生冲突A：预定加入到版本库 K：被锁定 </span></span><br><span class=\"line\"></span><br><span class=\"line\">svn  -v 目录路径/名</span><br><span class=\"line\"></span><br><span class=\"line\">svn status -v 目录路径/名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//显示文件和子目录状态,第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次</span></span><br><span class=\"line\"><span class=\"comment\">//修改的版本号和修改人</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"10-查看日志-log\"><a href=\"#10-查看日志-log\" class=\"headerlink\" title=\"10. 查看日志: log\"></a>10. 查看日志: log</h3><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">log</span>　文件名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn <span class=\"keyword\">log</span> <span class=\"keyword\">test</span>.swift    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//显示这个文件的所有修改记录，及其版本号的变化</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"11-查看文件详细信息-info\"><a href=\"#11-查看文件详细信息-info\" class=\"headerlink\" title=\"11. 查看文件详细信息: info\"></a>11. 查看文件详细信息: info</h3><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">svn</span>　<span class=\"literal\">info</span>　文件名</span><br><span class=\"line\"></span><br><span class=\"line\">//例子：</span><br><span class=\"line\">svn <span class=\"literal\">info</span> test.swift</span><br></pre></td></tr></table></figure>\n<h3 id=\"12-查看版本库下的文件和目录列表-list-缩写-ls\"><a href=\"#12-查看版本库下的文件和目录列表-list-缩写-ls\" class=\"headerlink\" title=\"12. 查看版本库下的文件和目录列表: list 缩写 ls\"></a>12. 查看版本库下的文件和目录列表: list 缩写 ls</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　list　<span class=\"string\">svn:</span><span class=\"comment\">//路径(目录或文件的全路径)</span></span><br><span class=\"line\">svn　ls　<span class=\"string\">svn:</span><span class=\"comment\">//路径(目录或文件的全路径)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn list <span class=\"string\">svn:</span><span class=\"comment\">//localhost/test</span></span><br><span class=\"line\">svn ls <span class=\"string\">svn:</span><span class=\"comment\">//localhost/test   </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//显示svn://localhost/test目录下的所有属于版本库的文件和目录</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"13-恢复本地修改-revert\"><a href=\"#13-恢复本地修改-revert\" class=\"headerlink\" title=\"13. 恢复本地修改: revert\"></a>13. 恢复本地修改: revert</h3><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　revert　[<span class=\"params\">--recursive</span>]　文件名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span>注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span>例子：</span><br><span class=\"line\">svn revert taotao.swift      </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span>丢弃对一个文件的修改</span><br><span class=\"line\"></span><br><span class=\"line\">svn revert <span class=\"params\">--recursive</span> .     </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span>恢复一整个目录的文件，. 为当前目录</span><br></pre></td></tr></table></figure>\n<h3 id=\"14-把工作拷贝更新到别的URL-switch\"><a href=\"#14-把工作拷贝更新到别的URL-switch\" class=\"headerlink\" title=\"14. 把工作拷贝更新到别的URL: switch\"></a>14. 把工作拷贝更新到别的URL: switch</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">switch</span>　<span class=\"string\">http:</span><span class=\"comment\">//目录全路径　  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//本地目录全路径</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn <span class=\"keyword\">switch</span> <span class=\"string\">http:</span><span class=\"comment\">//localhost/test/456 .  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//(原为123的分支)当前所在目录分支到</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"15-新建分支-copy\"><a href=\"#15-新建分支-copy\" class=\"headerlink\" title=\"15. 新建分支: copy\"></a>15. 新建分支: copy</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn <span class=\"keyword\">copy</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"bash\">//例子：</span></span><br><span class=\"line\"><span class=\"bash\">svn copy branchA branchB  -m <span class=\"string\">\"make B branch\"</span></span></span><br><span class=\"line\"><span class=\"bash\">//从branchA拷贝出一个新分支branchB</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"16-合并分支-merge\"><a href=\"#16-合并分支-merge\" class=\"headerlink\" title=\"16. 合并分支: merge\"></a>16. 合并分支: merge</h3><figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn <span class=\"keyword\">merge</span> branchA branchB  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//把对branchA的修改合并到分支branchB</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"17-解决冲突：resolved\"><a href=\"#17-解决冲突：resolved\" class=\"headerlink\" title=\"17. 解决冲突：resolved\"></a>17. 解决冲突：resolved</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　resolved　[本地目录全路径]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">$ svn update</span><br><span class=\"line\">C foo.c</span><br><span class=\"line\">Updated to revision <span class=\"number\">31</span>.</span><br><span class=\"line\"><span class=\"comment\">//如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ ls</span><br><span class=\"line\">foo.c</span><br><span class=\"line\">foo<span class=\"selector-class\">.c</span><span class=\"selector-class\">.mine</span></span><br><span class=\"line\">foo<span class=\"selector-class\">.c</span><span class=\"selector-class\">.r30</span></span><br><span class=\"line\">foo<span class=\"selector-class\">.c</span><span class=\"selector-class\">.r31</span></span><br><span class=\"line\"><span class=\"comment\">//当你解决了foo.c的冲突，并且准备提交，</span></span><br><span class=\"line\"><span class=\"comment\">//运行svn resolved让你的工作拷贝知道你已经完成了所有事情。</span></span><br><span class=\"line\"><span class=\"comment\">//你可以仅仅删除冲突的文件并且提交，</span></span><br><span class=\"line\"><span class=\"comment\">//但是svn resolved除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据。</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-检出-checkout-缩写-co\"><a href=\"#1-检出-checkout-缩写-co\" class=\"headerlink\" title=\"1. 检出: checkout 缩写 co\"></a>1. 检出: checkout 缩写 co</h3><p>如果不带 –password  参数传输密码的话，会提示输入密码，建议不要用明文的 –password 选项。其中 username 与 password前是两个短线，不是一个。默认check到当前目录。<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn  checkout  <span class=\"string\">http:</span><span class=\"comment\">//路径(目录或文件的全路径)　[本地目录全路径] --username　用户名</span></span><br><span class=\"line\">svn  checkout  <span class=\"string\">svn:</span><span class=\"comment\">//路径(目录或文件的全路径)　 [本地目录全路径] --username　用户名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn co <span class=\"string\">svn:</span><span class=\"comment\">//localhost/files          --username taotao</span></span><br><span class=\"line\">svn checkout <span class=\"string\">http:</span><span class=\"comment\">//localhost/files   --username taotao</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-导出-导出一个干净的不带-svn文件夹的目录树\"><a href=\"#2-导出-导出一个干净的不带-svn文件夹的目录树\" class=\"headerlink\" title=\"2. 导出(导出一个干净的不带.svn文件夹的目录树)\"></a>2. 导出(导出一个干净的不带.svn文件夹的目录树)</h3><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn  <span class=\"keyword\">export</span>  [-r 版本号]  http: <span class=\"comment\">//路径(目录或文件的全路径) --username　用户名</span></span><br><span class=\"line\">svn  <span class=\"keyword\">export</span>  [-r 版本号]  svn:  <span class=\"comment\">//路径(目录或文件的全路径) --username　用户名</span></span><br><span class=\"line\">svn  <span class=\"keyword\">export</span>  本地检出的(即带有.svn文件夹的)目录全路径  要导出的本地目录全路径</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn <span class=\"keyword\">export</span> svn:<span class=\"comment\">//localhost/files --username wzhnsc</span></span><br><span class=\"line\">svn <span class=\"keyword\">export</span> svn:<span class=\"comment\">//localhost/files --username wzhnsc</span></span><br><span class=\"line\">svn <span class=\"keyword\">export</span> /<span class=\"built_in\">home</span>/files /<span class=\"built_in\">home</span>/tofiles</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-添加新文件-add\"><a href=\"#3-添加新文件-add\" class=\"headerlink\" title=\"3. 添加新文件: add\"></a>3. 添加新文件: add</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">add</span><span class=\"bash\">　文件名</span></span><br><span class=\"line\"><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"bash\">//例子：</span></span><br><span class=\"line\"><span class=\"bash\">svn add picture.png</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-提交-commit-缩写-ci\"><a href=\"#4-提交-commit-缩写-ci\" class=\"headerlink\" title=\"4. 提交: commit 缩写 ci\"></a>4. 提交: commit 缩写 ci</h3><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　commit　-<span class=\"keyword\">m</span>　“提交备注信息文本“　[-<span class=\"keyword\">N</span>]　[--<span class=\"keyword\">no</span>-unlock]　文件名</span><br><span class=\"line\">svn　<span class=\"keyword\">ci</span>　-<span class=\"keyword\">m</span>　“提交备注信息文本“　    [-<span class=\"keyword\">N</span>]　[--<span class=\"keyword\">no</span>-unlock]　文件名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn commit -<span class=\"keyword\">m</span> “提交我的测试用<span class=\"keyword\">test</span>.swift“ <span class=\"keyword\">test</span>.swift</span><br><span class=\"line\">svn <span class=\"keyword\">ci</span> -<span class=\"keyword\">m</span> “提交我的测试用<span class=\"keyword\">test</span>.swift“ <span class=\"keyword\">test</span>.swift</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-更新文件-update\"><a href=\"#5-更新文件-update\" class=\"headerlink\" title=\"5. 更新文件: update\"></a>5. 更新文件: update</h3><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">update</span></span><br><span class=\"line\">svn　<span class=\"keyword\">update</span>　-r　修正版本　文件名</span><br><span class=\"line\">svn　<span class=\"keyword\">update</span>　文件名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn <span class=\"keyword\">update</span>      </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本</span></span><br><span class=\"line\"></span><br><span class=\"line\">svn <span class=\"keyword\">update</span> -r 200 <span class=\"keyword\">test</span>.swift    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将版本库中的文件 test.swift还原到修正版本（revision）200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//svn update test.swift</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//更新与版本库同步。提交的时候提示过期冲突，需要先update修改文件，然后清除</span></span><br><span class=\"line\">svn resolved，最后再提交commit。</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-删除文件-delete\"><a href=\"#6-删除文件-delete\" class=\"headerlink\" title=\"6. 删除文件: delete\"></a>6. 删除文件: delete</h3><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">delete</span>　svn:<span class=\"regexp\">//</span>路径(目录或文件的全路径) -m “删除备注信息文本”</span><br><span class=\"line\">svn　<span class=\"keyword\">delete</span>　文件名 </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>例子：</span><br><span class=\"line\">svn <span class=\"keyword\">delete</span> svn:<span class=\"regexp\">//</span>localhost<span class=\"regexp\">/testapp/</span>test.swift -m “删除测试文件test.swift”</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>如下：</span><br><span class=\"line\">svn <span class=\"keyword\">delete</span> test.swift</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-加锁-lock\"><a href=\"#7-加锁-lock\" class=\"headerlink\" title=\"7. 加锁: lock\"></a>7. 加锁: lock</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">lock</span>　-m　“加锁备注信息文本“　[<span class=\"comment\">--force]　文件名 </span></span><br><span class=\"line\">svn　<span class=\"keyword\">unlock</span>　文件名</span><br><span class=\"line\"></span><br><span class=\"line\">//例子：</span><br><span class=\"line\">svn <span class=\"keyword\">lock</span> -m “锁信测试用test.swift文件“ test.swift </span><br><span class=\"line\">svn <span class=\"keyword\">unlock</span> test.swift</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-比较差异-diff\"><a href=\"#8-比较差异-diff\" class=\"headerlink\" title=\"8. 比较差异: diff\"></a>8. 比较差异: diff</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　diff　     文件名 </span><br><span class=\"line\">svn　diff　-r　 修正版本号m:修正版本号n　文件名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn diff test<span class=\"selector-class\">.swift</span>               </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将修改的文件与基础版本比较</span></span><br><span class=\"line\"></span><br><span class=\"line\">svn diff -r <span class=\"number\">200</span>:<span class=\"number\">201</span> test<span class=\"selector-class\">.swift</span>   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对修正版本号200和修正版本号201比较差异</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"9-查看文件或者目录状态-status-缩写-st\"><a href=\"#9-查看文件或者目录状态-status-缩写-st\" class=\"headerlink\" title=\"9. 查看文件或者目录状态: status  缩写 st\"></a>9. 查看文件或者目录状态: status  缩写 st</h3><figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn st 目录路径/名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//目录下的文件和子目录的状态，正常状态不显示 //?：不在svn的控制中M：内容被修改；C：发生冲突A：预定加入到版本库 K：被锁定 </span></span><br><span class=\"line\"></span><br><span class=\"line\">svn  -v 目录路径/名</span><br><span class=\"line\"></span><br><span class=\"line\">svn status -v 目录路径/名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//显示文件和子目录状态,第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次</span></span><br><span class=\"line\"><span class=\"comment\">//修改的版本号和修改人</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"10-查看日志-log\"><a href=\"#10-查看日志-log\" class=\"headerlink\" title=\"10. 查看日志: log\"></a>10. 查看日志: log</h3><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">log</span>　文件名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn <span class=\"keyword\">log</span> <span class=\"keyword\">test</span>.swift    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//显示这个文件的所有修改记录，及其版本号的变化</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"11-查看文件详细信息-info\"><a href=\"#11-查看文件详细信息-info\" class=\"headerlink\" title=\"11. 查看文件详细信息: info\"></a>11. 查看文件详细信息: info</h3><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">svn</span>　<span class=\"literal\">info</span>　文件名</span><br><span class=\"line\"></span><br><span class=\"line\">//例子：</span><br><span class=\"line\">svn <span class=\"literal\">info</span> test.swift</span><br></pre></td></tr></table></figure>\n<h3 id=\"12-查看版本库下的文件和目录列表-list-缩写-ls\"><a href=\"#12-查看版本库下的文件和目录列表-list-缩写-ls\" class=\"headerlink\" title=\"12. 查看版本库下的文件和目录列表: list 缩写 ls\"></a>12. 查看版本库下的文件和目录列表: list 缩写 ls</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　list　<span class=\"string\">svn:</span><span class=\"comment\">//路径(目录或文件的全路径)</span></span><br><span class=\"line\">svn　ls　<span class=\"string\">svn:</span><span class=\"comment\">//路径(目录或文件的全路径)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn list <span class=\"string\">svn:</span><span class=\"comment\">//localhost/test</span></span><br><span class=\"line\">svn ls <span class=\"string\">svn:</span><span class=\"comment\">//localhost/test   </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//显示svn://localhost/test目录下的所有属于版本库的文件和目录</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"13-恢复本地修改-revert\"><a href=\"#13-恢复本地修改-revert\" class=\"headerlink\" title=\"13. 恢复本地修改: revert\"></a>13. 恢复本地修改: revert</h3><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　revert　[<span class=\"params\">--recursive</span>]　文件名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span>注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span>例子：</span><br><span class=\"line\">svn revert taotao.swift      </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span>丢弃对一个文件的修改</span><br><span class=\"line\"></span><br><span class=\"line\">svn revert <span class=\"params\">--recursive</span> .     </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">//</span>恢复一整个目录的文件，. 为当前目录</span><br></pre></td></tr></table></figure>\n<h3 id=\"14-把工作拷贝更新到别的URL-switch\"><a href=\"#14-把工作拷贝更新到别的URL-switch\" class=\"headerlink\" title=\"14. 把工作拷贝更新到别的URL: switch\"></a>14. 把工作拷贝更新到别的URL: switch</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　<span class=\"keyword\">switch</span>　<span class=\"string\">http:</span><span class=\"comment\">//目录全路径　  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//本地目录全路径</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn <span class=\"keyword\">switch</span> <span class=\"string\">http:</span><span class=\"comment\">//localhost/test/456 .  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//(原为123的分支)当前所在目录分支到</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"15-新建分支-copy\"><a href=\"#15-新建分支-copy\" class=\"headerlink\" title=\"15. 新建分支: copy\"></a>15. 新建分支: copy</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn <span class=\"keyword\">copy</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"bash\">//例子：</span></span><br><span class=\"line\"><span class=\"bash\">svn copy branchA branchB  -m <span class=\"string\">\"make B branch\"</span></span></span><br><span class=\"line\"><span class=\"bash\">//从branchA拷贝出一个新分支branchB</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"16-合并分支-merge\"><a href=\"#16-合并分支-merge\" class=\"headerlink\" title=\"16. 合并分支: merge\"></a>16. 合并分支: merge</h3><figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">svn <span class=\"keyword\">merge</span> branchA branchB  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//把对branchA的修改合并到分支branchB</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"17-解决冲突：resolved\"><a href=\"#17-解决冲突：resolved\" class=\"headerlink\" title=\"17. 解决冲突：resolved\"></a>17. 解决冲突：resolved</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svn　resolved　[本地目录全路径]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//例子：</span></span><br><span class=\"line\">$ svn update</span><br><span class=\"line\">C foo.c</span><br><span class=\"line\">Updated to revision <span class=\"number\">31</span>.</span><br><span class=\"line\"><span class=\"comment\">//如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ ls</span><br><span class=\"line\">foo.c</span><br><span class=\"line\">foo<span class=\"selector-class\">.c</span><span class=\"selector-class\">.mine</span></span><br><span class=\"line\">foo<span class=\"selector-class\">.c</span><span class=\"selector-class\">.r30</span></span><br><span class=\"line\">foo<span class=\"selector-class\">.c</span><span class=\"selector-class\">.r31</span></span><br><span class=\"line\"><span class=\"comment\">//当你解决了foo.c的冲突，并且准备提交，</span></span><br><span class=\"line\"><span class=\"comment\">//运行svn resolved让你的工作拷贝知道你已经完成了所有事情。</span></span><br><span class=\"line\"><span class=\"comment\">//你可以仅仅删除冲突的文件并且提交，</span></span><br><span class=\"line\"><span class=\"comment\">//但是svn resolved除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据。</span></span><br></pre></td></tr></table></figure>\n"},{"title":"iOS 中使用 Python","date":"2019-06-10T03:10:12.000Z","_content":"","source":"_posts/iOS 中使用 Python.md","raw":"---\ntitle: iOS 中使用 Python\ndate: 2019-06-10 11:10:12\ntags: Python\n---\n","slug":"iOS 中使用 Python","published":1,"updated":"2019-05-31T10:38:13.648Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwemxmyz0004ods68t7tqw81","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"iOS-RunLoop","date":"2019-06-05T06:01:15.000Z","_content":"","source":"_posts/iOS-RunLoop.md","raw":"---\ntitle: iOS-RunLoop\ndate: 2019-06-5 14:01:15\ntags: iOS\n---\n","slug":"iOS-RunLoop","published":1,"updated":"2019-06-01T05:47:06.401Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwemxmz00005ods6an02gfxw","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Xcode-常用调试技巧","date":"2018-02-01T07:06:17.000Z","_content":"\n### 1. 普通断点调试\n   断点(Breakpoint)调试顾名思义，是当程序运行到断点处时会暂停运行。然后可以查看具体参数的值或者属性状态等。具体操作是点击代码左侧开启断点，再点一次将关闭断点，但断点还在。\n   快捷键为：command+\\。如图：\n   ![](iOS-调试技巧/breakpoint1.png)\n### 2. 条件断点调试\n   可以对普通断点的属性进行配置，设置条件，使调试更加方便达到目的。如下循环中：\n    ```\n  for i in 0..<10 {\n      print(i)\n  }\n    ```\n   如果要调试循环中的代码，每次都要单步执行，可能这并不是我想要的。我想要在一定条件的时候中断程序进行调试，可以如图添加Condition：\n   ![](iOS-调试技巧/breakpoint4.png)\n   可以设置Ignore参数，会忽略前面n次的断点，会在第n+1次中断：\n   ![](iOS-调试技巧/breakpoint5.png)\n   可以查看某个函数被调用的次数，设置Action参数,要选中\n   Automatically continue after evaluating actions。\n   ![](iOS-调试技巧/breakpoint6.png)\n### 3. 异常断点调试\n   有时候由于异常导致后程序crash了，代码就直接断到main函数中去了，这时候调试就比较麻烦。这种情况就可以用异常断点调试方法进行调试。如图添加异常断点：\n   ![](iOS-调试技巧/breakpoint7.png)\n### 4. 符号断点Symbolic Breakpoint调试\n   符号断点的创建也和异常断点一样。一般符号断点可以在你指定的[类名 方法名]时中断执行。\n   ![](iOS-调试技巧/breakpoint8.png)\n   如果Symbol只写了一个函数名，那么就会在出现该函数名的地方中断执行。\n   ![](iOS-调试技巧/breakpoint9.png)\n### 5. Analyze分析器\n   Analyze分析器是一种静态的工具，可以对我们的程序进行分析，找出我们未使用的变量，或一些死存储。执行Analyze如下：Product-->Analyze。快捷键为: Command+Ctrl+B\n   可以设置在编译程序的时候同时Analyze，把下列选项设为Yes即可。\n   ![](iOS-调试技巧/breakpoint16.png)\n### 6. 僵尸对象\n   iOS中把那些已经release但还没完全消失的对象叫做僵尸对象，对已经release的对象再次释放，就会发生异常。虽然自从使用ARC后，由于对象释放产生的异常已经大大变少，但偶尔还会出现。开启僵尸对象模式后，就能快速定位到异常位置。\n   开启方式如下：Product-->Scheme-->Edit Scheme. 勾选Zombie Objects即可。\n   ![](iOS-调试技巧/breakpoint11.png)\n### 7. lldb命令调试\n#### (1) print、po输出打印：\n   打印变量的值可以使用print（简写p）命令，该命令如果打印的是基础数据类型，则会列出基础数据类型的类型和值。如果是对象，还会打印出对象指针地址。print的打印信息较多，如果只想查看对象的值，则可以使用po（printobject）命令。\n   ![](iOS-调试技巧/breakpoint12.png)\n#### (2) call:\n   call调用方法的意思，call可以使用在没有返回值，不需要显示输出的情况下。比如可以这样用：\n   ```  \n  call self.view.backgroundColor = UIColor.purple\n   ```\n   这样就不用为了看改一下颜色的效果再进行build一次了，尤其是build一次还要经过漫长的等待。\n  \n#### (3) expression表达式(expr):\n   expr常用于调试时修改变量的值。比如：\n   ![](iOS-调试技巧/breakpoint13.png)\n#### (4) image:\n   image lookup --address寻址。比如：\n   ```\n   (lldb) image lookup --address 0x00000001097c396f\n   ```\n   image lookup --type查看类型.比如：\n   ```\n  (lldb) image lookup --type UIButton\n   ```\n   可以列出UIButton所有的属性。\n#### (5) bt:\n   我们可以用bt来打印调用堆栈，加all可打印多个thread的堆栈，如下：\n   ![](iOS-调试技巧/breakpoint14.png)\n### 8. 视图调试\n   当在调看UI布局或者在布局产生冲突的时候可以使用视图调试解决问题。进入APP出现问题的那个界面然后点击Xcode Debug View Hierarchy, 如图：\n   ![](iOS-调试技巧/breakpoint15.png)\n### 9. Log调试\n   可以使用别人的Log工具或者自定义Log，按照需求自行选择。","source":"_posts/iOS-调试技巧.md","raw":"---\ntitle: Xcode-常用调试技巧\ndate: 2018-02-01 15:06:17\ntags: Xcode\n---\n\n### 1. 普通断点调试\n   断点(Breakpoint)调试顾名思义，是当程序运行到断点处时会暂停运行。然后可以查看具体参数的值或者属性状态等。具体操作是点击代码左侧开启断点，再点一次将关闭断点，但断点还在。\n   快捷键为：command+\\。如图：\n   ![](iOS-调试技巧/breakpoint1.png)\n### 2. 条件断点调试\n   可以对普通断点的属性进行配置，设置条件，使调试更加方便达到目的。如下循环中：\n    ```\n  for i in 0..<10 {\n      print(i)\n  }\n    ```\n   如果要调试循环中的代码，每次都要单步执行，可能这并不是我想要的。我想要在一定条件的时候中断程序进行调试，可以如图添加Condition：\n   ![](iOS-调试技巧/breakpoint4.png)\n   可以设置Ignore参数，会忽略前面n次的断点，会在第n+1次中断：\n   ![](iOS-调试技巧/breakpoint5.png)\n   可以查看某个函数被调用的次数，设置Action参数,要选中\n   Automatically continue after evaluating actions。\n   ![](iOS-调试技巧/breakpoint6.png)\n### 3. 异常断点调试\n   有时候由于异常导致后程序crash了，代码就直接断到main函数中去了，这时候调试就比较麻烦。这种情况就可以用异常断点调试方法进行调试。如图添加异常断点：\n   ![](iOS-调试技巧/breakpoint7.png)\n### 4. 符号断点Symbolic Breakpoint调试\n   符号断点的创建也和异常断点一样。一般符号断点可以在你指定的[类名 方法名]时中断执行。\n   ![](iOS-调试技巧/breakpoint8.png)\n   如果Symbol只写了一个函数名，那么就会在出现该函数名的地方中断执行。\n   ![](iOS-调试技巧/breakpoint9.png)\n### 5. Analyze分析器\n   Analyze分析器是一种静态的工具，可以对我们的程序进行分析，找出我们未使用的变量，或一些死存储。执行Analyze如下：Product-->Analyze。快捷键为: Command+Ctrl+B\n   可以设置在编译程序的时候同时Analyze，把下列选项设为Yes即可。\n   ![](iOS-调试技巧/breakpoint16.png)\n### 6. 僵尸对象\n   iOS中把那些已经release但还没完全消失的对象叫做僵尸对象，对已经release的对象再次释放，就会发生异常。虽然自从使用ARC后，由于对象释放产生的异常已经大大变少，但偶尔还会出现。开启僵尸对象模式后，就能快速定位到异常位置。\n   开启方式如下：Product-->Scheme-->Edit Scheme. 勾选Zombie Objects即可。\n   ![](iOS-调试技巧/breakpoint11.png)\n### 7. lldb命令调试\n#### (1) print、po输出打印：\n   打印变量的值可以使用print（简写p）命令，该命令如果打印的是基础数据类型，则会列出基础数据类型的类型和值。如果是对象，还会打印出对象指针地址。print的打印信息较多，如果只想查看对象的值，则可以使用po（printobject）命令。\n   ![](iOS-调试技巧/breakpoint12.png)\n#### (2) call:\n   call调用方法的意思，call可以使用在没有返回值，不需要显示输出的情况下。比如可以这样用：\n   ```  \n  call self.view.backgroundColor = UIColor.purple\n   ```\n   这样就不用为了看改一下颜色的效果再进行build一次了，尤其是build一次还要经过漫长的等待。\n  \n#### (3) expression表达式(expr):\n   expr常用于调试时修改变量的值。比如：\n   ![](iOS-调试技巧/breakpoint13.png)\n#### (4) image:\n   image lookup --address寻址。比如：\n   ```\n   (lldb) image lookup --address 0x00000001097c396f\n   ```\n   image lookup --type查看类型.比如：\n   ```\n  (lldb) image lookup --type UIButton\n   ```\n   可以列出UIButton所有的属性。\n#### (5) bt:\n   我们可以用bt来打印调用堆栈，加all可打印多个thread的堆栈，如下：\n   ![](iOS-调试技巧/breakpoint14.png)\n### 8. 视图调试\n   当在调看UI布局或者在布局产生冲突的时候可以使用视图调试解决问题。进入APP出现问题的那个界面然后点击Xcode Debug View Hierarchy, 如图：\n   ![](iOS-调试技巧/breakpoint15.png)\n### 9. Log调试\n   可以使用别人的Log工具或者自定义Log，按照需求自行选择。","slug":"iOS-调试技巧","published":1,"updated":"2019-05-31T09:31:27.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwemxmz10006ods6pu5e052z","content":"<h3 id=\"1-普通断点调试\"><a href=\"#1-普通断点调试\" class=\"headerlink\" title=\"1. 普通断点调试\"></a>1. 普通断点调试</h3><p>   断点(Breakpoint)调试顾名思义，是当程序运行到断点处时会暂停运行。然后可以查看具体参数的值或者属性状态等。具体操作是点击代码左侧开启断点，再点一次将关闭断点，但断点还在。<br>   快捷键为：command+\\。如图：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint1.png\" alt=\"\"></p>\n<h3 id=\"2-条件断点调试\"><a href=\"#2-条件断点调试\" class=\"headerlink\" title=\"2. 条件断点调试\"></a>2. 条件断点调试</h3><p>   可以对普通断点的属性进行配置，设置条件，使调试更加方便达到目的。如下循环中：<br>    <figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> 0<span class=\"built_in\">..</span>&lt;10 &#123;</span><br><span class=\"line\">    <span class=\"builtin-name\">print</span>(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>   如果要调试循环中的代码，每次都要单步执行，可能这并不是我想要的。我想要在一定条件的时候中断程序进行调试，可以如图添加Condition：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint4.png\" alt=\"\"><br>   可以设置Ignore参数，会忽略前面n次的断点，会在第n+1次中断：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint5.png\" alt=\"\"><br>   可以查看某个函数被调用的次数，设置Action参数,要选中<br>   Automatically continue after evaluating actions。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint6.png\" alt=\"\"></p>\n<h3 id=\"3-异常断点调试\"><a href=\"#3-异常断点调试\" class=\"headerlink\" title=\"3. 异常断点调试\"></a>3. 异常断点调试</h3><p>   有时候由于异常导致后程序crash了，代码就直接断到main函数中去了，这时候调试就比较麻烦。这种情况就可以用异常断点调试方法进行调试。如图添加异常断点：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint7.png\" alt=\"\"></p>\n<h3 id=\"4-符号断点Symbolic-Breakpoint调试\"><a href=\"#4-符号断点Symbolic-Breakpoint调试\" class=\"headerlink\" title=\"4. 符号断点Symbolic Breakpoint调试\"></a>4. 符号断点Symbolic Breakpoint调试</h3><p>   符号断点的创建也和异常断点一样。一般符号断点可以在你指定的[类名 方法名]时中断执行。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint8.png\" alt=\"\"><br>   如果Symbol只写了一个函数名，那么就会在出现该函数名的地方中断执行。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint9.png\" alt=\"\"></p>\n<h3 id=\"5-Analyze分析器\"><a href=\"#5-Analyze分析器\" class=\"headerlink\" title=\"5. Analyze分析器\"></a>5. Analyze分析器</h3><p>   Analyze分析器是一种静态的工具，可以对我们的程序进行分析，找出我们未使用的变量，或一些死存储。执行Analyze如下：Product–&gt;Analyze。快捷键为: Command+Ctrl+B<br>   可以设置在编译程序的时候同时Analyze，把下列选项设为Yes即可。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint16.png\" alt=\"\"></p>\n<h3 id=\"6-僵尸对象\"><a href=\"#6-僵尸对象\" class=\"headerlink\" title=\"6. 僵尸对象\"></a>6. 僵尸对象</h3><p>   iOS中把那些已经release但还没完全消失的对象叫做僵尸对象，对已经release的对象再次释放，就会发生异常。虽然自从使用ARC后，由于对象释放产生的异常已经大大变少，但偶尔还会出现。开启僵尸对象模式后，就能快速定位到异常位置。<br>   开启方式如下：Product–&gt;Scheme–&gt;Edit Scheme. 勾选Zombie Objects即可。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint11.png\" alt=\"\"></p>\n<h3 id=\"7-lldb命令调试\"><a href=\"#7-lldb命令调试\" class=\"headerlink\" title=\"7. lldb命令调试\"></a>7. lldb命令调试</h3><h4 id=\"1-print、po输出打印：\"><a href=\"#1-print、po输出打印：\" class=\"headerlink\" title=\"(1) print、po输出打印：\"></a>(1) print、po输出打印：</h4><p>   打印变量的值可以使用print（简写p）命令，该命令如果打印的是基础数据类型，则会列出基础数据类型的类型和值。如果是对象，还会打印出对象指针地址。print的打印信息较多，如果只想查看对象的值，则可以使用po（printobject）命令。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint12.png\" alt=\"\"></p>\n<h4 id=\"2-call\"><a href=\"#2-call\" class=\"headerlink\" title=\"(2) call:\"></a>(2) call:</h4><p>   call调用方法的意思，call可以使用在没有返回值，不需要显示输出的情况下。比如可以这样用：<br>   <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call self<span class=\"selector-class\">.view</span><span class=\"selector-class\">.backgroundColor</span> = UIColor.purple</span><br></pre></td></tr></table></figure></p>\n<p>   这样就不用为了看改一下颜色的效果再进行build一次了，尤其是build一次还要经过漫长的等待。</p>\n<h4 id=\"3-expression表达式-expr\"><a href=\"#3-expression表达式-expr\" class=\"headerlink\" title=\"(3) expression表达式(expr):\"></a>(3) expression表达式(expr):</h4><p>   expr常用于调试时修改变量的值。比如：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint13.png\" alt=\"\"></p>\n<h4 id=\"4-image\"><a href=\"#4-image\" class=\"headerlink\" title=\"(4) image:\"></a>(4) image:</h4><p>   image lookup –address寻址。比如：<br>   <figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) image <span class=\"built_in\">lookup</span> --<span class=\"built_in\">address</span> <span class=\"number\">0</span>x00000001097c396f</span><br></pre></td></tr></table></figure></p>\n<p>   image lookup –type查看类型.比如：<br>   <figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) image <span class=\"built_in\">lookup</span> --<span class=\"built_in\">type</span> UIButton</span><br></pre></td></tr></table></figure></p>\n<p>   可以列出UIButton所有的属性。</p>\n<h4 id=\"5-bt\"><a href=\"#5-bt\" class=\"headerlink\" title=\"(5) bt:\"></a>(5) bt:</h4><p>   我们可以用bt来打印调用堆栈，加all可打印多个thread的堆栈，如下：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint14.png\" alt=\"\"></p>\n<h3 id=\"8-视图调试\"><a href=\"#8-视图调试\" class=\"headerlink\" title=\"8. 视图调试\"></a>8. 视图调试</h3><p>   当在调看UI布局或者在布局产生冲突的时候可以使用视图调试解决问题。进入APP出现问题的那个界面然后点击Xcode Debug View Hierarchy, 如图：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint15.png\" alt=\"\"></p>\n<h3 id=\"9-Log调试\"><a href=\"#9-Log调试\" class=\"headerlink\" title=\"9. Log调试\"></a>9. Log调试</h3><p>   可以使用别人的Log工具或者自定义Log，按照需求自行选择。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-普通断点调试\"><a href=\"#1-普通断点调试\" class=\"headerlink\" title=\"1. 普通断点调试\"></a>1. 普通断点调试</h3><p>   断点(Breakpoint)调试顾名思义，是当程序运行到断点处时会暂停运行。然后可以查看具体参数的值或者属性状态等。具体操作是点击代码左侧开启断点，再点一次将关闭断点，但断点还在。<br>   快捷键为：command+\\。如图：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint1.png\" alt=\"\"></p>\n<h3 id=\"2-条件断点调试\"><a href=\"#2-条件断点调试\" class=\"headerlink\" title=\"2. 条件断点调试\"></a>2. 条件断点调试</h3><p>   可以对普通断点的属性进行配置，设置条件，使调试更加方便达到目的。如下循环中：<br>    <figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> 0<span class=\"built_in\">..</span>&lt;10 &#123;</span><br><span class=\"line\">    <span class=\"builtin-name\">print</span>(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>   如果要调试循环中的代码，每次都要单步执行，可能这并不是我想要的。我想要在一定条件的时候中断程序进行调试，可以如图添加Condition：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint4.png\" alt=\"\"><br>   可以设置Ignore参数，会忽略前面n次的断点，会在第n+1次中断：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint5.png\" alt=\"\"><br>   可以查看某个函数被调用的次数，设置Action参数,要选中<br>   Automatically continue after evaluating actions。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint6.png\" alt=\"\"></p>\n<h3 id=\"3-异常断点调试\"><a href=\"#3-异常断点调试\" class=\"headerlink\" title=\"3. 异常断点调试\"></a>3. 异常断点调试</h3><p>   有时候由于异常导致后程序crash了，代码就直接断到main函数中去了，这时候调试就比较麻烦。这种情况就可以用异常断点调试方法进行调试。如图添加异常断点：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint7.png\" alt=\"\"></p>\n<h3 id=\"4-符号断点Symbolic-Breakpoint调试\"><a href=\"#4-符号断点Symbolic-Breakpoint调试\" class=\"headerlink\" title=\"4. 符号断点Symbolic Breakpoint调试\"></a>4. 符号断点Symbolic Breakpoint调试</h3><p>   符号断点的创建也和异常断点一样。一般符号断点可以在你指定的[类名 方法名]时中断执行。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint8.png\" alt=\"\"><br>   如果Symbol只写了一个函数名，那么就会在出现该函数名的地方中断执行。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint9.png\" alt=\"\"></p>\n<h3 id=\"5-Analyze分析器\"><a href=\"#5-Analyze分析器\" class=\"headerlink\" title=\"5. Analyze分析器\"></a>5. Analyze分析器</h3><p>   Analyze分析器是一种静态的工具，可以对我们的程序进行分析，找出我们未使用的变量，或一些死存储。执行Analyze如下：Product–&gt;Analyze。快捷键为: Command+Ctrl+B<br>   可以设置在编译程序的时候同时Analyze，把下列选项设为Yes即可。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint16.png\" alt=\"\"></p>\n<h3 id=\"6-僵尸对象\"><a href=\"#6-僵尸对象\" class=\"headerlink\" title=\"6. 僵尸对象\"></a>6. 僵尸对象</h3><p>   iOS中把那些已经release但还没完全消失的对象叫做僵尸对象，对已经release的对象再次释放，就会发生异常。虽然自从使用ARC后，由于对象释放产生的异常已经大大变少，但偶尔还会出现。开启僵尸对象模式后，就能快速定位到异常位置。<br>   开启方式如下：Product–&gt;Scheme–&gt;Edit Scheme. 勾选Zombie Objects即可。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint11.png\" alt=\"\"></p>\n<h3 id=\"7-lldb命令调试\"><a href=\"#7-lldb命令调试\" class=\"headerlink\" title=\"7. lldb命令调试\"></a>7. lldb命令调试</h3><h4 id=\"1-print、po输出打印：\"><a href=\"#1-print、po输出打印：\" class=\"headerlink\" title=\"(1) print、po输出打印：\"></a>(1) print、po输出打印：</h4><p>   打印变量的值可以使用print（简写p）命令，该命令如果打印的是基础数据类型，则会列出基础数据类型的类型和值。如果是对象，还会打印出对象指针地址。print的打印信息较多，如果只想查看对象的值，则可以使用po（printobject）命令。<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint12.png\" alt=\"\"></p>\n<h4 id=\"2-call\"><a href=\"#2-call\" class=\"headerlink\" title=\"(2) call:\"></a>(2) call:</h4><p>   call调用方法的意思，call可以使用在没有返回值，不需要显示输出的情况下。比如可以这样用：<br>   <figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call self<span class=\"selector-class\">.view</span><span class=\"selector-class\">.backgroundColor</span> = UIColor.purple</span><br></pre></td></tr></table></figure></p>\n<p>   这样就不用为了看改一下颜色的效果再进行build一次了，尤其是build一次还要经过漫长的等待。</p>\n<h4 id=\"3-expression表达式-expr\"><a href=\"#3-expression表达式-expr\" class=\"headerlink\" title=\"(3) expression表达式(expr):\"></a>(3) expression表达式(expr):</h4><p>   expr常用于调试时修改变量的值。比如：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint13.png\" alt=\"\"></p>\n<h4 id=\"4-image\"><a href=\"#4-image\" class=\"headerlink\" title=\"(4) image:\"></a>(4) image:</h4><p>   image lookup –address寻址。比如：<br>   <figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) image <span class=\"built_in\">lookup</span> --<span class=\"built_in\">address</span> <span class=\"number\">0</span>x00000001097c396f</span><br></pre></td></tr></table></figure></p>\n<p>   image lookup –type查看类型.比如：<br>   <figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) image <span class=\"built_in\">lookup</span> --<span class=\"built_in\">type</span> UIButton</span><br></pre></td></tr></table></figure></p>\n<p>   可以列出UIButton所有的属性。</p>\n<h4 id=\"5-bt\"><a href=\"#5-bt\" class=\"headerlink\" title=\"(5) bt:\"></a>(5) bt:</h4><p>   我们可以用bt来打印调用堆栈，加all可打印多个thread的堆栈，如下：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint14.png\" alt=\"\"></p>\n<h3 id=\"8-视图调试\"><a href=\"#8-视图调试\" class=\"headerlink\" title=\"8. 视图调试\"></a>8. 视图调试</h3><p>   当在调看UI布局或者在布局产生冲突的时候可以使用视图调试解决问题。进入APP出现问题的那个界面然后点击Xcode Debug View Hierarchy, 如图：<br>   <img src=\"/2018/02/01/iOS-调试技巧/breakpoint15.png\" alt=\"\"></p>\n<h3 id=\"9-Log调试\"><a href=\"#9-Log调试\" class=\"headerlink\" title=\"9. Log调试\"></a>9. Log调试</h3><p>   可以使用别人的Log工具或者自定义Log，按照需求自行选择。</p>\n"},{"title":"iOS-Runtime","date":"2019-05-30T02:25:47.000Z","_content":"\n## Objc Runtime\n  源代码下载地址：[http://www.opensource.apple.com/source/objc4/](http://www.opensource.apple.com/source/objc4/)\n\n  Runtime 函数文档: [https://developer.apple.com/documentation/objectivec/objective-c_runtime](https://developer.apple.com/documentation/objectivec/objective-c_runtime)\n\n  苹果官方 Runtime 编程指南：\n  [https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048)\n### 1. 概念\n Objective-C 是一门动态语言，它将很多静态语言在编译和链接时做的事情推迟到运行时来处理。\n\n 这种动态特性意味着 Objective-C 不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。\n 对于 Objective-C 来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。\n\n Runtime 就是使用 C 和汇编写的一个运行时库，一般我们说 Runtime，不但包含运行时库的意思，还包含了运行时、运行时系统等概念。\n\n**Objc Runtime 使得 C 具有了面向对象能力，可以在程序运行时创建、检查、修改类、对象和它们的方法**。\n\n### 2. Runtime 的作用：\n#### (1) 封装\n Runtime 库中，对象可以用 C 语言中的结构体表示，而方法可以用 C 函数来实现，再加上了一些其他的特性。这些结构体和函数被 runtime 函数封装后，就可以在程序运行时创建、检查、修改类、对象和它们的方法了。\n#### (2) 找到方法的最终执行代码\n 当程序中执行 [receiver message] 时，会向消息接收者（receiver）发送一条消息 message，runtime 会根据消息接收者是否能响应该消息而做出不同的反应，即消息转发的流程。\n### 3. 类和对象（Class 和 Object）相关的基本数据结构\n#### (1) 关键词：\n Class：指向了 objc_class 结构体的指针 \n\tid：参数类型，指向某个类实例的指针 \n\tMethod：代表了类中的某个方法的类型\n\tSEL：方法选择器，全名是 selector\n\tIMP：函数指针，由编译器生成，方法实现的代码就是由 IMP 指定\n\tIvar：成员变量的类型\n\tProperty：属性存储器\n\tCache：方法调用的缓存器，为方法调用的性能进行优化\n\n#### (2) objc_class 和 objc_object 数据结构：\n```\ntypedef struct objc_class *Class;\ntypedef struct objc_object *id;\n```\n#### (3) objc_object 和 isa\nobjc_object 源代码在 objc-private.h line 75, 关键代码如下：\n```\nstruct objc_object {\nprivate:\n    isa_t isa;\n\npublic:\n\n    // ISA() assumes this is NOT a tagged pointer object\n    Class ISA();\n\n    // getIsa() allows this to be a tagged pointer object\n    Class getIsa();\n}\n```\nobjc_object 中的 isa，对应类型为联合体 isa_t，源代码在 objc-private.h line 61, 关键代码定义如下：\n```\nstruct {\n    uintptr_t nonpointer        : 1;                                         \\         //0:普通指针，1:优化过，使用位域存储更多信息\n    uintptr_t has_assoc         : 1;                                         \\         //对象是否含有或曾经含有关联引用\n    uintptr_t has_cxx_dtor      : 1;                                         \\         //表示是否有 C++ 析构函数或OC的 dealloc\n    uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\         //存放着 Class、Meta-Class 对象的内存地址信息\n    uintptr_t magic             : 6;                                         \\         //用于在调试时分辨对象是否未完成初始化\n    uintptr_t weakly_referenced : 1;                                         \\         //是否被弱引用指向\n    uintptr_t deallocating      : 1;                                         \\         //对象是否正在释放\n    uintptr_t has_sidetable_rc  : 1;                                         \\         //是否需要使用 sidetable 来存储引用计数\n    uintptr_t extra_rc          : 8                                                    //引用计数能够用 8 个二进制位存储时，直接存储在这里\n}\n```\n#### (4) objc_class\nobjc_class 源代码可在 objc-runtime-new.h line 1111 看到，由于 objc_class 继承自 objc_object， 所以其关键结构可简化如下:\n```\nstruct objc_class : objc_object {\n    isa_t isa;                 // Class ISA;\n    Class superclass;\n    cache_t cache;             // formerly cache pointer and vtable\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n\n    class_rw_t *data() { \n        return bits.data();\n    }\n}\n```\nobjc_object 用来描述 OC 中的实例，当用口语描述实例时，总会说 「XX类的实例x」或「x是XX的实例」。objc_object 的 isa 在程序结构上表达类似的含义，它指向了该实例所对应的类，类在 runtime 中被描述成 objc_class 结构。\nObjective-C 中的类本质上也是对象，称之为类对象，在 Objective-C 中有一个非常特殊的类 NSObject ，绝大部分的类都继承自它。它是 Objective-C 中的两个根类（rootclass）之一，另外一个是 NSProxy。\nNSObject 只有一个成员变量 isa。所有继承自 NSObject 的类也都会有这个成员变量。\n\n#### (5) 元类（metaclass），根类（root class），根元类（root metaclass）\n本质上 Objective-C 中的类也是对象，它也是某个类的实例，这个类我们称之为元类（metaclass）。元类也是对象（元类对象），元类也是某个类的实例，这个类我们称之为根元类（root metaclass）。\n不过，有一点比较特殊，那就是所有的元类所属的类都是同一个根元类（当然根元类也是元类，所以它所属的类也是根元类，即它本身）。根元类指的就是根类的元类，具体来说就是根类 NSObject 对应的元类。\n\n通过调用类方法，比如 [NSObject new]，给类对象发送消息。同样的，类对象能否响应这个消息也要通过 isa 找到类对象所属的类（元类）才能知道。也就是说，实例方法是保存在类中的，而类方法是保存在元类中的。理论上我们也可以给元类发送消息，但是 Objective-C 倾向于隐藏元类，不想让大家知道元类的存在。元类是为了保持 Objective-C 对象模型在设计上的完整性而引入的，比如用来保存类方法等，它主要是用来给编译器使用的。\n\n下图是为类（class），元类（metaclass），根类（root class），根元类（root metaclass）关系\n![](iOS-Runtime/object_model.png)\n#### (6) superclass\n指向该类的父类，如果该类已经是最顶层的根类（如 NSObject 或 NSProxy），则 superclass 为 NULL。\n#### (7) cache_t\ncache_t 是一个散列表，用来缓存曾经调用过的方法，提高方法的查找速度。\n源代码可在 objc-runtime-new.h line 59 找到，其关键结构如下:\n```\nstruct cache_t {\n    struct bucket_t *_buckets;     // 散列表\n    mask_t _mask;                  // 散列表的长度 -1\n    mask_t _occupied;              // 已经缓存的方法数量\n}\n\nstruct bucket_t {\n    cache_key_t _key;              // SEL 作为 key\n    MethodCacheIMP _imp;           // 函数的内存地址\n};\n```\n**buckets：**指向 Method 数据结构指针的数组。这个数组可能包含不超过 mask+1 个元素。需要注意的是，指针可能是 NULL，表示这个缓存 bucket 没有被占用，另外被占用的 bucket 可能是不连续的。这个数组可能会随着时间而增长。\n\n**mask：**一个整数，指定分配的缓存 bucket 的总数。在方法查找过程中，Objective-C runtime 使用这个字段来确定开始线性查找数组的索引未知。指向方法 selector 的指针与该字段做一个 AND 位操作（index = (mask & selector)）。这可以作为一个简单的 hash 散列算法。\n\n**occupied：**一个整数，指定实际占用的缓存 bucket 的总数。\n\n#### (8) class_data_bits_t\nclass_data_bits_t 是一个结构体，里面包含了一个 class_rw_t 类型的指针 data。class_rw_t 内部有个 class_ro_t 的指针 ro。class_rw_t 是可读可写的，class_ro_t 是只读的。 class_data_bits_t 源代码可以在 objc-runtime-new.h line 870 看到。\n\n**class_rw_t 结构如下：**\n```\nstruct class_rw_t {\n    // Be warned that Symbolication knows the layout of this structure.\n    uint32_t flags;\n    uint32_t version;\n\n    const class_ro_t *ro;             // 保存类的原始数据(不包含分类内容和动态添加的方法)\n    method_array_t methods;           // 方法列表(如果是类对象存储的是对象方法,元类对象存储的是类方法)\n    property_array_t properties;      // 属性列表\n    protocol_array_t protocols;       // 协议列表\n    Class firstSubclass;              // 第一个子类\n    Class nextSiblingClass;           // 兄弟类\n}\n\n```\n\n**class_ro_t 储存了类的初始信息，不包括分类和后来动态添加的内容。class_ro_t 关键代码如下：**\n```\nstruct class_ro_t {\n    uint32_t flags;\n    uint32_t instanceStart;\n    uint32_t instanceSize;\n#ifdef __LP64__\n    uint32_t reserved;\n#endif\n\n    const uint8_t * ivarLayout;\n    \n    const char * name;                    // 类名\n    method_list_t * baseMethodList;       // 原始方法列表\n    protocol_list_t * baseProtocols;      // 原始协议列表\n    const ivar_list_t * ivars;            // 成员变量列表\n\n    const uint8_t * weakIvarLayout;\n    property_list_t *baseProperties;      // 属性列表\n\n    method_list_t *baseMethods() const {\n        return baseMethodList;\n    }\n}\n\n```\n**method_list_t 数组包含了多个 method_t，其中 method_t 也是结构体 ，其关键结构如下：**\n```\nstruct method_t {\n    SEL name;               // 函数名\n    const char *types;      // 方法参数 (包含了返回值类型,参数类型)\n    MethodListIMP imp;      // 方法的实现 (指向函数的指针)\n}\n```\n**ivar_list_t 数组包含了多个 ivar_t 类型的结构体 ivar，ivar_t 结构如下：**\n\n```\nstruct ivar_t {\n    int32_t *offset;               // 变量在内存中相对所属对象内存空间起始地址的偏移量,偏移量大小根据类型来定\n    const char *name;              // 变量名\n    const char *type;              // 变量类型\n    // alignment is sometimes -1; use alignment() instead\n    uint32_t alignment_raw;\n    uint32_t size;\n\n    uint32_t alignment() const {\n        if (alignment_raw == ~(uint32_t)0) return 1U << WORD_SHIFT;\n        return 1 << alignment_raw;\n    }\n}\n```\n**property_list_t 数组包含多个 property_t，property_t 结构如下：**\n```\nstruct property_t {\n    const char *name;             \n    const char *attributes;        \n}\n```\n\nclass_ro_t 包含的类信息（方法、属性、协议等）都是在编译期就可以确定的，暂且称为元信息吧，在之后的逻辑中，它们显然是不希望被改变的；后续在用户层，无论是方法还是别的扩展，都是在 class_rw_t 上进行操作，这些操作都不会影响类的元信息。更多关于 class_rw_t 和 class_ro_t 的资料可查看 [这篇文章](https://zhangbuhuai.com/post/runtime.html)。\n\n### 4. 类和对象相关操作方法\n操作类相关的函数一般以 class 为前缀，操作对象相关函数以 objc 或 object_ 为前缀。可在开篇 Runtime 函数文档查看相关方法。\n\n#### (1) 类相关操作函数\t\n```\n\tconst char * class_getName ( Class cls )           // 获取类名\n\n\tClass class_getSuperclass ( Class cls )            // 获取父类\n\n\tBOOL class_isMetaClass ( Class cls )               // 判断给定的类是不是元类\n\n\tsize_t class_getInstanceSize ( Class cls )         // 获取类的实例大小\n\n\tint class_getVersion ( Class cls )                 // 获取版本号\n\n\tvoid class_setVersion ( Class cls, int version )   // 设置版本号\n\n\n```\n\n#### (2) 成员变量 (ivars) 和属性相关操作函数\n```\n\tIvar class_getInstanceVariable ( Class cls, const char *name )                                           // 获取类中指定名称实例成员变量的信息\n\n\tIvar class_getClassVariable ( Class cls, const char *name )                                              // 获取类成员变量的信息\n\n\tBOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types )    // 在 runtime 时创建的类添加成员变量\n\n\tIvar * class_copyIvarList ( Class cls, unsigned int *outCount )                                          // 获取整个成员变量列表，必须使用 free() 来释放\n\n\n```\n#### (3) method 相关操作函数\n```\n\tBOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types )       // 添加方法，和成员变量不同的是可以为类动态添加方法。如果有同名会返回 NO，修改的话需要使用 method_setImplementation\n\n\tMethod class_getInstanceMethod ( Class cls, SEL name )                         // 获取实例方法\n\n\tMethod class_getClassMethod ( Class cls, SEL name )                            // 获取类方法\n\n\tMethod * class_copyMethodList ( Class cls, unsigned int *outCount )            // 获取所有方法\n\n\tIMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types )    // 实现替换方法\n\n\tIMP class_getMethodImplementation ( Class cls, SEL name )                      // 返回方法的具体实现\n\n\tIMP class_getMethodImplementation_stret ( Class cls, SEL name )                // 返回方法的具体实现\n\n\tBOOL class_respondsToSelector ( Class cls, SEL sel )                           // 类实例是否响应指定的 selector\n\n\n\n```\n#### (4) protocol 相关操作函数\n```\n\tBOOL class_addProtocol ( Class cls, Protocol *protocol )                       // 添加协议\n\n\tBOOL class_conformsToProtocol ( Class cls, Protocol *protocol )                // 返回类是否实现指定的协议\n\n\tProtocol * class_copyProtocolList ( Class cls, unsigned int *outCount )        // 获取类实现的协议列表\n\n\n```\n\n#### (5) 相关示例代码：\n\n\n### 5. 消息与消息转发\n#### (1) Method 基础数据结构：\n  Method 是 method_t 结构体的指针，method_t 在分析 method_list_t 已写出其结构，其结构中包括 SEL 和 IMP 两种数据结构。\n\n**SEL:**\nObjective-C 在编译的时候，objc_selector 会依据方法的名字、参数序列、生成一个整型标识的地址\n( int 类型的地址)：这个标识就是 SEL，其结构如下：\n\n```\n\ttypedef struct objc_selector *SEL\n```\n**IMP：**\n是一个函数指针，指向方法实现的地址。其结构如下：\n```\n\t/// A pointer to the function of a method implementation. \n\t#if !OBJC_OLD_DISPATCH_PROTOTYPES\n\ttypedef void (*IMP)(void /* id, SEL, ... */ ); \n\t#else\n\ttypedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); \n\t#endif\n```\n**SEL 和 IMP 为映射关系：**SEL 通过 Dispatch table 表寻找到对应的 IMP， Dispatch table 表 (哈希表) 存放 SEL 和 IMP 的映射。我们可以对一个编号 (SEL) 和什么方法 (IMP) 映射做些操作，也就是说我们可以一个 SEL 指向不同的函数指针，这样就可以完成一个方法名在不同时候执行不同的函数体。\n#### (2) 相关操作方法：\n```\n\n```\n\n## Swift Runtime\n","source":"_posts/iOS-Runtime.md","raw":"---\ntitle: iOS-Runtime\ndate: 2019-05-30 10:25:47\ntags: iOS\n---\n\n## Objc Runtime\n  源代码下载地址：[http://www.opensource.apple.com/source/objc4/](http://www.opensource.apple.com/source/objc4/)\n\n  Runtime 函数文档: [https://developer.apple.com/documentation/objectivec/objective-c_runtime](https://developer.apple.com/documentation/objectivec/objective-c_runtime)\n\n  苹果官方 Runtime 编程指南：\n  [https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048)\n### 1. 概念\n Objective-C 是一门动态语言，它将很多静态语言在编译和链接时做的事情推迟到运行时来处理。\n\n 这种动态特性意味着 Objective-C 不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。\n 对于 Objective-C 来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。\n\n Runtime 就是使用 C 和汇编写的一个运行时库，一般我们说 Runtime，不但包含运行时库的意思，还包含了运行时、运行时系统等概念。\n\n**Objc Runtime 使得 C 具有了面向对象能力，可以在程序运行时创建、检查、修改类、对象和它们的方法**。\n\n### 2. Runtime 的作用：\n#### (1) 封装\n Runtime 库中，对象可以用 C 语言中的结构体表示，而方法可以用 C 函数来实现，再加上了一些其他的特性。这些结构体和函数被 runtime 函数封装后，就可以在程序运行时创建、检查、修改类、对象和它们的方法了。\n#### (2) 找到方法的最终执行代码\n 当程序中执行 [receiver message] 时，会向消息接收者（receiver）发送一条消息 message，runtime 会根据消息接收者是否能响应该消息而做出不同的反应，即消息转发的流程。\n### 3. 类和对象（Class 和 Object）相关的基本数据结构\n#### (1) 关键词：\n Class：指向了 objc_class 结构体的指针 \n\tid：参数类型，指向某个类实例的指针 \n\tMethod：代表了类中的某个方法的类型\n\tSEL：方法选择器，全名是 selector\n\tIMP：函数指针，由编译器生成，方法实现的代码就是由 IMP 指定\n\tIvar：成员变量的类型\n\tProperty：属性存储器\n\tCache：方法调用的缓存器，为方法调用的性能进行优化\n\n#### (2) objc_class 和 objc_object 数据结构：\n```\ntypedef struct objc_class *Class;\ntypedef struct objc_object *id;\n```\n#### (3) objc_object 和 isa\nobjc_object 源代码在 objc-private.h line 75, 关键代码如下：\n```\nstruct objc_object {\nprivate:\n    isa_t isa;\n\npublic:\n\n    // ISA() assumes this is NOT a tagged pointer object\n    Class ISA();\n\n    // getIsa() allows this to be a tagged pointer object\n    Class getIsa();\n}\n```\nobjc_object 中的 isa，对应类型为联合体 isa_t，源代码在 objc-private.h line 61, 关键代码定义如下：\n```\nstruct {\n    uintptr_t nonpointer        : 1;                                         \\         //0:普通指针，1:优化过，使用位域存储更多信息\n    uintptr_t has_assoc         : 1;                                         \\         //对象是否含有或曾经含有关联引用\n    uintptr_t has_cxx_dtor      : 1;                                         \\         //表示是否有 C++ 析构函数或OC的 dealloc\n    uintptr_t shiftcls          : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\         //存放着 Class、Meta-Class 对象的内存地址信息\n    uintptr_t magic             : 6;                                         \\         //用于在调试时分辨对象是否未完成初始化\n    uintptr_t weakly_referenced : 1;                                         \\         //是否被弱引用指向\n    uintptr_t deallocating      : 1;                                         \\         //对象是否正在释放\n    uintptr_t has_sidetable_rc  : 1;                                         \\         //是否需要使用 sidetable 来存储引用计数\n    uintptr_t extra_rc          : 8                                                    //引用计数能够用 8 个二进制位存储时，直接存储在这里\n}\n```\n#### (4) objc_class\nobjc_class 源代码可在 objc-runtime-new.h line 1111 看到，由于 objc_class 继承自 objc_object， 所以其关键结构可简化如下:\n```\nstruct objc_class : objc_object {\n    isa_t isa;                 // Class ISA;\n    Class superclass;\n    cache_t cache;             // formerly cache pointer and vtable\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n\n    class_rw_t *data() { \n        return bits.data();\n    }\n}\n```\nobjc_object 用来描述 OC 中的实例，当用口语描述实例时，总会说 「XX类的实例x」或「x是XX的实例」。objc_object 的 isa 在程序结构上表达类似的含义，它指向了该实例所对应的类，类在 runtime 中被描述成 objc_class 结构。\nObjective-C 中的类本质上也是对象，称之为类对象，在 Objective-C 中有一个非常特殊的类 NSObject ，绝大部分的类都继承自它。它是 Objective-C 中的两个根类（rootclass）之一，另外一个是 NSProxy。\nNSObject 只有一个成员变量 isa。所有继承自 NSObject 的类也都会有这个成员变量。\n\n#### (5) 元类（metaclass），根类（root class），根元类（root metaclass）\n本质上 Objective-C 中的类也是对象，它也是某个类的实例，这个类我们称之为元类（metaclass）。元类也是对象（元类对象），元类也是某个类的实例，这个类我们称之为根元类（root metaclass）。\n不过，有一点比较特殊，那就是所有的元类所属的类都是同一个根元类（当然根元类也是元类，所以它所属的类也是根元类，即它本身）。根元类指的就是根类的元类，具体来说就是根类 NSObject 对应的元类。\n\n通过调用类方法，比如 [NSObject new]，给类对象发送消息。同样的，类对象能否响应这个消息也要通过 isa 找到类对象所属的类（元类）才能知道。也就是说，实例方法是保存在类中的，而类方法是保存在元类中的。理论上我们也可以给元类发送消息，但是 Objective-C 倾向于隐藏元类，不想让大家知道元类的存在。元类是为了保持 Objective-C 对象模型在设计上的完整性而引入的，比如用来保存类方法等，它主要是用来给编译器使用的。\n\n下图是为类（class），元类（metaclass），根类（root class），根元类（root metaclass）关系\n![](iOS-Runtime/object_model.png)\n#### (6) superclass\n指向该类的父类，如果该类已经是最顶层的根类（如 NSObject 或 NSProxy），则 superclass 为 NULL。\n#### (7) cache_t\ncache_t 是一个散列表，用来缓存曾经调用过的方法，提高方法的查找速度。\n源代码可在 objc-runtime-new.h line 59 找到，其关键结构如下:\n```\nstruct cache_t {\n    struct bucket_t *_buckets;     // 散列表\n    mask_t _mask;                  // 散列表的长度 -1\n    mask_t _occupied;              // 已经缓存的方法数量\n}\n\nstruct bucket_t {\n    cache_key_t _key;              // SEL 作为 key\n    MethodCacheIMP _imp;           // 函数的内存地址\n};\n```\n**buckets：**指向 Method 数据结构指针的数组。这个数组可能包含不超过 mask+1 个元素。需要注意的是，指针可能是 NULL，表示这个缓存 bucket 没有被占用，另外被占用的 bucket 可能是不连续的。这个数组可能会随着时间而增长。\n\n**mask：**一个整数，指定分配的缓存 bucket 的总数。在方法查找过程中，Objective-C runtime 使用这个字段来确定开始线性查找数组的索引未知。指向方法 selector 的指针与该字段做一个 AND 位操作（index = (mask & selector)）。这可以作为一个简单的 hash 散列算法。\n\n**occupied：**一个整数，指定实际占用的缓存 bucket 的总数。\n\n#### (8) class_data_bits_t\nclass_data_bits_t 是一个结构体，里面包含了一个 class_rw_t 类型的指针 data。class_rw_t 内部有个 class_ro_t 的指针 ro。class_rw_t 是可读可写的，class_ro_t 是只读的。 class_data_bits_t 源代码可以在 objc-runtime-new.h line 870 看到。\n\n**class_rw_t 结构如下：**\n```\nstruct class_rw_t {\n    // Be warned that Symbolication knows the layout of this structure.\n    uint32_t flags;\n    uint32_t version;\n\n    const class_ro_t *ro;             // 保存类的原始数据(不包含分类内容和动态添加的方法)\n    method_array_t methods;           // 方法列表(如果是类对象存储的是对象方法,元类对象存储的是类方法)\n    property_array_t properties;      // 属性列表\n    protocol_array_t protocols;       // 协议列表\n    Class firstSubclass;              // 第一个子类\n    Class nextSiblingClass;           // 兄弟类\n}\n\n```\n\n**class_ro_t 储存了类的初始信息，不包括分类和后来动态添加的内容。class_ro_t 关键代码如下：**\n```\nstruct class_ro_t {\n    uint32_t flags;\n    uint32_t instanceStart;\n    uint32_t instanceSize;\n#ifdef __LP64__\n    uint32_t reserved;\n#endif\n\n    const uint8_t * ivarLayout;\n    \n    const char * name;                    // 类名\n    method_list_t * baseMethodList;       // 原始方法列表\n    protocol_list_t * baseProtocols;      // 原始协议列表\n    const ivar_list_t * ivars;            // 成员变量列表\n\n    const uint8_t * weakIvarLayout;\n    property_list_t *baseProperties;      // 属性列表\n\n    method_list_t *baseMethods() const {\n        return baseMethodList;\n    }\n}\n\n```\n**method_list_t 数组包含了多个 method_t，其中 method_t 也是结构体 ，其关键结构如下：**\n```\nstruct method_t {\n    SEL name;               // 函数名\n    const char *types;      // 方法参数 (包含了返回值类型,参数类型)\n    MethodListIMP imp;      // 方法的实现 (指向函数的指针)\n}\n```\n**ivar_list_t 数组包含了多个 ivar_t 类型的结构体 ivar，ivar_t 结构如下：**\n\n```\nstruct ivar_t {\n    int32_t *offset;               // 变量在内存中相对所属对象内存空间起始地址的偏移量,偏移量大小根据类型来定\n    const char *name;              // 变量名\n    const char *type;              // 变量类型\n    // alignment is sometimes -1; use alignment() instead\n    uint32_t alignment_raw;\n    uint32_t size;\n\n    uint32_t alignment() const {\n        if (alignment_raw == ~(uint32_t)0) return 1U << WORD_SHIFT;\n        return 1 << alignment_raw;\n    }\n}\n```\n**property_list_t 数组包含多个 property_t，property_t 结构如下：**\n```\nstruct property_t {\n    const char *name;             \n    const char *attributes;        \n}\n```\n\nclass_ro_t 包含的类信息（方法、属性、协议等）都是在编译期就可以确定的，暂且称为元信息吧，在之后的逻辑中，它们显然是不希望被改变的；后续在用户层，无论是方法还是别的扩展，都是在 class_rw_t 上进行操作，这些操作都不会影响类的元信息。更多关于 class_rw_t 和 class_ro_t 的资料可查看 [这篇文章](https://zhangbuhuai.com/post/runtime.html)。\n\n### 4. 类和对象相关操作方法\n操作类相关的函数一般以 class 为前缀，操作对象相关函数以 objc 或 object_ 为前缀。可在开篇 Runtime 函数文档查看相关方法。\n\n#### (1) 类相关操作函数\t\n```\n\tconst char * class_getName ( Class cls )           // 获取类名\n\n\tClass class_getSuperclass ( Class cls )            // 获取父类\n\n\tBOOL class_isMetaClass ( Class cls )               // 判断给定的类是不是元类\n\n\tsize_t class_getInstanceSize ( Class cls )         // 获取类的实例大小\n\n\tint class_getVersion ( Class cls )                 // 获取版本号\n\n\tvoid class_setVersion ( Class cls, int version )   // 设置版本号\n\n\n```\n\n#### (2) 成员变量 (ivars) 和属性相关操作函数\n```\n\tIvar class_getInstanceVariable ( Class cls, const char *name )                                           // 获取类中指定名称实例成员变量的信息\n\n\tIvar class_getClassVariable ( Class cls, const char *name )                                              // 获取类成员变量的信息\n\n\tBOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types )    // 在 runtime 时创建的类添加成员变量\n\n\tIvar * class_copyIvarList ( Class cls, unsigned int *outCount )                                          // 获取整个成员变量列表，必须使用 free() 来释放\n\n\n```\n#### (3) method 相关操作函数\n```\n\tBOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types )       // 添加方法，和成员变量不同的是可以为类动态添加方法。如果有同名会返回 NO，修改的话需要使用 method_setImplementation\n\n\tMethod class_getInstanceMethod ( Class cls, SEL name )                         // 获取实例方法\n\n\tMethod class_getClassMethod ( Class cls, SEL name )                            // 获取类方法\n\n\tMethod * class_copyMethodList ( Class cls, unsigned int *outCount )            // 获取所有方法\n\n\tIMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types )    // 实现替换方法\n\n\tIMP class_getMethodImplementation ( Class cls, SEL name )                      // 返回方法的具体实现\n\n\tIMP class_getMethodImplementation_stret ( Class cls, SEL name )                // 返回方法的具体实现\n\n\tBOOL class_respondsToSelector ( Class cls, SEL sel )                           // 类实例是否响应指定的 selector\n\n\n\n```\n#### (4) protocol 相关操作函数\n```\n\tBOOL class_addProtocol ( Class cls, Protocol *protocol )                       // 添加协议\n\n\tBOOL class_conformsToProtocol ( Class cls, Protocol *protocol )                // 返回类是否实现指定的协议\n\n\tProtocol * class_copyProtocolList ( Class cls, unsigned int *outCount )        // 获取类实现的协议列表\n\n\n```\n\n#### (5) 相关示例代码：\n\n\n### 5. 消息与消息转发\n#### (1) Method 基础数据结构：\n  Method 是 method_t 结构体的指针，method_t 在分析 method_list_t 已写出其结构，其结构中包括 SEL 和 IMP 两种数据结构。\n\n**SEL:**\nObjective-C 在编译的时候，objc_selector 会依据方法的名字、参数序列、生成一个整型标识的地址\n( int 类型的地址)：这个标识就是 SEL，其结构如下：\n\n```\n\ttypedef struct objc_selector *SEL\n```\n**IMP：**\n是一个函数指针，指向方法实现的地址。其结构如下：\n```\n\t/// A pointer to the function of a method implementation. \n\t#if !OBJC_OLD_DISPATCH_PROTOTYPES\n\ttypedef void (*IMP)(void /* id, SEL, ... */ ); \n\t#else\n\ttypedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); \n\t#endif\n```\n**SEL 和 IMP 为映射关系：**SEL 通过 Dispatch table 表寻找到对应的 IMP， Dispatch table 表 (哈希表) 存放 SEL 和 IMP 的映射。我们可以对一个编号 (SEL) 和什么方法 (IMP) 映射做些操作，也就是说我们可以一个 SEL 指向不同的函数指针，这样就可以完成一个方法名在不同时候执行不同的函数体。\n#### (2) 相关操作方法：\n```\n\n```\n\n## Swift Runtime\n","slug":"iOS-Runtime","published":1,"updated":"2019-06-02T07:39:53.625Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwemxnpb000gods6qpdv1rsq","content":"<h2 id=\"Objc-Runtime\"><a href=\"#Objc-Runtime\" class=\"headerlink\" title=\"Objc Runtime\"></a>Objc Runtime</h2><p>  源代码下载地址：<a href=\"http://www.opensource.apple.com/source/objc4/\" target=\"_blank\" rel=\"noopener\">http://www.opensource.apple.com/source/objc4/</a></p>\n<p>  Runtime 函数文档: <a href=\"https://developer.apple.com/documentation/objectivec/objective-c_runtime\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/documentation/objectivec/objective-c_runtime</a></p>\n<p>  苹果官方 Runtime 编程指南：<br>  <a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048</a></p>\n<h3 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1. 概念\"></a>1. 概念</h3><p> Objective-C 是一门动态语言，它将很多静态语言在编译和链接时做的事情推迟到运行时来处理。</p>\n<p> 这种动态特性意味着 Objective-C 不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。<br> 对于 Objective-C 来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。</p>\n<p> Runtime 就是使用 C 和汇编写的一个运行时库，一般我们说 Runtime，不但包含运行时库的意思，还包含了运行时、运行时系统等概念。</p>\n<p><strong>Objc Runtime 使得 C 具有了面向对象能力，可以在程序运行时创建、检查、修改类、对象和它们的方法</strong>。</p>\n<h3 id=\"2-Runtime-的作用：\"><a href=\"#2-Runtime-的作用：\" class=\"headerlink\" title=\"2. Runtime 的作用：\"></a>2. Runtime 的作用：</h3><h4 id=\"1-封装\"><a href=\"#1-封装\" class=\"headerlink\" title=\"(1) 封装\"></a>(1) 封装</h4><p> Runtime 库中，对象可以用 C 语言中的结构体表示，而方法可以用 C 函数来实现，再加上了一些其他的特性。这些结构体和函数被 runtime 函数封装后，就可以在程序运行时创建、检查、修改类、对象和它们的方法了。</p>\n<h4 id=\"2-找到方法的最终执行代码\"><a href=\"#2-找到方法的最终执行代码\" class=\"headerlink\" title=\"(2) 找到方法的最终执行代码\"></a>(2) 找到方法的最终执行代码</h4><p> 当程序中执行 [receiver message] 时，会向消息接收者（receiver）发送一条消息 message，runtime 会根据消息接收者是否能响应该消息而做出不同的反应，即消息转发的流程。</p>\n<h3 id=\"3-类和对象（Class-和-Object）相关的基本数据结构\"><a href=\"#3-类和对象（Class-和-Object）相关的基本数据结构\" class=\"headerlink\" title=\"3. 类和对象（Class 和 Object）相关的基本数据结构\"></a>3. 类和对象（Class 和 Object）相关的基本数据结构</h3><h4 id=\"1-关键词：\"><a href=\"#1-关键词：\" class=\"headerlink\" title=\"(1) 关键词：\"></a>(1) 关键词：</h4><p> Class：指向了 objc_class 结构体的指针<br>    id：参数类型，指向某个类实例的指针<br>    Method：代表了类中的某个方法的类型<br>    SEL：方法选择器，全名是 selector<br>    IMP：函数指针，由编译器生成，方法实现的代码就是由 IMP 指定<br>    Ivar：成员变量的类型<br>    Property：属性存储器<br>    Cache：方法调用的缓存器，为方法调用的性能进行优化</p>\n<h4 id=\"2-objc-class-和-objc-object-数据结构：\"><a href=\"#2-objc-class-和-objc-object-数据结构：\" class=\"headerlink\" title=\"(2) objc_class 和 objc_object 数据结构：\"></a>(2) objc_class 和 objc_object 数据结构：</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_class</span> *<span class=\"title\">Class</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_object</span> *<span class=\"title\">id</span>;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-objc-object-和-isa\"><a href=\"#3-objc-object-和-isa\" class=\"headerlink\" title=\"(3) objc_object 和 isa\"></a>(3) objc_object 和 isa</h4><p>objc_object 源代码在 objc-private.h line 75, 关键代码如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_object</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">isa_t</span> isa;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class=\"line\">    <span class=\"function\">Class <span class=\"title\">ISA</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// getIsa() allows this to be a tagged pointer object</span></span><br><span class=\"line\">    <span class=\"function\">Class <span class=\"title\">getIsa</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>objc_object 中的 isa，对应类型为联合体 isa_t，源代码在 objc-private.h line 61, 关键代码定义如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> nonpointer        : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//0:普通指针，1:优化过，使用位域存储更多信息</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> has_assoc         : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//对象是否含有或曾经含有关联引用</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> has_cxx_dtor      : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//表示是否有 C++ 析构函数或OC的 dealloc</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> shiftcls          : <span class=\"number\">44</span>; <span class=\"comment\">/*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/</span> \\         <span class=\"comment\">//存放着 Class、Meta-Class 对象的内存地址信息</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> magic             : <span class=\"number\">6</span>;                                         \\         <span class=\"comment\">//用于在调试时分辨对象是否未完成初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> weakly_referenced : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//是否被弱引用指向</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> deallocating      : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//对象是否正在释放</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> has_sidetable_rc  : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//是否需要使用 sidetable 来存储引用计数</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> extra_rc          : <span class=\"number\">8</span>                                                    <span class=\"comment\">//引用计数能够用 8 个二进制位存储时，直接存储在这里</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-objc-class\"><a href=\"#4-objc-class\" class=\"headerlink\" title=\"(4) objc_class\"></a>(4) objc_class</h4><p>objc_class 源代码可在 objc-runtime-new.h line 1111 看到，由于 objc_class 继承自 objc_object， 所以其关键结构可简化如下:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_class</span> :</span> objc_object &#123;</span><br><span class=\"line\">    <span class=\"keyword\">isa_t</span> isa;                 <span class=\"comment\">// Class ISA;</span></span><br><span class=\"line\">    Class superclass;</span><br><span class=\"line\">    <span class=\"keyword\">cache_t</span> cache;             <span class=\"comment\">// formerly cache pointer and vtable</span></span><br><span class=\"line\">    <span class=\"keyword\">class_data_bits_t</span> bits;    <span class=\"comment\">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">class_rw_t</span> *data() &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> bits.data();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>objc_object 用来描述 OC 中的实例，当用口语描述实例时，总会说 「XX类的实例x」或「x是XX的实例」。objc_object 的 isa 在程序结构上表达类似的含义，它指向了该实例所对应的类，类在 runtime 中被描述成 objc_class 结构。<br>Objective-C 中的类本质上也是对象，称之为类对象，在 Objective-C 中有一个非常特殊的类 NSObject ，绝大部分的类都继承自它。它是 Objective-C 中的两个根类（rootclass）之一，另外一个是 NSProxy。<br>NSObject 只有一个成员变量 isa。所有继承自 NSObject 的类也都会有这个成员变量。</p>\n<h4 id=\"5-元类（metaclass），根类（root-class），根元类（root-metaclass）\"><a href=\"#5-元类（metaclass），根类（root-class），根元类（root-metaclass）\" class=\"headerlink\" title=\"(5) 元类（metaclass），根类（root class），根元类（root metaclass）\"></a>(5) 元类（metaclass），根类（root class），根元类（root metaclass）</h4><p>本质上 Objective-C 中的类也是对象，它也是某个类的实例，这个类我们称之为元类（metaclass）。元类也是对象（元类对象），元类也是某个类的实例，这个类我们称之为根元类（root metaclass）。<br>不过，有一点比较特殊，那就是所有的元类所属的类都是同一个根元类（当然根元类也是元类，所以它所属的类也是根元类，即它本身）。根元类指的就是根类的元类，具体来说就是根类 NSObject 对应的元类。</p>\n<p>通过调用类方法，比如 [NSObject new]，给类对象发送消息。同样的，类对象能否响应这个消息也要通过 isa 找到类对象所属的类（元类）才能知道。也就是说，实例方法是保存在类中的，而类方法是保存在元类中的。理论上我们也可以给元类发送消息，但是 Objective-C 倾向于隐藏元类，不想让大家知道元类的存在。元类是为了保持 Objective-C 对象模型在设计上的完整性而引入的，比如用来保存类方法等，它主要是用来给编译器使用的。</p>\n<p>下图是为类（class），元类（metaclass），根类（root class），根元类（root metaclass）关系<br><img src=\"/2019/05/30/iOS-Runtime/object_model.png\" alt=\"\"></p>\n<h4 id=\"6-superclass\"><a href=\"#6-superclass\" class=\"headerlink\" title=\"(6) superclass\"></a>(6) superclass</h4><p>指向该类的父类，如果该类已经是最顶层的根类（如 NSObject 或 NSProxy），则 superclass 为 NULL。</p>\n<h4 id=\"7-cache-t\"><a href=\"#7-cache-t\" class=\"headerlink\" title=\"(7) cache_t\"></a>(7) cache_t</h4><p>cache_t 是一个散列表，用来缓存曾经调用过的方法，提高方法的查找速度。<br>源代码可在 objc-runtime-new.h line 59 找到，其关键结构如下:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cache_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket_t</span> *_<span class=\"title\">buckets</span>;</span>     <span class=\"comment\">// 散列表</span></span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> _mask;                  <span class=\"comment\">// 散列表的长度 -1</span></span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> _occupied;              <span class=\"comment\">// 已经缓存的方法数量</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">cache_key_t</span> _key;              <span class=\"comment\">// SEL 作为 key</span></span><br><span class=\"line\">    MethodCacheIMP _imp;           <span class=\"comment\">// 函数的内存地址</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>buckets：</strong>指向 Method 数据结构指针的数组。这个数组可能包含不超过 mask+1 个元素。需要注意的是，指针可能是 NULL，表示这个缓存 bucket 没有被占用，另外被占用的 bucket 可能是不连续的。这个数组可能会随着时间而增长。</p>\n<p><strong>mask：</strong>一个整数，指定分配的缓存 bucket 的总数。在方法查找过程中，Objective-C runtime 使用这个字段来确定开始线性查找数组的索引未知。指向方法 selector 的指针与该字段做一个 AND 位操作（index = (mask &amp; selector)）。这可以作为一个简单的 hash 散列算法。</p>\n<p><strong>occupied：</strong>一个整数，指定实际占用的缓存 bucket 的总数。</p>\n<h4 id=\"8-class-data-bits-t\"><a href=\"#8-class-data-bits-t\" class=\"headerlink\" title=\"(8) class_data_bits_t\"></a>(8) class_data_bits_t</h4><p>class_data_bits_t 是一个结构体，里面包含了一个 class_rw_t 类型的指针 data。class_rw_t 内部有个 class_ro_t 的指针 ro。class_rw_t 是可读可写的，class_ro_t 是只读的。 class_data_bits_t 源代码可以在 objc-runtime-new.h line 870 看到。</p>\n<p><strong>class_rw_t 结构如下：</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">class_rw_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> flags;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> version;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">class_ro_t</span> *ro;             <span class=\"comment\">// 保存类的原始数据(不包含分类内容和动态添加的方法)</span></span><br><span class=\"line\">    <span class=\"keyword\">method_array_t</span> methods;           <span class=\"comment\">// 方法列表(如果是类对象存储的是对象方法,元类对象存储的是类方法)</span></span><br><span class=\"line\">    <span class=\"keyword\">property_array_t</span> properties;      <span class=\"comment\">// 属性列表</span></span><br><span class=\"line\">    <span class=\"keyword\">protocol_array_t</span> protocols;       <span class=\"comment\">// 协议列表</span></span><br><span class=\"line\">    Class firstSubclass;              <span class=\"comment\">// 第一个子类</span></span><br><span class=\"line\">    Class nextSiblingClass;           <span class=\"comment\">// 兄弟类</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>class_ro_t 储存了类的初始信息，不包括分类和后来动态添加的内容。class_ro_t 关键代码如下：</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">class_ro_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> flags;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> instanceStart;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> instanceSize;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __LP64__</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> reserved;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">uint8_t</span> * ivarLayout;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * name;                    <span class=\"comment\">// 类名</span></span><br><span class=\"line\">    <span class=\"keyword\">method_list_t</span> * baseMethodList;       <span class=\"comment\">// 原始方法列表</span></span><br><span class=\"line\">    <span class=\"keyword\">protocol_list_t</span> * baseProtocols;      <span class=\"comment\">// 原始协议列表</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">ivar_list_t</span> * ivars;            <span class=\"comment\">// 成员变量列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">uint8_t</span> * weakIvarLayout;</span><br><span class=\"line\">    <span class=\"keyword\">property_list_t</span> *baseProperties;      <span class=\"comment\">// 属性列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">method_list_t</span> *baseMethods() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> baseMethodList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>method_list_t 数组包含了多个 method_t，其中 method_t 也是结构体 ，其关键结构如下：</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">method_t</span> &#123;</span></span><br><span class=\"line\">    SEL name;               <span class=\"comment\">// 函数名</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types;      <span class=\"comment\">// 方法参数 (包含了返回值类型,参数类型)</span></span><br><span class=\"line\">    MethodListIMP imp;      <span class=\"comment\">// 方法的实现 (指向函数的指针)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>ivar_list_t 数组包含了多个 ivar_t 类型的结构体 ivar，ivar_t 结构如下：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ivar_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int32_t</span> *offset;               <span class=\"comment\">// 变量在内存中相对所属对象内存空间起始地址的偏移量,偏移量大小根据类型来定</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;              <span class=\"comment\">// 变量名</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *type;              <span class=\"comment\">// 变量类型</span></span><br><span class=\"line\">    <span class=\"comment\">// alignment is sometimes -1; use alignment() instead</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> alignment_raw;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> alignment() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (alignment_raw == ~(<span class=\"keyword\">uint32_t</span>)<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1U</span> &lt;&lt; WORD_SHIFT;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> &lt;&lt; alignment_raw;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>property_list_t 数组包含多个 property_t，property_t 结构如下：</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">property_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;             </span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *attributes;        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>class_ro_t 包含的类信息（方法、属性、协议等）都是在编译期就可以确定的，暂且称为元信息吧，在之后的逻辑中，它们显然是不希望被改变的；后续在用户层，无论是方法还是别的扩展，都是在 class_rw_t 上进行操作，这些操作都不会影响类的元信息。更多关于 class_rw_t 和 class_ro_t 的资料可查看 <a href=\"https://zhangbuhuai.com/post/runtime.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</p>\n<h3 id=\"4-类和对象相关操作方法\"><a href=\"#4-类和对象相关操作方法\" class=\"headerlink\" title=\"4. 类和对象相关操作方法\"></a>4. 类和对象相关操作方法</h3><p>操作类相关的函数一般以 class 为前缀，操作对象相关函数以 objc 或 object_ 为前缀。可在开篇 Runtime 函数文档查看相关方法。</p>\n<h4 id=\"1-类相关操作函数\"><a href=\"#1-类相关操作函数\" class=\"headerlink\" title=\"(1) 类相关操作函数\"></a>(1) 类相关操作函数</h4><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const <span class=\"keyword\">char</span> * class_getName ( <span class=\"keyword\">Class</span> cls )           <span class=\"comment\">// 获取类名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Class</span> class_getSuperclass ( <span class=\"keyword\">Class</span> cls )            <span class=\"comment\">// 获取父类</span></span><br><span class=\"line\"></span><br><span class=\"line\">BOOL class_isMetaClass ( <span class=\"keyword\">Class</span> cls )               <span class=\"comment\">// 判断给定的类是不是元类</span></span><br><span class=\"line\"></span><br><span class=\"line\">size_t class_getInstanceSize ( <span class=\"keyword\">Class</span> cls )         <span class=\"comment\">// 获取类的实例大小</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> class_getVersion ( <span class=\"keyword\">Class</span> cls )                 <span class=\"comment\">// 获取版本号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> class_setVersion ( <span class=\"keyword\">Class</span> cls, <span class=\"keyword\">int</span> version )   <span class=\"comment\">// 设置版本号</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-成员变量-ivars-和属性相关操作函数\"><a href=\"#2-成员变量-ivars-和属性相关操作函数\" class=\"headerlink\" title=\"(2) 成员变量 (ivars) 和属性相关操作函数\"></a>(2) 成员变量 (ivars) 和属性相关操作函数</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Ivar <span class=\"title\">class_getInstanceVariable</span> <span class=\"params\">( Class cls, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name )</span>                                           <span class=\"comment\">// 获取类中指定名称实例成员变量的信息</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">Ivar <span class=\"title\">class_getClassVariable</span> <span class=\"params\">( Class cls, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name )</span>                                              <span class=\"comment\">// 获取类成员变量的信息</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">class_addIvar</span> <span class=\"params\">( Class cls, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">uint8_t</span> alignment, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types )</span>    <span class=\"comment\">// 在 runtime 时创建的类添加成员变量</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">Ivar * <span class=\"title\">class_copyIvarList</span> <span class=\"params\">( Class cls, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *outCount )</span>                                          <span class=\"comment\">// 获取整个成员变量列表，必须使用 free() 来释放</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-method-相关操作函数\"><a href=\"#3-method-相关操作函数\" class=\"headerlink\" title=\"(3) method 相关操作函数\"></a>(3) method 相关操作函数</h4><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BOOL class_addMethod ( <span class=\"keyword\">Class</span> cls, SEL name, IMP imp, <span class=\"keyword\">const</span> char *types )       <span class=\"comment\">// 添加方法，和成员变量不同的是可以为类动态添加方法。如果有同名会返回 NO，修改的话需要使用 method_setImplementation</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">Method</span> <span class=\"title\">class_getInstanceMethod</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL name )</span>                         // 获取实例方法</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Method</span> <span class=\"title\">class_getClassMethod</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL name )</span>                            // 获取类方法</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Method</span> * <span class=\"title\">class_copyMethodList</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, unsigned int *outCount )</span>            // 获取所有方法</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">IMP</span> <span class=\"title\">class_replaceMethod</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL name, IMP imp, <span class=\"keyword\">const</span> char *types )</span>    // 实现替换方法</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">IMP</span> <span class=\"title\">class_getMethodImplementation</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL name )</span>                      // 返回方法的具体实现</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">IMP</span> <span class=\"title\">class_getMethodImplementation_stret</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL name )</span>                // 返回方法的具体实现</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">BOOL</span> <span class=\"title\">class_respondsToSelector</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL sel )</span>                           // 类实例是否响应指定的 <span class=\"title\">selector</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"4-protocol-相关操作函数\"><a href=\"#4-protocol-相关操作函数\" class=\"headerlink\" title=\"(4) protocol 相关操作函数\"></a>(4) protocol 相关操作函数</h4><figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">BOOL</span> class_addProtocol ( Class <span class=\"keyword\">cls</span>, Protocol *protocol )                       <span class=\"comment\">// 添加协议</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">BOOL</span> class_conformsToProtocol ( Class <span class=\"keyword\">cls</span>, Protocol *protocol )                <span class=\"comment\">// 返回类是否实现指定的协议</span></span><br><span class=\"line\"></span><br><span class=\"line\">Protocol * class_copyProtocolList ( Class <span class=\"keyword\">cls</span>, unsigned int *outCount )        <span class=\"comment\">// 获取类实现的协议列表</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"5-相关示例代码：\"><a href=\"#5-相关示例代码：\" class=\"headerlink\" title=\"(5) 相关示例代码：\"></a>(5) 相关示例代码：</h4><h3 id=\"5-消息与消息转发\"><a href=\"#5-消息与消息转发\" class=\"headerlink\" title=\"5. 消息与消息转发\"></a>5. 消息与消息转发</h3><h4 id=\"1-Method-基础数据结构：\"><a href=\"#1-Method-基础数据结构：\" class=\"headerlink\" title=\"(1) Method 基础数据结构：\"></a>(1) Method 基础数据结构：</h4><p>  Method 是 method_t 结构体的指针，method_t 在分析 method_list_t 已写出其结构，其结构中包括 SEL 和 IMP 两种数据结构。</p>\n<p><strong>SEL:</strong><br>Objective-C 在编译的时候，objc_selector 会依据方法的名字、参数序列、生成一个整型标识的地址<br>( int 类型的地址)：这个标识就是 SEL，其结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_selector</span> *<span class=\"title\">SEL</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>IMP：</strong><br>是一个函数指针，指向方法实现的地址。其结构如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// A pointer to the function of a method implementation. </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*IMP)</span><span class=\"params\">(<span class=\"keyword\">void</span> <span class=\"comment\">/* id, SEL, ... */</span> )</span></span>; </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong>SEL 和 IMP 为映射关系：</strong>SEL 通过 Dispatch table 表寻找到对应的 IMP， Dispatch table 表 (哈希表) 存放 SEL 和 IMP 的映射。我们可以对一个编号 (SEL) 和什么方法 (IMP) 映射做些操作，也就是说我们可以一个 SEL 指向不同的函数指针，这样就可以完成一个方法名在不同时候执行不同的函数体。</p>\n<h4 id=\"2-相关操作方法：\"><a href=\"#2-相关操作方法：\" class=\"headerlink\" title=\"(2) 相关操作方法：\"></a>(2) 相关操作方法：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Swift-Runtime\"><a href=\"#Swift-Runtime\" class=\"headerlink\" title=\"Swift Runtime\"></a>Swift Runtime</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Objc-Runtime\"><a href=\"#Objc-Runtime\" class=\"headerlink\" title=\"Objc Runtime\"></a>Objc Runtime</h2><p>  源代码下载地址：<a href=\"http://www.opensource.apple.com/source/objc4/\" target=\"_blank\" rel=\"noopener\">http://www.opensource.apple.com/source/objc4/</a></p>\n<p>  Runtime 函数文档: <a href=\"https://developer.apple.com/documentation/objectivec/objective-c_runtime\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/documentation/objectivec/objective-c_runtime</a></p>\n<p>  苹果官方 Runtime 编程指南：<br>  <a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048</a></p>\n<h3 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1. 概念\"></a>1. 概念</h3><p> Objective-C 是一门动态语言，它将很多静态语言在编译和链接时做的事情推迟到运行时来处理。</p>\n<p> 这种动态特性意味着 Objective-C 不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。<br> 对于 Objective-C 来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。</p>\n<p> Runtime 就是使用 C 和汇编写的一个运行时库，一般我们说 Runtime，不但包含运行时库的意思，还包含了运行时、运行时系统等概念。</p>\n<p><strong>Objc Runtime 使得 C 具有了面向对象能力，可以在程序运行时创建、检查、修改类、对象和它们的方法</strong>。</p>\n<h3 id=\"2-Runtime-的作用：\"><a href=\"#2-Runtime-的作用：\" class=\"headerlink\" title=\"2. Runtime 的作用：\"></a>2. Runtime 的作用：</h3><h4 id=\"1-封装\"><a href=\"#1-封装\" class=\"headerlink\" title=\"(1) 封装\"></a>(1) 封装</h4><p> Runtime 库中，对象可以用 C 语言中的结构体表示，而方法可以用 C 函数来实现，再加上了一些其他的特性。这些结构体和函数被 runtime 函数封装后，就可以在程序运行时创建、检查、修改类、对象和它们的方法了。</p>\n<h4 id=\"2-找到方法的最终执行代码\"><a href=\"#2-找到方法的最终执行代码\" class=\"headerlink\" title=\"(2) 找到方法的最终执行代码\"></a>(2) 找到方法的最终执行代码</h4><p> 当程序中执行 [receiver message] 时，会向消息接收者（receiver）发送一条消息 message，runtime 会根据消息接收者是否能响应该消息而做出不同的反应，即消息转发的流程。</p>\n<h3 id=\"3-类和对象（Class-和-Object）相关的基本数据结构\"><a href=\"#3-类和对象（Class-和-Object）相关的基本数据结构\" class=\"headerlink\" title=\"3. 类和对象（Class 和 Object）相关的基本数据结构\"></a>3. 类和对象（Class 和 Object）相关的基本数据结构</h3><h4 id=\"1-关键词：\"><a href=\"#1-关键词：\" class=\"headerlink\" title=\"(1) 关键词：\"></a>(1) 关键词：</h4><p> Class：指向了 objc_class 结构体的指针<br>    id：参数类型，指向某个类实例的指针<br>    Method：代表了类中的某个方法的类型<br>    SEL：方法选择器，全名是 selector<br>    IMP：函数指针，由编译器生成，方法实现的代码就是由 IMP 指定<br>    Ivar：成员变量的类型<br>    Property：属性存储器<br>    Cache：方法调用的缓存器，为方法调用的性能进行优化</p>\n<h4 id=\"2-objc-class-和-objc-object-数据结构：\"><a href=\"#2-objc-class-和-objc-object-数据结构：\" class=\"headerlink\" title=\"(2) objc_class 和 objc_object 数据结构：\"></a>(2) objc_class 和 objc_object 数据结构：</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_class</span> *<span class=\"title\">Class</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_object</span> *<span class=\"title\">id</span>;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-objc-object-和-isa\"><a href=\"#3-objc-object-和-isa\" class=\"headerlink\" title=\"(3) objc_object 和 isa\"></a>(3) objc_object 和 isa</h4><p>objc_object 源代码在 objc-private.h line 75, 关键代码如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_object</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">isa_t</span> isa;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class=\"line\">    <span class=\"function\">Class <span class=\"title\">ISA</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// getIsa() allows this to be a tagged pointer object</span></span><br><span class=\"line\">    <span class=\"function\">Class <span class=\"title\">getIsa</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>objc_object 中的 isa，对应类型为联合体 isa_t，源代码在 objc-private.h line 61, 关键代码定义如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> nonpointer        : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//0:普通指针，1:优化过，使用位域存储更多信息</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> has_assoc         : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//对象是否含有或曾经含有关联引用</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> has_cxx_dtor      : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//表示是否有 C++ 析构函数或OC的 dealloc</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> shiftcls          : <span class=\"number\">44</span>; <span class=\"comment\">/*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/</span> \\         <span class=\"comment\">//存放着 Class、Meta-Class 对象的内存地址信息</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> magic             : <span class=\"number\">6</span>;                                         \\         <span class=\"comment\">//用于在调试时分辨对象是否未完成初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> weakly_referenced : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//是否被弱引用指向</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> deallocating      : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//对象是否正在释放</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> has_sidetable_rc  : <span class=\"number\">1</span>;                                         \\         <span class=\"comment\">//是否需要使用 sidetable 来存储引用计数</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> extra_rc          : <span class=\"number\">8</span>                                                    <span class=\"comment\">//引用计数能够用 8 个二进制位存储时，直接存储在这里</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-objc-class\"><a href=\"#4-objc-class\" class=\"headerlink\" title=\"(4) objc_class\"></a>(4) objc_class</h4><p>objc_class 源代码可在 objc-runtime-new.h line 1111 看到，由于 objc_class 继承自 objc_object， 所以其关键结构可简化如下:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_class</span> :</span> objc_object &#123;</span><br><span class=\"line\">    <span class=\"keyword\">isa_t</span> isa;                 <span class=\"comment\">// Class ISA;</span></span><br><span class=\"line\">    Class superclass;</span><br><span class=\"line\">    <span class=\"keyword\">cache_t</span> cache;             <span class=\"comment\">// formerly cache pointer and vtable</span></span><br><span class=\"line\">    <span class=\"keyword\">class_data_bits_t</span> bits;    <span class=\"comment\">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">class_rw_t</span> *data() &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> bits.data();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>objc_object 用来描述 OC 中的实例，当用口语描述实例时，总会说 「XX类的实例x」或「x是XX的实例」。objc_object 的 isa 在程序结构上表达类似的含义，它指向了该实例所对应的类，类在 runtime 中被描述成 objc_class 结构。<br>Objective-C 中的类本质上也是对象，称之为类对象，在 Objective-C 中有一个非常特殊的类 NSObject ，绝大部分的类都继承自它。它是 Objective-C 中的两个根类（rootclass）之一，另外一个是 NSProxy。<br>NSObject 只有一个成员变量 isa。所有继承自 NSObject 的类也都会有这个成员变量。</p>\n<h4 id=\"5-元类（metaclass），根类（root-class），根元类（root-metaclass）\"><a href=\"#5-元类（metaclass），根类（root-class），根元类（root-metaclass）\" class=\"headerlink\" title=\"(5) 元类（metaclass），根类（root class），根元类（root metaclass）\"></a>(5) 元类（metaclass），根类（root class），根元类（root metaclass）</h4><p>本质上 Objective-C 中的类也是对象，它也是某个类的实例，这个类我们称之为元类（metaclass）。元类也是对象（元类对象），元类也是某个类的实例，这个类我们称之为根元类（root metaclass）。<br>不过，有一点比较特殊，那就是所有的元类所属的类都是同一个根元类（当然根元类也是元类，所以它所属的类也是根元类，即它本身）。根元类指的就是根类的元类，具体来说就是根类 NSObject 对应的元类。</p>\n<p>通过调用类方法，比如 [NSObject new]，给类对象发送消息。同样的，类对象能否响应这个消息也要通过 isa 找到类对象所属的类（元类）才能知道。也就是说，实例方法是保存在类中的，而类方法是保存在元类中的。理论上我们也可以给元类发送消息，但是 Objective-C 倾向于隐藏元类，不想让大家知道元类的存在。元类是为了保持 Objective-C 对象模型在设计上的完整性而引入的，比如用来保存类方法等，它主要是用来给编译器使用的。</p>\n<p>下图是为类（class），元类（metaclass），根类（root class），根元类（root metaclass）关系<br><img src=\"/2019/05/30/iOS-Runtime/object_model.png\" alt=\"\"></p>\n<h4 id=\"6-superclass\"><a href=\"#6-superclass\" class=\"headerlink\" title=\"(6) superclass\"></a>(6) superclass</h4><p>指向该类的父类，如果该类已经是最顶层的根类（如 NSObject 或 NSProxy），则 superclass 为 NULL。</p>\n<h4 id=\"7-cache-t\"><a href=\"#7-cache-t\" class=\"headerlink\" title=\"(7) cache_t\"></a>(7) cache_t</h4><p>cache_t 是一个散列表，用来缓存曾经调用过的方法，提高方法的查找速度。<br>源代码可在 objc-runtime-new.h line 59 找到，其关键结构如下:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cache_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket_t</span> *_<span class=\"title\">buckets</span>;</span>     <span class=\"comment\">// 散列表</span></span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> _mask;                  <span class=\"comment\">// 散列表的长度 -1</span></span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> _occupied;              <span class=\"comment\">// 已经缓存的方法数量</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">cache_key_t</span> _key;              <span class=\"comment\">// SEL 作为 key</span></span><br><span class=\"line\">    MethodCacheIMP _imp;           <span class=\"comment\">// 函数的内存地址</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>buckets：</strong>指向 Method 数据结构指针的数组。这个数组可能包含不超过 mask+1 个元素。需要注意的是，指针可能是 NULL，表示这个缓存 bucket 没有被占用，另外被占用的 bucket 可能是不连续的。这个数组可能会随着时间而增长。</p>\n<p><strong>mask：</strong>一个整数，指定分配的缓存 bucket 的总数。在方法查找过程中，Objective-C runtime 使用这个字段来确定开始线性查找数组的索引未知。指向方法 selector 的指针与该字段做一个 AND 位操作（index = (mask &amp; selector)）。这可以作为一个简单的 hash 散列算法。</p>\n<p><strong>occupied：</strong>一个整数，指定实际占用的缓存 bucket 的总数。</p>\n<h4 id=\"8-class-data-bits-t\"><a href=\"#8-class-data-bits-t\" class=\"headerlink\" title=\"(8) class_data_bits_t\"></a>(8) class_data_bits_t</h4><p>class_data_bits_t 是一个结构体，里面包含了一个 class_rw_t 类型的指针 data。class_rw_t 内部有个 class_ro_t 的指针 ro。class_rw_t 是可读可写的，class_ro_t 是只读的。 class_data_bits_t 源代码可以在 objc-runtime-new.h line 870 看到。</p>\n<p><strong>class_rw_t 结构如下：</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">class_rw_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> flags;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> version;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">class_ro_t</span> *ro;             <span class=\"comment\">// 保存类的原始数据(不包含分类内容和动态添加的方法)</span></span><br><span class=\"line\">    <span class=\"keyword\">method_array_t</span> methods;           <span class=\"comment\">// 方法列表(如果是类对象存储的是对象方法,元类对象存储的是类方法)</span></span><br><span class=\"line\">    <span class=\"keyword\">property_array_t</span> properties;      <span class=\"comment\">// 属性列表</span></span><br><span class=\"line\">    <span class=\"keyword\">protocol_array_t</span> protocols;       <span class=\"comment\">// 协议列表</span></span><br><span class=\"line\">    Class firstSubclass;              <span class=\"comment\">// 第一个子类</span></span><br><span class=\"line\">    Class nextSiblingClass;           <span class=\"comment\">// 兄弟类</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>class_ro_t 储存了类的初始信息，不包括分类和后来动态添加的内容。class_ro_t 关键代码如下：</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">class_ro_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> flags;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> instanceStart;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> instanceSize;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __LP64__</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> reserved;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">uint8_t</span> * ivarLayout;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * name;                    <span class=\"comment\">// 类名</span></span><br><span class=\"line\">    <span class=\"keyword\">method_list_t</span> * baseMethodList;       <span class=\"comment\">// 原始方法列表</span></span><br><span class=\"line\">    <span class=\"keyword\">protocol_list_t</span> * baseProtocols;      <span class=\"comment\">// 原始协议列表</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">ivar_list_t</span> * ivars;            <span class=\"comment\">// 成员变量列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">uint8_t</span> * weakIvarLayout;</span><br><span class=\"line\">    <span class=\"keyword\">property_list_t</span> *baseProperties;      <span class=\"comment\">// 属性列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">method_list_t</span> *baseMethods() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> baseMethodList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>method_list_t 数组包含了多个 method_t，其中 method_t 也是结构体 ，其关键结构如下：</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">method_t</span> &#123;</span></span><br><span class=\"line\">    SEL name;               <span class=\"comment\">// 函数名</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types;      <span class=\"comment\">// 方法参数 (包含了返回值类型,参数类型)</span></span><br><span class=\"line\">    MethodListIMP imp;      <span class=\"comment\">// 方法的实现 (指向函数的指针)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>ivar_list_t 数组包含了多个 ivar_t 类型的结构体 ivar，ivar_t 结构如下：</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ivar_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int32_t</span> *offset;               <span class=\"comment\">// 变量在内存中相对所属对象内存空间起始地址的偏移量,偏移量大小根据类型来定</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;              <span class=\"comment\">// 变量名</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *type;              <span class=\"comment\">// 变量类型</span></span><br><span class=\"line\">    <span class=\"comment\">// alignment is sometimes -1; use alignment() instead</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> alignment_raw;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> alignment() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (alignment_raw == ~(<span class=\"keyword\">uint32_t</span>)<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1U</span> &lt;&lt; WORD_SHIFT;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> &lt;&lt; alignment_raw;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>property_list_t 数组包含多个 property_t，property_t 结构如下：</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">property_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;             </span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *attributes;        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>class_ro_t 包含的类信息（方法、属性、协议等）都是在编译期就可以确定的，暂且称为元信息吧，在之后的逻辑中，它们显然是不希望被改变的；后续在用户层，无论是方法还是别的扩展，都是在 class_rw_t 上进行操作，这些操作都不会影响类的元信息。更多关于 class_rw_t 和 class_ro_t 的资料可查看 <a href=\"https://zhangbuhuai.com/post/runtime.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</p>\n<h3 id=\"4-类和对象相关操作方法\"><a href=\"#4-类和对象相关操作方法\" class=\"headerlink\" title=\"4. 类和对象相关操作方法\"></a>4. 类和对象相关操作方法</h3><p>操作类相关的函数一般以 class 为前缀，操作对象相关函数以 objc 或 object_ 为前缀。可在开篇 Runtime 函数文档查看相关方法。</p>\n<h4 id=\"1-类相关操作函数\"><a href=\"#1-类相关操作函数\" class=\"headerlink\" title=\"(1) 类相关操作函数\"></a>(1) 类相关操作函数</h4><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const <span class=\"keyword\">char</span> * class_getName ( <span class=\"keyword\">Class</span> cls )           <span class=\"comment\">// 获取类名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Class</span> class_getSuperclass ( <span class=\"keyword\">Class</span> cls )            <span class=\"comment\">// 获取父类</span></span><br><span class=\"line\"></span><br><span class=\"line\">BOOL class_isMetaClass ( <span class=\"keyword\">Class</span> cls )               <span class=\"comment\">// 判断给定的类是不是元类</span></span><br><span class=\"line\"></span><br><span class=\"line\">size_t class_getInstanceSize ( <span class=\"keyword\">Class</span> cls )         <span class=\"comment\">// 获取类的实例大小</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> class_getVersion ( <span class=\"keyword\">Class</span> cls )                 <span class=\"comment\">// 获取版本号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> class_setVersion ( <span class=\"keyword\">Class</span> cls, <span class=\"keyword\">int</span> version )   <span class=\"comment\">// 设置版本号</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-成员变量-ivars-和属性相关操作函数\"><a href=\"#2-成员变量-ivars-和属性相关操作函数\" class=\"headerlink\" title=\"(2) 成员变量 (ivars) 和属性相关操作函数\"></a>(2) 成员变量 (ivars) 和属性相关操作函数</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Ivar <span class=\"title\">class_getInstanceVariable</span> <span class=\"params\">( Class cls, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name )</span>                                           <span class=\"comment\">// 获取类中指定名称实例成员变量的信息</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">Ivar <span class=\"title\">class_getClassVariable</span> <span class=\"params\">( Class cls, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name )</span>                                              <span class=\"comment\">// 获取类成员变量的信息</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">class_addIvar</span> <span class=\"params\">( Class cls, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">uint8_t</span> alignment, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types )</span>    <span class=\"comment\">// 在 runtime 时创建的类添加成员变量</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">Ivar * <span class=\"title\">class_copyIvarList</span> <span class=\"params\">( Class cls, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *outCount )</span>                                          <span class=\"comment\">// 获取整个成员变量列表，必须使用 free() 来释放</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-method-相关操作函数\"><a href=\"#3-method-相关操作函数\" class=\"headerlink\" title=\"(3) method 相关操作函数\"></a>(3) method 相关操作函数</h4><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BOOL class_addMethod ( <span class=\"keyword\">Class</span> cls, SEL name, IMP imp, <span class=\"keyword\">const</span> char *types )       <span class=\"comment\">// 添加方法，和成员变量不同的是可以为类动态添加方法。如果有同名会返回 NO，修改的话需要使用 method_setImplementation</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">Method</span> <span class=\"title\">class_getInstanceMethod</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL name )</span>                         // 获取实例方法</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Method</span> <span class=\"title\">class_getClassMethod</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL name )</span>                            // 获取类方法</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Method</span> * <span class=\"title\">class_copyMethodList</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, unsigned int *outCount )</span>            // 获取所有方法</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">IMP</span> <span class=\"title\">class_replaceMethod</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL name, IMP imp, <span class=\"keyword\">const</span> char *types )</span>    // 实现替换方法</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">IMP</span> <span class=\"title\">class_getMethodImplementation</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL name )</span>                      // 返回方法的具体实现</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">IMP</span> <span class=\"title\">class_getMethodImplementation_stret</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL name )</span>                // 返回方法的具体实现</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">BOOL</span> <span class=\"title\">class_respondsToSelector</span> <span class=\"params\">( <span class=\"keyword\">Class</span> cls, SEL sel )</span>                           // 类实例是否响应指定的 <span class=\"title\">selector</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"4-protocol-相关操作函数\"><a href=\"#4-protocol-相关操作函数\" class=\"headerlink\" title=\"(4) protocol 相关操作函数\"></a>(4) protocol 相关操作函数</h4><figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">BOOL</span> class_addProtocol ( Class <span class=\"keyword\">cls</span>, Protocol *protocol )                       <span class=\"comment\">// 添加协议</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">BOOL</span> class_conformsToProtocol ( Class <span class=\"keyword\">cls</span>, Protocol *protocol )                <span class=\"comment\">// 返回类是否实现指定的协议</span></span><br><span class=\"line\"></span><br><span class=\"line\">Protocol * class_copyProtocolList ( Class <span class=\"keyword\">cls</span>, unsigned int *outCount )        <span class=\"comment\">// 获取类实现的协议列表</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"5-相关示例代码：\"><a href=\"#5-相关示例代码：\" class=\"headerlink\" title=\"(5) 相关示例代码：\"></a>(5) 相关示例代码：</h4><h3 id=\"5-消息与消息转发\"><a href=\"#5-消息与消息转发\" class=\"headerlink\" title=\"5. 消息与消息转发\"></a>5. 消息与消息转发</h3><h4 id=\"1-Method-基础数据结构：\"><a href=\"#1-Method-基础数据结构：\" class=\"headerlink\" title=\"(1) Method 基础数据结构：\"></a>(1) Method 基础数据结构：</h4><p>  Method 是 method_t 结构体的指针，method_t 在分析 method_list_t 已写出其结构，其结构中包括 SEL 和 IMP 两种数据结构。</p>\n<p><strong>SEL:</strong><br>Objective-C 在编译的时候，objc_selector 会依据方法的名字、参数序列、生成一个整型标识的地址<br>( int 类型的地址)：这个标识就是 SEL，其结构如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_selector</span> *<span class=\"title\">SEL</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>IMP：</strong><br>是一个函数指针，指向方法实现的地址。其结构如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// A pointer to the function of a method implementation. </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(*IMP)</span><span class=\"params\">(<span class=\"keyword\">void</span> <span class=\"comment\">/* id, SEL, ... */</span> )</span></span>; </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong>SEL 和 IMP 为映射关系：</strong>SEL 通过 Dispatch table 表寻找到对应的 IMP， Dispatch table 表 (哈希表) 存放 SEL 和 IMP 的映射。我们可以对一个编号 (SEL) 和什么方法 (IMP) 映射做些操作，也就是说我们可以一个 SEL 指向不同的函数指针，这样就可以完成一个方法名在不同时候执行不同的函数体。</p>\n<h4 id=\"2-相关操作方法：\"><a href=\"#2-相关操作方法：\" class=\"headerlink\" title=\"(2) 相关操作方法：\"></a>(2) 相关操作方法：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Swift-Runtime\"><a href=\"#Swift-Runtime\" class=\"headerlink\" title=\"Swift Runtime\"></a>Swift Runtime</h2>"}],"PostAsset":[{"_id":"source/_posts/Git-常用命令/git_sections.png","slug":"git_sections.png","post":"cjwemxmyo0000ods6e8gnf7tm","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint1.png","slug":"breakpoint1.png","post":"cjwemxmz10006ods6pu5e052z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint11.png","slug":"breakpoint11.png","post":"cjwemxmz10006ods6pu5e052z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint12.png","slug":"breakpoint12.png","post":"cjwemxmz10006ods6pu5e052z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint13.png","slug":"breakpoint13.png","post":"cjwemxmz10006ods6pu5e052z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint14.png","slug":"breakpoint14.png","post":"cjwemxmz10006ods6pu5e052z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint15.png","slug":"breakpoint15.png","post":"cjwemxmz10006ods6pu5e052z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint16.png","slug":"breakpoint16.png","post":"cjwemxmz10006ods6pu5e052z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint4.png","slug":"breakpoint4.png","post":"cjwemxmz10006ods6pu5e052z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint5.png","slug":"breakpoint5.png","post":"cjwemxmz10006ods6pu5e052z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint6.png","slug":"breakpoint6.png","post":"cjwemxmz10006ods6pu5e052z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint7.png","slug":"breakpoint7.png","post":"cjwemxmz10006ods6pu5e052z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint8.png","slug":"breakpoint8.png","post":"cjwemxmz10006ods6pu5e052z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-调试技巧/breakpoint9.png","slug":"breakpoint9.png","post":"cjwemxmz10006ods6pu5e052z","modified":0,"renderable":0},{"_id":"source/_posts/iOS-Runtime/object_model.png","slug":"object_model.png","post":"cjwemxnpb000gods6qpdv1rsq","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cjwemxmyo0000ods6e8gnf7tm","tag_id":"cjwemxmyx0003ods6ujxli2mo","_id":"cjwemxmz20008ods6zfa9k5z4"},{"post_id":"cjwemxmyw0002ods65echecsh","tag_id":"cjwemxmz20007ods61d25rz7c","_id":"cjwemxmz3000aods68dzoqawk"},{"post_id":"cjwemxmyz0004ods68t7tqw81","tag_id":"cjwemxmz30009ods6k9o90gff","_id":"cjwemxmz3000cods6i14kmcpy"},{"post_id":"cjwemxmz00005ods6an02gfxw","tag_id":"cjwemxmz3000bods6alailwdy","_id":"cjwemxmz3000eods6otwnbtts"},{"post_id":"cjwemxmz10006ods6pu5e052z","tag_id":"cjwemxmz3000dods65vssgv6l","_id":"cjwemxmz4000fods617sxi2w7"},{"post_id":"cjwemxnpb000gods6qpdv1rsq","tag_id":"cjwemxmz3000bods6alailwdy","_id":"cjwemxnpe000iods64810fcl6"}],"Tag":[{"name":"Git","_id":"cjwemxmyx0003ods6ujxli2mo"},{"name":"SVN","_id":"cjwemxmz20007ods61d25rz7c"},{"name":"Python","_id":"cjwemxmz30009ods6k9o90gff"},{"name":"iOS","_id":"cjwemxmz3000bods6alailwdy"},{"name":"Xcode","_id":"cjwemxmz3000dods65vssgv6l"}]}}